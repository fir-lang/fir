#![allow(clippy::all)]

use crate::ast::*;
use crate::interpolation::{copy_update_escapes, parse_string_parts};
use crate::parser_utils::*;
use crate::token::*;

use std::convert::Infallible;
use std::rc::Rc;

use smol_str::SmolStr;

use lexgen_util::{LexerError, Loc};

grammar<'a>(module: &'a Rc<str>);

extern {
    type Location = Loc;
    type Error = LexerError<Infallible>;

    enum Token {
        UpperId => Token { kind: TokenKind::UpperId, .. },
        UpperIdPath => Token { kind: TokenKind::UpperIdPath, .. },
        UpperIdLBracket => Token { kind: TokenKind::UpperIdLBracket, .. },
        TildeUpperId => Token { kind: TokenKind::TildeUpperId, .. },
        TildeUpperIdPath => Token { kind: TokenKind::TildeUpperIdPath, .. },
        LowerId => Token { kind: TokenKind::LowerId, .. },
        Label => Token { kind: TokenKind::Label, .. },
        "(" => Token { kind: TokenKind::LParen, .. },
        "row(" => Token { kind: TokenKind::LParenRow, .. },
        ")" => Token { kind: TokenKind::RParen, .. },
        "[" => Token { kind: TokenKind::LBracket, .. },
        "row[" => Token { kind: TokenKind::LBracketRow, .. },
        "]" => Token { kind: TokenKind::RBracket, .. },
        "{" => Token { kind: TokenKind::LBrace, .. },
        "}" => Token { kind: TokenKind::RBrace, .. },
        ":" => Token { kind: TokenKind::Colon, .. },
        "," => Token { kind: TokenKind::Comma, .. },
        "." => Token { kind: TokenKind::Dot, .. },
        "=" => Token { kind: TokenKind::Eq, .. },
        ".." => Token { kind: TokenKind::DotDot, .. },
        "..=" => Token { kind: TokenKind::DotDotEq, .. },
        "_" => Token { kind: TokenKind::Underscore, .. },
        "==" => Token { kind: TokenKind::EqEq, .. },
        "+" => Token { kind: TokenKind::Plus, .. },
        "-" => Token { kind: TokenKind::Minus, .. },
        "*" => Token { kind: TokenKind::Star, .. },
        "+=" => Token { kind: TokenKind::PlusEq, .. },
        "-=" => Token { kind: TokenKind::MinusEq, .. },
        "*=" => Token { kind: TokenKind::StarEq, .. },
        "^=" => Token { kind: TokenKind::CaretEq, .. },
        "!" => Token { kind: TokenKind::Exclamation, .. },
        "!=" => Token { kind: TokenKind::ExclamationEq, .. },
        "&" => Token { kind: TokenKind::Amp, .. },
        "&&" => Token { kind: TokenKind::AmpAmp, .. },
        "|" => Token { kind: TokenKind::Pipe, .. },
        "||" => Token { kind: TokenKind::PipePipe, .. },
        "<" => Token { kind: TokenKind::LAngle, .. },
        "<<" => Token { kind: TokenKind::DoubleLAngle, .. },
        "<=" => Token { kind: TokenKind::LAngleEq, .. },
        ">" => Token { kind: TokenKind::RAngle, .. },
        ">>" => Token { kind: TokenKind::DoubleRAngle, .. },
        ">=" => Token { kind: TokenKind::RAngleEq, .. },
        "/" => Token { kind: TokenKind::Slash, .. },
        INDENT => Token { kind: TokenKind::Indent, .. },
        DEDENT => Token { kind: TokenKind::Dedent, .. },
        NEWLINE => Token { kind: TokenKind::Newline, .. },
        "Fn" => Token { kind: TokenKind::UpperFn, .. },
        "as" => Token { kind: TokenKind::As, .. },
        "break" => Token { kind: TokenKind::Break, .. },
        "continue" => Token { kind: TokenKind::Continue, .. },
        "elif" => Token { kind: TokenKind::Elif, .. },
        "else" => Token { kind: TokenKind::Else, .. },
        "fn" => Token { kind: TokenKind::Fn, .. },
        "for" => Token { kind: TokenKind::For, .. },
        "if" => Token { kind: TokenKind::If, .. },
        "impl" => Token { kind: TokenKind::Impl, .. },
        "import" => Token { kind: TokenKind::Import, .. },
        "in" => Token { kind: TokenKind::In, .. },
        "is" => Token { kind: TokenKind::Is, .. },
        "let" => Token { kind: TokenKind::Let, .. },
        "loop" => Token { kind: TokenKind::Loop, .. },
        "match" => Token { kind: TokenKind::Match, .. },
        "prim" => Token { kind: TokenKind::Prim, .. },
        "return" => Token { kind: TokenKind::Return, .. },
        "trait" => Token { kind: TokenKind::Trait, .. },
        "type" => Token { kind: TokenKind::Type, .. },
        "while" => Token { kind: TokenKind::While, .. },
        IntLit => Token { kind: TokenKind::Int { .. }, .. },
        HexIntLit => Token { kind: TokenKind::HexInt { .. }, .. },
        BinIntLit => Token { kind: TokenKind::BinInt { .. }, .. },
        StringLit => Token { kind: TokenKind::String, .. },
        CharLit => Token { kind: TokenKind::Char, .. },
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Utils
//
////////////////////////////////////////////////////////////////////////////////////////////////////

// Note: This allows trailing separator.
Sep<T, S>: Vec<T> = {
    <mut v:(<T> S)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

// Note: This doesn't allow trailing separator.
Sep1<T, S>: Vec<T> = {
    <e0:T> <mut v:(S <T>)*> => {
        v.insert(0, e0);
        v
    }
};

LUpperId: L<Id> = {
    <l:@L> <id:UpperId> <r:@R> => L::new(module, l, r, id.smol_str()),
}

LUpperIdLBracket: L<Id> = {
    <l:@L> <id:UpperIdLBracket> <r:@R> => L::new(module, l, r, id.smol_str()),
}

LLowerId: L<Id> = {
    <l:@L> <id:LowerId> <r:@R> => L::new(module, l, r, id.smol_str()),
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Type declarations
//
////////////////////////////////////////////////////////////////////////////////////////////////////

TypeDecl: L<TypeDecl> = {
    <l:@L> "type" <type_name:UpperId> <rhs:TypeDeclRhs> <r:@R> =>
        L::new(module, l, r, TypeDecl {
            name: type_name.smol_str(),
            type_params: vec![],
            type_param_kinds: vec![],
            rhs: Some(rhs),
        }),

    <l:@L> "type" <type_name:UpperIdLBracket> <type_params:TypeParams> <rhs:TypeDeclRhs> <r:@R> =>
        L::new(module, l, r, TypeDecl {
            name: type_name.smol_str(),
            type_params,
            type_param_kinds: vec![],
            rhs: Some(rhs),
        }),

    <l:@L> "prim"? "type" <type_name:UpperId> NEWLINE <r:@R> =>
        L::new(module, l, r, TypeDecl {
            name: type_name.smol_str(),
            type_params: vec![],
            type_param_kinds: vec![],
            rhs: None,
        }),

    <l:@L> "prim"? "type" <type_name:UpperIdLBracket> <type_params:TypeParams> NEWLINE <r:@R> =>
        L::new(module, l, r, TypeDecl {
            name: type_name.smol_str(),
            type_params,
            type_param_kinds: vec![],
            rhs: None,
        }),
}

TypeDeclRhs: TypeDeclRhs = {
    ":" NEWLINE INDENT <constrs:TypeConstrs> DEDENT =>
        TypeDeclRhs::Sum(constrs),

    ":" NEWLINE INDENT <named_fields:NamedFields> DEDENT =>
        TypeDeclRhs::Product(ConstructorFields::Named(named_fields)),
}

TypeParams: Vec<Id> = {
    <params:Sep<LowerId, ",">> "]" =>
        params.into_iter().map(|id| id.smol_str()).collect(),
}

TypeConstrs: Vec<ConstructorDecl> = {
    ConstructorDecl+
}

ConstructorDecl: ConstructorDecl = {
    <name:UpperId> NEWLINE =>
        ConstructorDecl {
            name: name.smol_str(),
            fields: ConstructorFields::Empty
        },

    <name:UpperId> ":" NEWLINE INDENT <named_fields:NamedFields> DEDENT =>
        ConstructorDecl {
            name: name.smol_str(),
            fields: ConstructorFields::Named(named_fields),
        },

    <name:UpperId> "(" <fields:UnnamedFields> ","? ")" NEWLINE =>
        ConstructorDecl {
            name: name.smol_str(),
            fields: ConstructorFields::Unnamed(fields),
        },
}

NamedFields: Vec<(Id, Type)> = {
    (<NamedField> NEWLINE)+
}

NamedField: (Id, Type) = {
    <name:LowerId> ":" <type_:Type> =>
        (name.smol_str(), type_),
}

UnnamedFields: Vec<Type> = {
    <mut fields:UnnamedFields> "," <field:Type> => {
        fields.push(field);
        fields
    },

    <field:Type> => vec![field],
}

LType: L<Type> = {
    <l:@L> <ty:Type> <r:@R> => L::new(module, l, r, ty),
}

LTypeNamed: L<Type> = {
    <l:@L> <ty:TypeNamed> <r:@R> => L::new(module, l, r, ty),
}

Type: Type = {
    #[precedence(level = "0")]
    <ty:TypeNamed> => ty,

    <var:LowerId> =>
        Type::Var(var.smol_str()),

    #[precedence(level = "1")]
    #[assoc(side = "right")]
    "Fn" "(" <args:Sep<LType, ",">> ")" <ret:ReturnType>  =>
        Type::Fn(FnType {
            args,
            exceptions: ret.0.map(|t| t.map(Box::new)),
            ret: ret.1.map(|t| t.map(|t| Box::new(t))),
        }),

    "(" <fields:Sep<RecordTypeField, ",">> <extension:RowExtension> ")" =>
        Type::Record { fields, extension, is_row: false },

    "row(" <fields:Sep<RecordTypeField, ",">> <extension:RowExtension> ")" =>
        Type::Record { fields, extension, is_row: true },

    "[" <alts:Sep<VariantAlt, ",">> <extension:RowExtension> "]" =>
        Type::Variant { alts, extension, is_row: false },

    "row[" <alts:Sep<VariantAlt, ",">> <extension:RowExtension> "]" =>
        Type::Variant { alts, extension, is_row: true },
}

TypeNoFn: Type = {
    <ty:TypeNamed> => ty,

    <var:LowerId> =>
        Type::Var(var.smol_str()),

    "(" <fields:Sep<RecordTypeField, ",">> <extension:RowExtension> ")" =>
        Type::Record { fields, extension, is_row: false },

    "row(" <fields:Sep<RecordTypeField, ",">> <extension:RowExtension> ")" =>
        Type::Record { fields, extension, is_row: true },

    "[" <alts:Sep<VariantAlt, ",">> <extension:RowExtension> "]" =>
        Type::Variant { alts, extension, is_row: false },

    "row[" <alts:Sep<VariantAlt, ",">> <extension:RowExtension> "]" =>
        Type::Variant { alts, extension, is_row: true },
}

LTypeNoFn: L<Type> = {
    <l:@L> <ty:TypeNoFn> <r:@R> => L::new(module, l, r, ty),
}

TypeNamed: Type = {
    <name:UpperId> =>
        Type::Named(NamedType { name: name.smol_str(), args: vec![] }),

    <name:UpperIdLBracket> <args:Sep<LType, ",">> "]" =>
        Type::Named(NamedType { name: name.smol_str(), args }),
}

RowExtension: Option<Id> = {
    => None,

    ".." <id:LowerId> => Some(id.smol_str()),
}

TypeArg: L<(Option<Id>, L<Type>)> = {
    <l:@L> <name:UpperId> "=" <ty:LType> <r:@R> =>
        L::new(module, l, r, (Some(name.smol_str()), ty)),

    <ty:LType> => {
        let loc = ty.loc.clone();
        L { loc, node: (None, ty) }
    },
}

RecordTypeField: Named<Type> = {
    <name:LowerId> ":" <ty:Type> => Named { name: Some(name.smol_str()), node: ty },
    <ty:Type> => Named { name: None, node: ty },
}

VariantAlt: VariantAlt = {
    <name:UpperId> "(" <fields:Sep<RecordTypeField, ",">> ")" =>
        VariantAlt { con: name.smol_str(), fields },
    <name:UpperId> =>
        VariantAlt { con: name.smol_str(), fields: vec![] },
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function declarations
//
////////////////////////////////////////////////////////////////////////////////////////////////////

FunDecl: L<FunDecl> = {
    // We need two productions here as with two optional bracketed type/pred
    // list we can't tell that one list means only type list.

    // TODO: comma parsing after `self` is not right.

    <l:@L> <sig:FunSig> NEWLINE INDENT <body:LStmts> DEDENT <r:@R> =>
        L::new(module, l, r, FunDecl {
            parent_ty: None,
            name: sig.0,
            sig: sig.1,
            body: Some(body),
        }),

    <l:@L> "prim"? <sig:FunSig> NEWLINE <r:@R> =>
        L::new(module, l, r, FunDecl {
            parent_ty: None,
            name: sig.0,
            sig: sig.1,
            body: None,
        }),

    <l:@L> <sig:FunSig> "=" <rhs:LInlineExpr> NEWLINE <r:@R> => {
        let L { loc, node } = rhs;
        L::new(module, l, r, FunDecl {
            parent_ty: None,
            name: sig.0,
            sig: sig.1,
            body: Some(vec![L { loc: loc.clone(), node: Stmt::Expr(L { loc: loc.clone(), node: node }) }]),
        })
    },
}

FunSig: (L<Id>, FunSig) = {
    <name:LLowerId>
            <context:Context>
            <param_list:ParamList>
            <ret:ReturnType>
            => {
        (name,
            FunSig {
                context,
                self_: param_list.0,
                params: param_list.1,
                exceptions: ret.0,
                return_ty: ret.1,
            })
    },

    <name:LLowerId> <context:Context> <ret:ReturnType> => {
        (name,
            FunSig {
                context,
                self_: SelfParam::No,
                params: vec![],
                exceptions: ret.0,
                return_ty: ret.1,
            })
    },
}

TopFunDecl: L<FunDecl> = {
    <l:@L> <sig:TopFunSig> NEWLINE INDENT <body:LStmts> DEDENT <r:@R> => {
        let (parent_ty, name, sig): (Option<L<Id>>, L<Id>, FunSig) = sig;
        L::new(module, l, r, FunDecl {
            parent_ty,
            name,
            sig,
            body: Some(body),
        })
    },

    <l:@L> "prim"? <sig:TopFunSig> NEWLINE <r:@R> => {
        let (parent_ty, name, sig) = sig;
        L::new(module, l, r, FunDecl {
            parent_ty,
            name,
            sig,
            body: None,
        })
    },

    <l:@L> <sig:TopFunSig> "=" <rhs:LInlineExpr> NEWLINE <r:@R> => {
        let L { loc, node } = rhs;
        let (parent_ty, name, sig) = sig;
        L::new(module, l, r, FunDecl {
            parent_ty,
            name,
            sig,
            body: Some(vec![L { loc: loc.clone(), node: Stmt::Expr(L { loc: loc.clone(), node: node }) }]),
        })
    },
}

TopFunSig: (Option<L<Id>>, L<Id>, FunSig) = {
    <parent_ty:ParentTy?> <name:LLowerId>
            <context:Context>
            <param_list:ParamList>
            <ret:ReturnType>
            => {
        (
            parent_ty,
            name,
            FunSig {
                context,
                self_: param_list.0,
                params: param_list.1,
                exceptions: ret.0,
                return_ty: ret.1,
            }
        )
    },

    <parent_ty:ParentTy?> <name:LLowerId> <context:Context> <ret:ReturnType> => {
        (
            parent_ty,
            name,
            FunSig {
                context,
                self_: SelfParam::No,
                params: vec![],
                exceptions: ret.0,
                return_ty: ret.1,
            }
        )
    },
}

ParamList: (SelfParam, Vec<(Id, Option<L<Type>>)>) = {
    <l:@L> "(" <params:Sep<Param, ",">> ")" => {
        process_param_list(params, module, &l)
    },
}

Param: (SmolStr, Option<L<Type>>) = {
    <id:LowerId> <ty:(":" <LType>)?> => {
        (id.smol_str(), ty)
    },
}

ReturnType: (Option<L<Type>>, Option<L<Type>>) = {
    => (None, None),

    ":" <ty1:LTypeNoFn?> <ty2:LType> => (ty1, Some(ty2)),
}

ParentTy: L<Id> = {
    <ty:LUpperId> "." => ty,
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Statements
//
////////////////////////////////////////////////////////////////////////////////////////////////////

LStmts: Vec<L<Stmt>> = {
    <stmts:LStmt*> =>
        stmts,
}

pub LStmt: L<Stmt> = {
    <l:@L> <stmt:Stmt> <r:@R> => L::new(module, l, r, stmt),
}

Stmt: Stmt = {
    "break" <label:Label?> NEWLINE => Stmt::Break { label: label.map(|l| SmolStr::new(&l.smol_str()[1..])), level: 0 },

    "continue" <label:Label?> NEWLINE => Stmt::Continue { label: label.map(|l| SmolStr::new(&l.smol_str()[1..])), level: 0 },

    "let" <lhs:LPat> <ty:(":" <LType>)?> "=" <rhs:LInlineExpr> NEWLINE =>
        Stmt::Let(LetStmt { lhs, ty, rhs }),

    "let" <lhs:LPat> <ty:(":" <LType>)?> "=" <rhs:LBlockExpr> =>
        Stmt::Let(LetStmt { lhs, ty, rhs }),

    <lhs:LInlineExpr> <op:AssignOp> <rhs:LInlineExpr> NEWLINE =>
        Stmt::Assign(AssignStmt {
            lhs,
            rhs,
            op,
        }),

    <lhs:LInlineExpr> <op:AssignOp> <rhs:LBlockExpr> =>
        Stmt::Assign(AssignStmt {
            lhs,
            rhs,
            op,
        }),

    <l:@L> <expr:InlineExpr> <r:@R> NEWLINE =>
        Stmt::Expr(L::new(module, l, r, expr)),

    <l:@L> <expr:BlockExpr> <r:@R> =>
        Stmt::Expr(L::new(module, l, r, expr)),

    <label:LoopLabel?> "for" <pat:LPat> <ast_ty:(":" <LType>)?> "in" <expr:LExpr> ":" NEWLINE INDENT <body:LStmts> DEDENT =>
        Stmt::For(ForStmt {
            label,
            pat,
            ast_ty,
            tc_ty: None,
            expr,
            expr_ty: None,
            body,
        }),

    <label:LoopLabel?> "while" <cond:LExpr> ":" NEWLINE INDENT <body:LStmts> DEDENT =>
        Stmt::While(WhileStmt {
            label,
            cond,
            body,
        }),

    <label:LoopLabel?> <l:@L> "loop" <r:@R> ":" NEWLINE INDENT <body:LStmts> DEDENT =>
        Stmt::While(WhileStmt {
            label,
            cond: L::new(module, l, r, Expr::ConstrSelect(Constructor {
                ty: SmolStr::new_static("Bool"),
                constr: Some(SmolStr::new_static("True")),
                ty_args: vec![],
            })),
            body,
        }),
}

LoopLabel: SmolStr = {
    <label:Label> ":" => SmolStr::new(&label.smol_str().as_str()[1..])
}

Alts: Vec<Alt> = {
    Alt*
}

Alt: Alt = {
    <pattern:LPat> ":" NEWLINE INDENT <stmts:LStmts> DEDENT =>
        Alt {
            pattern,
            guard: None,
            rhs: stmts,
        },

    <pattern:LPat> "if" <guard:LExpr> ":" NEWLINE INDENT <stmts:LStmts> DEDENT =>
        Alt {
            pattern,
            guard: Some(guard),
            rhs: stmts,
        },

    <pattern:LPat> ":" <stmt:LStmt>  =>
        Alt {
            pattern,
            guard: None,
            rhs: vec![stmt],
        },

    <pattern:LPat> "if" <guard:LExpr> ":" <stmt:LStmt>  =>
        Alt {
            pattern,
            guard: Some(guard),
            rhs: vec![stmt],
        },
}

AssignOp: AssignOp = {
    "=" => AssignOp::Eq,
    "+=" => AssignOp::PlusEq,
    "-=" => AssignOp::MinusEq,
    "*=" => AssignOp::StarEq,
    "^=" => AssignOp::CaretEq,
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Expressions
//
////////////////////////////////////////////////////////////////////////////////////////////////////

pub LExpr: L<Expr> = {
    <l:@L> <expr:Expr> <r:@R> => L::new(module, l, r, expr),
}

Expr: Expr = {
    <expr:InlineExpr> => expr,
    <expr:BlockExpr>  => expr,
}

LBlockExpr: L<Expr> = {
    <l:@L> <expr:BlockExpr> <r:@R> =>
        L::new(module, l, r, expr),
}

// Block expressions are also statements, without a NEWLINE after them.
BlockExpr: Expr = {
    "match" <expr:LInlineExpr> ":" NEWLINE INDENT <alts:Alts> DEDENT =>
        Expr::Match(MatchExpr {
            scrutinee: Box::new(expr),
            alts,
        }),

    "if" <cond:LExpr> ":" NEWLINE INDENT <then_:LStmts> DEDENT
            <mut branches:("elif" <LExpr> ":" NEWLINE INDENT <LStmts> DEDENT)*>
            <else_branch:("else" ":" NEWLINE INDENT <LStmts> DEDENT)?> => {
        branches.insert(0, (cond, then_));
        Expr::If(IfExpr {
            branches,
            else_branch,
        })
    },
}

LInlineExpr: L<Expr> = {
    <l:@L> <expr:InlineExpr> <r:@R> =>
        L::new(module, l, r, expr),
}

// Inline expressions can be made statements with a NEWLINE after them.
InlineExpr: Expr = {
    #[precedence(level = "0")]
    <id:LowerId> => {
        let str = id.smol_str();
        if str == "self" {
            Expr::Self_
        } else {
            Expr::Var(VarExpr { id: str, ty_args: vec![] })
        }
    },

    <id:UpperId> =>
        Expr::ConstrSelect(Constructor { ty: id.smol_str(), constr: None, ty_args: vec![] }),

    <path:UpperIdPath> => {
        let mut parts = path_parts(&path.text);
        let constr = parts.pop().unwrap();
        let ty = parts.pop().unwrap();
        Expr::ConstrSelect(Constructor { ty, constr: Some(constr), ty_args: vec![] })
    },

    "(" <mut exprs:Sep<ParenExpr, ",">> ")" => {
        match exprs.len() {
            0 => Expr::Record(vec![]),
            1 if exprs[0].0.is_none() => exprs.pop().unwrap().1.node,
            _ => Expr::Record(exprs.into_iter().map(|(name, expr)| Named { name: name, node: expr }).collect()),
        }
    },

    <int:IntLit> => {
        let kind = match int.kind {
            TokenKind::Int(int_kind) => int_kind,
            _ => unreachable!(),
        };
        let token_str = &int.text;

        // TODO: Allocate the buffer once and reuse.
        // Even better, build the number as we scan for underscores.
        let mut int_str = String::new();

        // Drop "i8", "u32" etc. suffix.
        let suffix = match kind {
            Some(IntKind::I8) => Some("i8"),
            Some(IntKind::U8) => Some("u8"),
            Some(IntKind::I32) => Some("i32"),
            Some(IntKind::U32) => Some("u32"),
            None => None,
        };

        let token_str = match suffix {
            None => token_str,
            Some(suffix) => token_str.strip_suffix(suffix).unwrap(),
        };

        // Drop '_'s.
        for char in token_str.chars() {
            if char == '_' {
                continue;
            }
            int_str.push(char);
        }

        Expr::Int(IntExpr {
            text: int_str,
            suffix: kind,
            radix: 10,
            parsed: 0,
        })
    },

    <int:HexIntLit> => {
        let kind = match int.kind {
            TokenKind::HexInt(int_kind) => int_kind,
            _ => unreachable!(),
        };
        debug_assert!(int.text.starts_with("0x"));
        let token_str = &int.text["0x".len()..];

        // TODO: Allocate the buffer once and reuse.
        // Even better, build the number as we scan for underscores.
        let mut int_str = String::new();

        // Drop "i8", "u32" etc. suffix.
        let suffix = match kind {
            Some(IntKind::I8) => Some("i8"),
            Some(IntKind::U8) => Some("u8"),
            Some(IntKind::I32) => Some("i32"),
            Some(IntKind::U32) => Some("u32"),
            None => None,
        };

        let token_str = match suffix {
            None => token_str,
            Some(suffix) => token_str.strip_suffix(suffix).unwrap(),
        };

        // Drop '_'s.
        for char in token_str.chars() {
            if char == '_' {
                continue;
            }
            int_str.push(char);
        }

        Expr::Int(IntExpr {
            text: int_str,
            suffix: kind,
            radix: 16,
            parsed: 0,
        })
    },

    <int:BinIntLit> => {
        let kind = match int.kind {
            TokenKind::BinInt(int_kind) => int_kind,
            _ => unreachable!(),
        };
        debug_assert!(int.text.starts_with("0b"));
        let token_str = &int.text["0x".len()..];

        // TODO: Allocate the buffer once and reuse.
        // Even better, build the number as we scan for underscores.
        let mut int_str = String::new();

        // Drop "i8", "u32" etc. suffix.
        let suffix = match kind {
            Some(IntKind::I8) => Some("i8"),
            Some(IntKind::U8) => Some("u8"),
            Some(IntKind::I32) => Some("i32"),
            Some(IntKind::U32) => Some("u32"),
            None => None,
        };

        let token_str = match suffix {
            None => token_str,
            Some(suffix) => token_str.strip_suffix(suffix).unwrap(),
        };

        // Drop '_'s.
        for char in token_str.chars() {
            if char == '_' {
                continue;
            }
            int_str.push(char);
        }

        Expr::Int(IntExpr {
            text: int_str,
            suffix: kind,
            radix: 2,
            parsed: 0,
        })
    },

    <l:@L> <string:StringLit> => {
        let l = Loc { line: l.line, col: l.col + 1, byte_idx: l.byte_idx + 1 };
        Expr::String(parse_string_parts(module, &string.text[1..string.text.len() - 1], l))
    },

    <char:CharLit> => Expr::Char(parse_char_lit(&char.text)),

    <l:@L> <fun:InlineExpr> <r:@R> "(" <args:Sep<CallArg, ",">> ")" =>
        Expr::Call(CallExpr {
            fun: Box::new(L::new(module, l, r, fun)),
            args,
        }),

    <l:@L> <expr:InlineExpr> <r:@R> "." <field:LowerId> =>
        match expr {
            Expr::ConstrSelect(Constructor { ty: id, constr: None, ty_args: _ }) =>
                Expr::AssocFnSelect(AssocFnSelectExpr { ty: id, member: field.smol_str(), ty_args: vec![] }),

            _ => Expr::FieldSelect(FieldSelectExpr {
                object: Box::new(L::new(module, l, r, expr)),
                field: field.smol_str(),
            }),
        },

    "[" <elems:Sep<SeqElem, ",">> "]" =>
        Expr::Seq(elems),

    #[precedence(level = "2")]
    "!" <l:@L> <expr:InlineExpr> <r:@R> =>
        Expr::UnOp(UnOpExpr { op: UnOp::Not, expr: Box::new(L::new(module, l, r, expr)) }),

    "-" <l:@L> <expr:InlineExpr> <r:@R> =>
        Expr::UnOp(UnOpExpr { op: UnOp::Neg, expr: Box::new(L::new(module, l, r, expr)) }),

    #[precedence(level = "3")]
    <id:TildeUpperId> <args:("(" <Sep<ParenExpr, ",">> ")")?> =>
        Expr::Variant(VariantExpr {
            id: id.text.as_str()[1..].into(),
            args: match args {
                Some(args) => args.into_iter().map(|(name, expr)| Named { name: name, node: expr }).collect(),
                None => vec![],
            },
        }),

    #[precedence(level = "4")]
    #[assoc(side = "left")]
    <l1:@L> <left:InlineExpr> <r1:@R> "*" <l2:@L> <right:InlineExpr> <r2:@R> =>
        Expr::BinOp(BinOpExpr {
            left: Box::new(L::new(module, l1, r1, left)),
            right: Box::new(L::new(module, l2, r2, right)),
            op: BinOp::Multiply,
        }),

    #[assoc(side = "left")]
    <l1:@L> <left:InlineExpr> <r1:@R> "/" <l2:@L> <right:InlineExpr> <r2:@R> =>
        Expr::BinOp(BinOpExpr {
            left: Box::new(L::new(module, l1, r1, left)),
            right: Box::new(L::new(module, l2, r2, right)),
            op: BinOp::Divide,
        }),

    #[precedence(level = "5")]
    #[assoc(side = "left")]
    <l1:@L> <left:InlineExpr> <r1:@R> "+" <l2:@L> <right:InlineExpr> <r2:@R> =>
        Expr::BinOp(BinOpExpr {
            left: Box::new(L::new(module, l1, r1, left)),
            right: Box::new(L::new(module, l2, r2, right)),
            op: BinOp::Add,
        }),

    <l1:@L> <left:InlineExpr> <r1:@R> "-" <l2:@L> <right:InlineExpr> <r2:@R> =>
        Expr::BinOp(BinOpExpr {
            left: Box::new(L::new(module, l1, r1, left)),
            right: Box::new(L::new(module, l2, r2, right)),
            op: BinOp::Subtract,
        }),

    #[precedence(level = "6")]
    #[assoc(side = "left")]
    <l1:@L> <left:InlineExpr> <r1:@R> "<<" <l2:@L> <right:InlineExpr> <r2:@R> =>
        Expr::BinOp(BinOpExpr {
            left: Box::new(L::new(module, l1, r1, left)),
            right: Box::new(L::new(module, l2, r2, right)),
            op: BinOp::LeftShift,
        }),

    <l1:@L> <left:InlineExpr> <r1:@R> ">>" <l2:@L> <right:InlineExpr> <r2:@R> =>
        Expr::BinOp(BinOpExpr {
            left: Box::new(L::new(module, l1, r1, left)),
            right: Box::new(L::new(module, l2, r2, right)),
            op: BinOp::RightShift,
        }),

    #[precedence(level = "7")]
    #[assoc(side = "left")]
    <l1:@L> <left:InlineExpr> <r1:@R> "&" <l2:@L> <right:InlineExpr> <r2:@R> =>
        Expr::BinOp(BinOpExpr {
            left: Box::new(L::new(module, l1, r1, left)),
            right: Box::new(L::new(module, l2, r2, right)),
            op: BinOp::BitAnd,
        }),

    #[precedence(level = "8")]
    #[assoc(side = "left")]
    <l1:@L> <left:InlineExpr> <r1:@R> "|" <l2:@L> <right:InlineExpr> <r2:@R> =>
        Expr::BinOp(BinOpExpr {
            left: Box::new(L::new(module, l1, r1, left)),
            right: Box::new(L::new(module, l2, r2, right)),
            op: BinOp::BitOr,
        }),

    #[precedence(level = "9")]
    #[assoc(side = "left")]
    <l1:@L> <left:InlineExpr> <r1:@R> "==" <l2:@L> <right:InlineExpr> <r2:@R> =>
        Expr::BinOp(BinOpExpr {
            left: Box::new(L::new(module, l1, r1, left)),
            right: Box::new(L::new(module, l2, r2, right)),
            op: BinOp::Equal,
        }),

    <l1:@L> <left:InlineExpr> <r1:@R> "!=" <l2:@L> <right:InlineExpr> <r2:@R> =>
        Expr::BinOp(BinOpExpr {
            left: Box::new(L::new(module, l1, r1, left)),
            right: Box::new(L::new(module, l2, r2, right)),
            op: BinOp::NotEqual,
        }),

    <l1:@L> <left:InlineExpr> <r1:@R> "<" <l2:@L> <right:InlineExpr> <r2:@R> =>
        Expr::BinOp(BinOpExpr {
            left: Box::new(L::new(module, l1, r1, left)),
            right: Box::new(L::new(module, l2, r2, right)),
            op: BinOp::Lt,
        }),

    <l1:@L> <left:InlineExpr> <r1:@R> ">" <l2:@L> <right:InlineExpr> <r2:@R> =>
        Expr::BinOp(BinOpExpr {
            left: Box::new(L::new(module, l1, r1, left)),
            right: Box::new(L::new(module, l2, r2, right)),
            op: BinOp::Gt,
        }),

    <l1:@L> <left:InlineExpr> <r1:@R> "<=" <l2:@L> <right:InlineExpr> <r2:@R> =>
        Expr::BinOp(BinOpExpr {
            left: Box::new(L::new(module, l1, r1, left)),
            right: Box::new(L::new(module, l2, r2, right)),
            op: BinOp::LtEq,
        }),

    <l1:@L> <left:InlineExpr> <r1:@R> ">=" <l2:@L> <right:InlineExpr> <r2:@R> =>
        Expr::BinOp(BinOpExpr {
            left: Box::new(L::new(module, l1, r1, left)),
            right: Box::new(L::new(module, l2, r2, right)),
            op: BinOp::GtEq,
        }),

    <l1:@L> <expr:InlineExpr> <r1:@R> "is" <l2:@L> <pat:Pat> <r2:@R> =>
        Expr::Is(IsExpr {
            expr: Box::new(L::new(module, l1, r1, expr)),
            pat: L::new(module, l2, r2, pat),
        }),

    #[precedence(level = "10")]
    #[assoc(side = "left")]
    <l1:@L> <left:InlineExpr> <r1:@R> "&&" <l2:@L> <right:InlineExpr> <r2:@R> =>
        Expr::BinOp(BinOpExpr {
            left: Box::new(L::new(module, l1, r1, left)),
            right: Box::new(L::new(module, l2, r2, right)),
            op: BinOp::And,
        }),

    #[precedence(level = "11")]
    #[assoc(side = "left")]
    <l1:@L> <left:InlineExpr> <r1:@R> "||" <l2:@L> <right:InlineExpr> <r2:@R> =>
        Expr::BinOp(BinOpExpr {
            left: Box::new(L::new(module, l1, r1, left)),
            right: Box::new(L::new(module, l2, r2, right)),
            op: BinOp::Or,
        }),

    <l:@L> "return" <r:@R> =>
        Expr::Return(Box::new(L::new(module, l, r, Expr::Record(vec![])))),

    #[precedence(level = "12")]
    "return" <expr:LInlineExpr> =>
        Expr::Return(Box::new(expr)),

    "fn" "(" <params:Sep<(<LowerId> <(":" <LType>)?>), ",">> ")"
         <ret:ReturnType> "{" NEWLINE INDENT <body:LStmts> DEDENT "}" =>
        Expr::Fn(FnExpr {
            sig: FunSig {
                context: Context { type_params: vec![], preds: vec![] },
                self_: SelfParam::No,
                params: params.into_iter().map(|(name, ty)| (name.smol_str(), ty)).collect(),
                exceptions: ret.0,
                return_ty: ret.1,
            },
            body,
            idx: 0,
            inferred_ty: None,
        }),

    "fn" "(" <params:Sep<(<LowerId> <(":" <LType>)?>), ",">> ")"
         <ret:ReturnType> "{" <body:LInlineExpr> "}" =>
        Expr::Fn(FnExpr {
            sig: FunSig {
                context: Context { type_params: vec![], preds: vec![] },
                self_: SelfParam::No,
                params: params.into_iter().map(|(name, ty)| (name.smol_str(), ty)).collect(),
                exceptions: ret.0,
                return_ty: ret.1,
            },
            body: vec![L { loc: body.loc.clone(), node: Stmt::Expr(body) }],
            idx: 0,
            inferred_ty: None,
        }),

    "{" NEWLINE INDENT <body:LStmts> DEDENT "}" =>
        Expr::Fn(FnExpr {
            sig: FunSig {
                context: Context { type_params: vec![], preds: vec![] },
                self_: SelfParam::No,
                params: vec![],
                exceptions: None,
                return_ty: None,
            },
            body,
            idx: 0,
            inferred_ty: None,
        }),

    "{" <body:LInlineExpr> "}" =>
        Expr::Fn(FnExpr {
            sig: FunSig {
                context: Context { type_params: vec![], preds: vec![] },
                self_: SelfParam::No,
                params: vec![],
                exceptions: None,
                return_ty: None,
            },
            body: vec![L { loc: body.loc.clone(), node: Stmt::Expr(body) }],
            idx: 0,
            inferred_ty: None,
        }),
}

ParenExpr: (Option<Id>, L<Expr>) = {
    <id:LowerId> "=" <expr:LExpr> =>
        (Some(id.smol_str()), expr),

    <expr:LExpr> =>
        (None, expr),
}

CallArg: CallArg = {
    <name:LowerId> "=" <expr:LExpr> =>
        CallArg {
            name: Some(name.smol_str()),
            expr,
        },

    <expr:LExpr> =>
        CallArg {
            name: None,
            expr,
        },
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Sequence elements
//
////////////////////////////////////////////////////////////////////////////////////////////////////

SeqElem: (Option<L<Expr>>, L<Expr>) = {
    <expr:LInlineExpr> => (None, expr),
    <key:LInlineExpr> "=" <value:LInlineExpr> => (Some(key), value),
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Patterns
//
////////////////////////////////////////////////////////////////////////////////////////////////////

LPat: L<Pat> = {
    <l:@L> <pat:Pat> <r:@R> => L::new(module, l, r, pat),
}

Pat: Pat = {
    #[precedence(level = "0")]
    <id:LowerId> => Pat::Var(VarPat { var: id.smol_str(), ty: None }),

    <constr:ConstrPattern> => Pat::Constr(constr),

    <var:VariantPattern> => Pat::Variant(var),

    "(" <fields:Sep<PatternField, ",">> ")" =>
        Pat::Record(RecordPattern {
            fields: fields.into_iter().map(|(name, pat)| Named { name, node: pat }).collect(),
            ignore_rest: false,
            inferred_ty: None,
        }),

    "(" <fields:(<PatternField> ",")+> ".." ")" =>
        Pat::Record(RecordPattern {
            fields: fields.into_iter().map(|(name, pat)| Named { name, node: pat }).collect(),
            ignore_rest: true,
            inferred_ty: None,
        }),

    "_" => Pat::Ignore,

    <str:StringLit> =>
        Pat::Str(copy_update_escapes(&str.text[1..str.text.len() - 1])),

    <char:CharLit> => Pat::Char(parse_char_lit(&char.text)),

    <str:StringLit> <binder:StrPfxBinder> =>
        Pat::StrPfx(copy_update_escapes(&str.text[1..str.text.len() - 1]), binder),

    #[precedence(level = "1")]
    #[assoc(side = "right")]
    <l1:@L> <p1:Pat> <r1:@R> "|" <l2:@L> <p2:Pat> <r2:@L> => {
        Pat::Or(
            Box::new(L::new(module, l1, r1, p1)),
            Box::new(L::new(module, l2, r2, p2)),
        )
    }
}

StrPfxBinder: Option<Id> = {
    <id:LowerId> => Some(id.smol_str()),
    "_" => None,
}

Constructor: Constructor = {
    <ty:UpperId> =>
        Constructor { ty: ty.smol_str(), constr: None, ty_args: vec![] },

    <path:UpperIdPath> => {
        let mut parts = path_parts(&path.text);
        let constr = parts.pop().unwrap();
        let ty = parts.pop().unwrap();
        Constructor { ty, constr: Some(constr), ty_args: vec![] }
    }
}

ConstrPattern: ConstrPattern = {
    <constr:Constructor> =>
        ConstrPattern { constr, fields: vec![], ignore_rest: false },

    <constr:Constructor> "(" ".." ")" =>
        ConstrPattern {
            constr,
            fields: vec![],
            ignore_rest: true,
        },

    <constr:Constructor> "(" <fields:Sep<PatternField, ",">> ")" =>
        ConstrPattern {
            constr,
            fields: fields.into_iter().map(|(name, pat)| Named { name, node: pat }).collect(),
            ignore_rest: false,
        },

    <constr:Constructor> "(" <fields:(<PatternField> ",")+> ".." ")" =>
        ConstrPattern {
            constr,
            fields: fields.into_iter().map(|(name, pat)| Named { name, node: pat }).collect(),
            ignore_rest: true,
        },
}

VariantPattern: VariantPattern = {
    <constr:TildeUpperId> =>
        VariantPattern {
            constr: constr.text.as_str()[1..].into(),
            fields: vec![],
        },

    <constr:TildeUpperId> "(" <fields:Sep<PatternField, ",">> ")" =>
        VariantPattern {
            constr: constr.text.as_str()[1..].into(),
            fields: fields.into_iter().map(|(name, pat)| Named { name, node: pat }).collect(),
        },
}

PatternField: (Option<Id>, L<Pat>) = {
    <id:LowerId> "=" <pat:LPat> =>
        (Some(id.smol_str()), pat),

    <pat:LPat> =>
        (None, pat),
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Import declarations
//
////////////////////////////////////////////////////////////////////////////////////////////////////

ImportDecl: L<ImportDecl> = {
    <l:@L> "import" <path:Sep<UpperId, ".">> NEWLINE <r:@R> =>
        L::new(module, l, r, ImportDecl { path: path.into_iter().map(|t| t.smol_str()).collect() }),
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Trait declarations
//
////////////////////////////////////////////////////////////////////////////////////////////////////

TraitDecl: L<TraitDecl> = {
    <l:@L> "trait" <name:LUpperIdLBracket> <type_params:Sep<LLowerId, ",">> "]" ":"
            NEWLINE INDENT <items:FunDecl+> DEDENT <r:@R> =>
        L::new(module, l, r, TraitDecl {
            name,
            type_params,
            type_param_kinds: vec![],
            items,
        }),

    <l:@L> "trait" <name:LUpperIdLBracket> <type_params:Sep<LLowerId, ",">> "]" <r:@R> =>
        L::new(module, l, r, TraitDecl {
            name,
            type_params,
            type_param_kinds: vec![],
            items: vec![],
        }),

}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Impl declarations
//
////////////////////////////////////////////////////////////////////////////////////////////////////

ImplDecl: L<ImplDecl> = {
    <l:@L> "impl" <context:Context> <trait_:LUpperIdLBracket> <tys:Sep<LType, ",">> "]" ":"
            NEWLINE INDENT <items:FunDecl+> DEDENT <r:@R> => {
        L::new(module, l, r, ImplDecl {
            context,
            trait_,
            tys,
            items,
        })
    },

    <l:@L> "impl" <context:Context> <trait_:LUpperIdLBracket> <tys:Sep<LType, ",">> "]" <r:@R> => {
        L::new(module, l, r, ImplDecl {
            context,
            trait_,
            tys,
            items: vec![],
        })
    },
}

Context: Context = {
    => Context { type_params: vec![], preds: vec![] },

    "[" <tys:Sep<LType, ",">> "]" => Context { type_params: vec![], preds: tys },
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Top-level declarations
//
////////////////////////////////////////////////////////////////////////////////////////////////////

pub TopDecls: Vec<L<TopDecl>> = {
    TopDecl*
}

TopDecl: L<TopDecl> = {
    NEWLINE* <l:@L> <type_decl:TypeDecl> <r:@R> =>
        L::new(module, l, r, TopDecl::Type(type_decl)),

    NEWLINE* <l:@L> <fun_decl:TopFunDecl> <r:@R> =>
        L::new(module, l, r, TopDecl::Fun(fun_decl)),

    NEWLINE* <l:@L> <import_decl:ImportDecl> <r:@R> =>
        L::new(module, l, r, TopDecl::Import(import_decl)),

    NEWLINE* <l:@L> <trait_decl:TraitDecl> <r:@R> =>
        L::new(module, l, r, TopDecl::Trait(trait_decl)),

    NEWLINE* <l:@L> <impl_decl:ImplDecl> <r:@R> =>
        L::new(module, l, r, TopDecl::Impl(impl_decl)),
}
