/*
This module compiles lowered syntax to C.

## Heap objects

All heap objects are allocated with `mallc` and have a `u32` tag.

For now we don't reclaim memory: all allocations leak.

In the future: we may try Boehm or some other conservative GC.

## Types

Product types (including records) will be compiled to C structs.

Sum types: every constructor will have its own struct and structs, with different fields and sizes.

Sum type constructors will have different (unique in entire program) tags, which will be used to
discriminate in pattern matching.

## Functions and constructors

Every function and constructor will be compiled to two C definitions:

- An actual C function that runs the function and constructor.
- A static object (with same layout as heap allocations) for the closures of the constructor or
  function.

## Closures

Every closure in the program will have its own unique type, similar to types.

## Exprs

Block expressions like `match` and `if` will be compiled with a destination variable, for the value
generated by the `match`/`if`/etc.

- `LocalVar`: C variable.

- `Fun`: reference to the top-level closure of the function.

- `Con`: same as `Con`.

- `ConAlloc`: allocate the heap object with `malloc` + initialize fields.

- `FieldSel`: evaluate object, then `object->field`.

- `Call`: special case `Fun` calls to call the function directly. For others: the function will
  evaluate to a closure. Call the closure entry.

- `Int`: compile to C integer.

- `Str`: allocate an array for the UTF-8 encoding, then allocate `type Str(...)`.

- `BoolAnd`:
  ```
  ({
    bool b = <evaluate left>;
    if (b) {
      b = <evaluate right>;
    }
    b
  })
  ```

- `BoolOr`: similar to `BoolAnd`.

- `Return`: C `return`

- `Match`: compile each branch as `if <scrutinee> is <pattern> { <body> }`.
  Chain all branches with `else if`.

  Branch return values will need to be written to the "destination" variable.

- `If`: similar.

- `ClosureAlloc`: allocate closure.

- `Is`: see pattern matching below.

- `Do`: We may be able to use statement expressions:
   https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html.

   Or create and pass destination.

- Variant: we need to create structs for these. TODO

When a Fir expression is in C expression context: compile it directly.
In C statement context: wrap the generated code with `({ ... })`.
Reference: https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html
*/

use crate::ast::Id;
use crate::collections::*;
use crate::lowering::*;
use crate::mono_ast as mono;

use indoc::writedoc;
use smol_str::SmolStr;

use std::fmt::Write;

macro_rules! write {
    ($($arg:tt)*) => {
        ::core::write!($($arg)*).unwrap()
    };
}

#[allow(unused)]
macro_rules! writeln {
    ($($arg:tt)*) => {
        ::core::writeln!($($arg)*).unwrap()
    };
}

struct Cg {
    /// Indexed by `LocalIdx`. Locals in the current function.
    locals: Vec<LocalInfo>,
}

type RecordType = OrdMap<Id, mono::Type>;

pub(crate) fn to_c(pgm: &LoweredPgm) -> String {
    let mut record_tags: HashMap<RecordType, u32> = Default::default();

    let mut p = Printer::default();

    writedoc!(
        p,
        "
        #include <stdint.h>
        #include <stdio.h>
        #include <stdlib.h>
        "
    );

    for (tag, heap_obj) in pgm.heap_objs.iter().enumerate() {
        heap_obj_to_c(heap_obj, tag as u32, &mut record_tags, &mut p);
        p.nl();
    }

    for (_i, fun) in pgm.funs.iter().enumerate() {
        fun_to_c(fun, &record_tags, &mut p);
    }

    p.print()
}

fn heap_obj_to_c(
    heap_obj: &HeapObj,
    tag: u32,
    record_tags: &mut HashMap<RecordType, u32>,
    p: &mut Printer,
) {
    match heap_obj {
        HeapObj::Builtin(builtin) => builtin_con_decl_to_c(builtin, tag, p),
        HeapObj::Source(source_con) => source_con_decl_to_c(source_con, tag, record_tags, p),
        HeapObj::Record(record) => record_decl_to_c(record, tag, record_tags, p),
    }
}

fn builtin_con_decl_to_c(builtin: &BuiltinConDecl, tag: u32, p: &mut Printer) {
    match builtin {
        BuiltinConDecl::Con => {
            writedoc!(
                p,
                "
                // Heap layout of constructor closures.
                typedef struct {{
                    uint32_t tag; // {tag}
                    uint32_t con_tag;
                }} Con_;

                typedef Con_* Con;
                "
            );
        }

        BuiltinConDecl::Fun => {
            writedoc!(
                p,
                "
                // Heap layout of function closures.
                typedef struct {{
                    uint32_t tag; // {tag}
                    void* fun;
                }} Fun_;

                typedef Fun_* Fun;
                "
            );
        }

        BuiltinConDecl::Closure => {
            writedoc!(
                p,
                "
                // Heap layout of function expression closures.
                // These objects have variable sizes depending on captured values.
                // Captured values come after the `fun` field.
                typedef struct {{
                    uint32_t tag; // {tag}
                    void* fun;
                    // captured values here...
                }} Closure_;

                typedef Closure_* Closure;
                "
            );
        }

        BuiltinConDecl::ArrayU8 => {
            writedoc!(p, "typedef uint8_t* Array_U8;\n");
        }

        BuiltinConDecl::ArrayU32 => {
            writedoc!(p, "typedef uint32_t* Array_U32;\n");
        }

        BuiltinConDecl::ArrayU64 => {
            writedoc!(p, "typedef uint64_t* Array_U64;\n");
        }

        BuiltinConDecl::I8 => {
            writedoc!(p, "typedef int8_t I8;\n");
        }

        BuiltinConDecl::U8 => {
            writedoc!(p, "typedef uint8_t U8;\n");
        }

        BuiltinConDecl::I32 => {
            writedoc!(p, "typedef int32_t I32;\n");
        }

        BuiltinConDecl::U32 => {
            writedoc!(p, "typedef uint32_t U32;\n");
        }

        BuiltinConDecl::I64 => {
            writedoc!(p, "typedef int64_t I64;\n");
        }

        BuiltinConDecl::U64 => {
            writedoc!(p, "typedef uint64_t U64;\n");
        }
    }
}

fn source_con_decl_to_c(
    builtin: &SourceConDecl,
    tag: u32,
    record_tags: &HashMap<RecordType, u32>,
    p: &mut Printer,
) {
    let SourceConDecl {
        name,
        idx,
        ty_args,
        fields,
    } = builtin;

    assert_eq!(idx.0, tag);

    let mut ty_name = name.to_string();
    for ty_arg in ty_args {
        ty_name.push('_');
        ty_to_c_(ty_arg, record_tags, &mut ty_name);
    }

    write!(p, "typedef struct {{");
    p.indent();
    p.nl();
    write!(p, "uint32_t tag; // {tag}");
    for (i, field) in fields.iter().enumerate() {
        p.nl();
        write!(p, "{} f{};", ty_to_c(&field.mono_ty, record_tags), i);
    }
    p.dedent();
    p.nl();
    write!(p, "}} {ty_name}_;");
    p.nl();
    p.nl();
    write!(p, "typedef struct {ty_name}_* {ty_name};");
    p.nl();
}

fn record_decl_to_c(
    record: &RecordShape,
    tag: u32,
    record_tags: &mut HashMap<RecordType, u32>,
    p: &mut Printer,
) {
    let old = record_tags.insert(record.fields.clone(), tag);
    assert!(old.is_none());

    write!(p, "typedef struct {{");
    p.indent();
    p.nl();
    write!(p, "uint32_t tag; // {tag}");
    for (i, field) in record.fields.values().enumerate() {
        p.nl();
        write!(p, "{} f{};", ty_to_c(field, record_tags), i);
    }
    p.dedent();
    p.nl();
    write!(p, "}} Record{tag}_;");
    p.nl();
    p.nl();
    write!(p, "typedef Record{tag}_* Record{tag};");
    p.nl();
}

fn ty_to_c(ty: &mono::Type, record_tags: &HashMap<RecordType, u32>) -> String {
    let mut out = String::new();
    ty_to_c_(ty, record_tags, &mut out);
    out
}

fn ty_to_c_(ty: &mono::Type, record_tags: &HashMap<RecordType, u32>, out: &mut String) {
    match ty {
        mono::Type::Named(mono::NamedType { name, args }) => {
            out.push_str(name);
            for arg in args {
                out.push('_');
                ty_to_c_(arg, record_tags, out);
            }
        }

        mono::Type::Record { fields } => {
            let tag = record_tags.get(fields).unwrap();
            write!(out, "Record{}", tag);
        }

        mono::Type::Variant { alts: _ } => {
            out.push_str("TODO_2");
        }

        mono::Type::Fn(_) => {
            out.push_str("Closure");
        }

        mono::Type::Never => {
            panic!("Never type")
        }
    }
}

fn fun_to_c(fun: &Fun, record_tags: &HashMap<RecordType, u32>, p: &mut Printer) {
    match fun {
        Fun::Builtin(builtin) => {
            builtin_fun_to_c(builtin, record_tags, p);
        }

        Fun::Source(_) => {
            // TODO
        }
    }
}

fn builtin_fun_to_c(fun: &BuiltinFunDecl, record_tags: &HashMap<RecordType, u32>, p: &mut Printer) {
    match fun {
        BuiltinFunDecl::Panic { a, exn_q } => {
            // prim panic(msg: Str) a / exn?
            let a = ty_to_c(a, record_tags);
            let exn_q = ty_to_c(exn_q, record_tags);
            writedoc!(
                p,
                "
                [[noreturn]]
                {a} panic_{a}_{exn_q}(Str msg) {{
                    // TODO: copy string with nul terminator, write to stderr
                    abort();
                }}
                ",
            );
        }

        BuiltinFunDecl::PrintStrNoNl => todo!(),

        BuiltinFunDecl::ShrI8 => todo!(),

        BuiltinFunDecl::ShrU8 => todo!(),

        BuiltinFunDecl::ShrI32 => todo!(),

        BuiltinFunDecl::ShrU32 => todo!(),

        BuiltinFunDecl::BitAndI8 => todo!(),

        BuiltinFunDecl::BitAndU8 => todo!(),

        BuiltinFunDecl::BitAndI32 => todo!(),

        BuiltinFunDecl::BitAndU32 => todo!(),

        BuiltinFunDecl::BitOrI8 => todo!(),

        BuiltinFunDecl::BitOrU8 => todo!(),

        BuiltinFunDecl::BitOrI32 => todo!(),

        BuiltinFunDecl::BitOrU32 => todo!(),

        BuiltinFunDecl::BitXorU32 => todo!(),

        BuiltinFunDecl::ToStrI8 => todo!(),

        BuiltinFunDecl::ToStrU8 => todo!(),

        BuiltinFunDecl::ToStrI32 => todo!(),

        BuiltinFunDecl::ToStrU32 => todo!(),

        BuiltinFunDecl::ToStrU64 => todo!(),

        BuiltinFunDecl::ToStrI64 => todo!(),

        BuiltinFunDecl::U8AsI8 => todo!(),

        BuiltinFunDecl::U8AsU32 => todo!(),

        BuiltinFunDecl::U32AsU8 => todo!(),

        BuiltinFunDecl::U32AsI32 => todo!(),

        BuiltinFunDecl::U32AsU64 => todo!(),

        BuiltinFunDecl::I8Shl => todo!(),

        BuiltinFunDecl::U8Shl => todo!(),

        BuiltinFunDecl::I32Shl => todo!(),

        BuiltinFunDecl::U32Shl => todo!(),

        BuiltinFunDecl::I8Cmp => todo!(),

        BuiltinFunDecl::U8Cmp => todo!(),

        BuiltinFunDecl::I32Cmp => todo!(),

        BuiltinFunDecl::U32Cmp => todo!(),

        BuiltinFunDecl::U64Cmp => todo!(),

        BuiltinFunDecl::I8Add => todo!(),

        BuiltinFunDecl::U8Add => todo!(),

        BuiltinFunDecl::I32Add => todo!(),

        BuiltinFunDecl::U32Add => todo!(),

        BuiltinFunDecl::U64Add => todo!(),

        BuiltinFunDecl::I8Sub => todo!(),

        BuiltinFunDecl::U8Sub => todo!(),

        BuiltinFunDecl::I32Sub => todo!(),

        BuiltinFunDecl::U32Sub => todo!(),

        BuiltinFunDecl::I8Mul => todo!(),

        BuiltinFunDecl::U8Mul => todo!(),

        BuiltinFunDecl::I32Mul => todo!(),

        BuiltinFunDecl::U32Mul => todo!(),

        BuiltinFunDecl::U64Mul => todo!(),

        BuiltinFunDecl::I8Div => todo!(),

        BuiltinFunDecl::U8Div => todo!(),

        BuiltinFunDecl::I32Div => todo!(),

        BuiltinFunDecl::U32Div => todo!(),

        BuiltinFunDecl::I8Eq => todo!(),

        BuiltinFunDecl::U8Eq => todo!(),

        BuiltinFunDecl::I32Eq => todo!(),

        BuiltinFunDecl::U32Eq => todo!(),

        BuiltinFunDecl::U32Mod => todo!(),

        BuiltinFunDecl::I8Rem => todo!(),

        BuiltinFunDecl::U8Rem => todo!(),

        BuiltinFunDecl::I32Rem => todo!(),

        BuiltinFunDecl::U32Rem => todo!(),

        BuiltinFunDecl::I32AsU32 => todo!(),

        BuiltinFunDecl::I32Abs => todo!(),

        BuiltinFunDecl::I8Neg => todo!(),

        BuiltinFunDecl::I32Neg => todo!(),

        BuiltinFunDecl::ThrowUnchecked { exn, a, exn_q } => {
            // prim throwUnchecked(exn: exn) a / exn?
            let exn = ty_to_c(exn, record_tags);
            let a = ty_to_c(a, record_tags);
            let exn_q = ty_to_c(exn_q, record_tags);
            writedoc!(
                p,
                "
                {a} throwUnchecked_{exn}_{a}_{exn_q}({exn} exn) {{
                    throw exn;
                }}
                ",
            );
        }

        BuiltinFunDecl::Try {
            a,
            exn,
            exn_q,
            ok_con: _,
            err_con: _,
        } => {
            // prim try(cb: Fn() a / exn) Result[exn, a] / exn?
            let result = ty_to_c(
                &mono::Type::Named(mono::NamedType {
                    name: SmolStr::new_static("Result"),
                    args: vec![exn.clone(), a.clone()],
                }),
                record_tags,
            );
            let exn = ty_to_c(exn, record_tags);
            let a = ty_to_c(a, record_tags);
            let exn_q = ty_to_c(exn_q, record_tags);
            writedoc!(
                p,
                "
                {result} try_{a}_{exn}_{exn_q}(Closure cb) {{
                    try {{
                        // TODO: call closure, return return value
                    }} catch ({exn} exn) {{
                        // TODO: return error
                    }}
                }}
                ",
            );
        }

        BuiltinFunDecl::ArrayNew { t: _ } => todo!(),

        BuiltinFunDecl::ArrayLen => todo!(),

        BuiltinFunDecl::ArrayGet { t: _ } => todo!(),

        BuiltinFunDecl::ArraySet { t: _ } => todo!(),

        BuiltinFunDecl::ArraySlice { t: _ } => todo!(),

        BuiltinFunDecl::ArrayCopyWithin { t: _ } => todo!(),

        BuiltinFunDecl::ReadFileUtf8 => todo!(),

        BuiltinFunDecl::GetArgs => todo!(),
    }
}

/// Compile the Fir expression to a C expression.
#[allow(unused)]
fn expr(expr: &Expr, cg: &mut Cg, p: &mut Printer) {
    match expr {
        Expr::LocalVar(idx) => {
            write!(p, "{}", cg.locals[idx.as_usize()].name);
        }

        Expr::Fun(fun_idx) => todo!(),

        Expr::Con(heap_obj_idx) => todo!(),

        Expr::ConAlloc(heap_obj_idx, ls) => todo!(),

        Expr::FieldSel(field_sel_expr) => todo!(),

        Expr::Call(call_expr) => todo!(),

        Expr::Int(_) => todo!(),

        Expr::Str(_) => todo!(),

        Expr::BoolAnd(l, l1) => todo!(),

        Expr::BoolOr(l, l1) => todo!(),

        Expr::Return(l) => todo!(),

        Expr::Match(match_expr) => todo!(),

        Expr::If(if_expr) => todo!(),

        Expr::ClosureAlloc(closure_idx) => todo!(),

        Expr::Is(is_expr) => todo!(),

        Expr::Do(ls) => todo!(),

        Expr::Variant(l) => todo!(),
    }
}

#[derive(Debug, Default)]
struct Printer {
    lines: Vec<String>,
    current_line: String,
    indent: u32,
}

impl Printer {
    fn nl(&mut self) {
        let line = std::mem::replace(
            &mut self.current_line,
            std::iter::repeat(' ')
                .take(self.indent as usize * 4)
                .collect(),
        );
        self.lines.push(line)
    }

    fn print(mut self) -> String {
        self.nl();
        let mut out = String::with_capacity(self.lines.iter().map(|l| l.len()).sum());
        for (i, line) in self.lines.iter().enumerate() {
            if i != 0 {
                out.push('\n');
            }
            out.push_str(line);
        }
        out
    }

    fn indent(&mut self) {
        self.indent += 1;
    }

    fn dedent(&mut self) {
        self.indent -= 1;
    }
}

impl Write for Printer {
    fn write_str(&mut self, s: &str) -> std::fmt::Result {
        self.current_line.push_str(s);
        Ok(())
    }
}
