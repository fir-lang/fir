/*
TODOs:

- Make sure signed integers wrap on overflow and underflow in a defined way. Update the interpreter
  to do the same. Add tests. (`__builtin_add_overflow` etc.)

  In the future we'll probably trap by default and require explicitly allowing overflowing.
  (`checkedAdd`, `uncheckedAdd` etc.)
*/

/*
This module compiles lowered syntax to C.

## Heap objects

All heap objects are allocated with `malloc`. First word of every allocation is a 64-bit tag.

For now, fields are all `uint64_t`s, same as the interpreter.

For now we don't reclaim memory: all allocations leak.

In the future: we may try Boehm or some other conservative GC.

## Stack values

For now, arguments and locals are all `uint64_t`, same as the interpreter.

## Types

Product types (including records) will be compiled to C structs.

Sum types: every constructor will have its own struct and structs, with different fields and sizes.

For now: all constructors (not just types!) have unique tags. This is to allow a simple variant
implementation where value-to-variant conversions are no-op. In the future: variants will be stack
allocated, value-to-variant conversion will just add a tag word.

## Functions and constructors

Every function and constructor will be compiled to two C definitions:

- An actual C function that runs the function and constructor.

- A static object (with same layout as heap allocations) for the closures of the constructor or
  function.

## Closures

Every closure in the program will have its own unique type, similar to types.

## Exprs

Block expressions like `match` and `if` will be compiled with a destination variable, for the value
generated by the `match`/`if`/etc.

- `LocalVar`: C variable.

- `Fun`: reference to the top-level closure of the function.

- `Con`: same as `Fun`.

- `ConAlloc`: allocate the heap object with `malloc` + initialize fields.

- `FieldSel`: evaluate object, then `object->field`.

- `Call`: special case `Fun` calls to call the function directly. For others: the function will
  evaluate to a closure. Call the closure entry.

- `Int`: compile to a C integer.

- `Str`: allocate an array for the UTF-8 encoding, then allocate `Str(array)`.

- `BoolAnd`:
  ```
  ({
    bool b = <evaluate left>;
    if (b) {
      b = <evaluate right>;
    }
    b
  })
  ```

- `BoolOr`: similar to `BoolAnd`.

- `Return`: C `return`.

- `Match`: compile each branch as `if <scrutinee> is <pattern> { <body> }`.
  Chain all branches with `else if`.

  Branch return values will need to be written to the "destination" variable.

- `If`: similar.

- `ClosureAlloc`: allocate closure.

- `Is`: see pattern matching below.

- `Do`: We may be able to use statement expressions:
   https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html.

   Or create and pass destination.

- Variant: Compile as-is. Variant expressions need to be boxed, and all boxed objects have a tag.

  In the future: variants will be stack allocated, and value-to-variant conversion will just add a
  tag word.

## Prims

- `try`: `setjmp`
- `throw`: `longjmp`

When a Fir expression is in C expression context: compile it directly.
In C statement context: wrap the generated code with `({ ... })`.
Reference: https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html
*/

#![allow(unused_variables)]

use crate::ast::{Id, Loc};
use crate::collections::*;
use crate::lowering::*;
use crate::mono_ast as mono;
use crate::utils::loc_display;

use std::fmt::Write;

macro_rules! w {
    ($($arg:tt)*) => {
        ::core::write!($($arg)*).unwrap()
    };
}

macro_rules! wln {
    ($p:expr, $($arg:tt)*) => {{
        ::core::write!($p, $($arg)*).unwrap();
        $p.nl();
    }};
}

macro_rules! writedoc {
    ($p:expr, $($arg:tt)*) => {{
        ::indoc::writedoc!($p, $($arg)*).unwrap();
    }};
}

/// Code generation context.
struct Cg<'a> {
    pgm: &'a LoweredPgm,

    /// Counter for generating fresh temporary variables.
    temp_counter: u32,
}

impl<'a> Cg<'a> {
    fn fresh_temp(&mut self) -> String {
        let n = self.temp_counter;
        self.temp_counter += 1;
        format!("_t{}", n)
    }
}

pub(crate) fn to_c(pgm: &LoweredPgm, main: &str) -> String {
    let mut p = Printer::default();

    writedoc!(
        p,
        "
        #include <inttypes.h>
        #include <setjmp.h>
        #include <stdbool.h>
        #include <stdint.h>
        #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>

        typedef  uint8_t  U8;
        typedef   int8_t  I8;
        typedef uint16_t U16;
        typedef  int16_t I16;
        typedef uint32_t U32;
        typedef  int32_t I32;
        typedef uint64_t U64;
        typedef  int64_t I64;
        "
    );

    // Generate structs for sum types. These just have the tag and they're mainly to make code
    // easier to read.
    for (ty_id, ty_arg_map) in &pgm.type_objs {
        for (ty_args, objs) in ty_arg_map.iter() {
            if let TypeObjs::Product(_) = objs {
                continue;
            }
            w!(p, "// {}", ty_id);
            if !ty_args.is_empty() {
                w!(p, "[");
                for (i, ty_arg) in ty_args.iter().enumerate() {
                    if i != 0 {
                        w!(p, ", ");
                    }
                    w!(p, "{}", ty_arg);
                }
                w!(p, "]");
            }
            p.nl();
            writedoc!(
                p,
                "typedef struct {{
                    uint64_t tag;
                }} {};",
                sum_struct_name(ty_id, ty_args)
            );
            p.nl();
        }
    }

    let heap_objs_sorted = top_sort(&pgm.type_objs, &pgm.record_objs, &pgm.heap_objs);
    for scc in &heap_objs_sorted {
        // If SCC has more than one element, forward-declare the structs.
        if scc.len() > 1 {
            for heap_obj_idx in scc {
                match &pgm.heap_objs[heap_obj_idx.as_usize()] {
                    HeapObj::Source(source_con) => {
                        let struct_name = source_con_struct_name(source_con);
                        wln!(p, "typedef struct {} {};", struct_name, struct_name);
                    }
                    HeapObj::Record(record) => {
                        let struct_name = record_struct_name(record);
                        wln!(p, "typedef struct {} {};", struct_name, struct_name);
                    }
                    HeapObj::Builtin(_) => {
                        panic!("Builtin in SCC");
                    }
                }
            }
            p.nl();
        }

        // Generate struct definitions.
        for heap_obj_idx in scc {
            heap_obj_to_c(
                &pgm.heap_objs[heap_obj_idx.as_usize()],
                heap_obj_idx.0,
                &mut p,
            );
            p.nl();
        }
    }

    writedoc!(
        p,
        "
        // Exception handling using setjmp/longjmp
        typedef struct ExnHandler {{
            jmp_buf buf;
            struct ExnHandler* prev;
            uint64_t exn_value;
        }} ExnHandler;

        static ExnHandler* current_exn_handler = NULL;

        static void throw_exn(uint64_t exn) {{
            if (current_exn_handler == NULL) {{
                fprintf(stderr, \"Uncaught exception\\n\");
                exit(1);
            }}
            current_exn_handler->exn_value = exn;
            longjmp(current_exn_handler->buf, 1);
        }}

        static uint32_t get_tag(void* obj) {{
            return (uint32_t)*(uint64_t*)obj;
        }}

        // Array allocation and access functions.

        static ARRAY* array_new_u8(uint32_t len) {{
            size_t data_words = (len + 7) / 8;
            ARRAY* arr = (ARRAY*)malloc(sizeof(ARRAY) + (data_words * sizeof(uint64_t)));
            arr->tag = ARRAY_TAG;
            arr->data_ptr = (uint64_t*)(arr + 1);
            arr->len = len;
            memset(arr + 1, 0, data_words * sizeof(uint64_t));
            return arr;
        }}

        static uint64_t array_get_u8(ARRAY* arr, uint32_t idx) {{
            uint8_t* data_ptr = (uint8_t*)arr->data_ptr;
            return (uint64_t)data_ptr[idx];
        }}

        static void array_set_u8(ARRAY* arr, uint32_t idx, uint64_t val) {{
            uint8_t* data_ptr = (uint8_t*)arr->data_ptr;
            data_ptr[idx] = (uint8_t)val;
        }}

        static ARRAY* array_slice_u8(ARRAY* arr, uint32_t start, uint32_t end) {{
            ARRAY* new_arr = (ARRAY*)malloc(sizeof(ARRAY));
            new_arr->tag = ARRAY_TAG;
            uint8_t* data_ptr = (uint8_t*)arr->data_ptr;
            new_arr->data_ptr = (uint64_t*)(data_ptr + start);
            new_arr->len = end - start;
            return new_arr;
        }}

        static void array_copy_within_u8(ARRAY* arr, uint32_t src, uint32_t dst, uint32_t len) {{
            uint8_t* data_ptr = (uint8_t*)arr->data_ptr;
            memmove(data_ptr + dst, data_ptr + src, len);
        }}

        static ARRAY* array_new_u32(uint32_t len) {{
            size_t data_words = (len + 1) / 2;
            ARRAY* arr = (ARRAY*)malloc(sizeof(ARRAY) + (data_words * sizeof(uint64_t)));
            arr->tag = ARRAY_TAG;
            arr->data_ptr = (uint64_t*)(arr + 1);
            arr->len = len;
            memset(arr + 1, 0, data_words * sizeof(uint64_t));
            return arr;
        }}

        static uint64_t array_get_u32(ARRAY* arr, uint32_t idx) {{
            uint32_t* data_ptr = (uint32_t*)arr->data_ptr;
            return (uint64_t)data_ptr[idx];
        }}

        static void array_set_u32(ARRAY* arr, uint32_t idx, uint64_t val) {{
            uint32_t* data_ptr = (uint32_t*)arr->data_ptr;
            data_ptr[idx] = (uint32_t)val;
        }}

        static ARRAY* array_slice_u32(ARRAY* arr, uint32_t start, uint32_t end) {{
            ARRAY* new_arr = (ARRAY*)malloc(sizeof(ARRAY));
            new_arr->tag = ARRAY_TAG;
            uint32_t* data_ptr = (uint32_t*)arr->data_ptr;
            new_arr->data_ptr = (uint64_t*)(data_ptr + start);
            new_arr->len = end - start;
            return new_arr;
        }}

        static void array_copy_within_u32(ARRAY* arr, uint32_t src, uint32_t dst, uint32_t len) {{
            uint32_t* data_ptr = (uint32_t*)arr->data_ptr;
            memmove(data_ptr + dst, data_ptr + src, len * sizeof(uint32_t));
        }}

        static ARRAY* array_new_u64(uint32_t len) {{
            ARRAY* arr = (ARRAY*)malloc(sizeof(ARRAY) + (len * sizeof(uint64_t)));
            arr->tag = ARRAY_TAG;
            arr->data_ptr = (uint64_t*)(arr + 1);
            arr->len = len;
            memset(arr + 1, 0, len * sizeof(uint64_t));
            return arr;
        }}

        static uint64_t array_get_u64(ARRAY* arr, uint32_t idx) {{
            uint64_t* data_ptr = (uint64_t*)arr->data_ptr;
            return data_ptr[idx];
        }}

        static void array_set_u64(ARRAY* arr, uint32_t idx, uint64_t val) {{
            uint64_t* data_ptr = (uint64_t*)arr->data_ptr;
            data_ptr[idx] = val;
        }}

        static ARRAY* array_slice_u64(ARRAY* arr, uint32_t start, uint32_t end) {{
            ARRAY* new_arr = (ARRAY*)malloc(sizeof(ARRAY));
            new_arr->tag = ARRAY_TAG;
            uint64_t* data_ptr = (uint64_t*)arr->data_ptr;
            new_arr->data_ptr = data_ptr + start;
            new_arr->len = end - start;
            return new_arr;
        }}

        static void array_copy_within_u64(ARRAY* arr, uint32_t src, uint32_t dst, uint32_t len) {{
            uint64_t* data_ptr = (uint64_t*)arr->data_ptr;
            memmove(data_ptr + dst, data_ptr + src, len * sizeof(uint64_t));
        }}

        static uint32_t array_len(ARRAY* arr) {{
            return (uint32_t)arr->len;
        }}

        // String comparison for pattern matching
        static bool str_eq(Str* s1, const char* str2, size_t len2) {{
            ARRAY* bytes_arr = s1->_0;
            uint32_t len1 = array_len(bytes_arr);
            if (len1 != len2) return false;
            uint8_t* data_ptr = (uint8_t*)bytes_arr->data_ptr;
            return memcmp(data_ptr, str2, len1) == 0;
        }}

        // Allocate string from bytes
        static Str* alloc_str(const char* bytes, size_t len) {{
            ARRAY* arr = array_new_u8(len);
            uint8_t* data_ptr = (uint8_t*)arr->data_ptr;
            memcpy(data_ptr, bytes, len);

            Str* str = (Str*)malloc(sizeof(Str));
            str->_tag = TAG_Str;
            str->_0 = arr;
            return str;
        }}

        // Globals for CLI args
        static int g_argc;
        static char** g_argv;

        "
    );
    p.nl();

    if pgm.closures.iter().any(|c| !c.fvs.is_empty()) {
        wln!(p, "// Closure structs for closures with captures");
        p.nl();
        for (i, closure) in pgm.closures.iter().enumerate() {
            gen_closure_struct(closure, i, &mut p);
        }
        p.nl();
    }

    for (i, fun) in pgm.funs.iter().enumerate() {
        forward_declare_fun(fun, i, &mut p);
    }
    p.nl();

    for (i, closure) in pgm.closures.iter().enumerate() {
        forward_declare_closure(closure, i, &mut p);
    }
    p.nl();

    p.nl();
    w!(
        p,
        "// Statically allocated singletons for nullary constructors"
    );
    p.nl();
    for heap_obj in pgm.heap_objs.iter() {
        match heap_obj {
            HeapObj::Source(source_con) if source_con.fields.is_empty() => {
                let singleton_name = source_con_singleton_name(source_con);
                let struct_name = source_con_struct_name(source_con);
                let tag_name = source_con_tag_name(source_con);
                wln!(
                    p,
                    "static {} {}_data = {{ ._tag = {} }};",
                    struct_name,
                    singleton_name,
                    tag_name
                );
                wln!(p, "#define {} (&{}_data)", singleton_name, singleton_name);
            }
            HeapObj::Record(record) if record.fields.is_empty() => {
                let struct_name = record_struct_name(record);
                let tag_name = format!("TAG_{}", struct_name);
                let singleton_name = format!("_singleton_{}", struct_name);
                wln!(
                    p,
                    "static {} {}_data = {{ {} }};",
                    struct_name,
                    singleton_name,
                    tag_name
                );
                wln!(p, "#define {} (&{}_data)", singleton_name, singleton_name);
            }
            _ => {}
        }
    }
    p.nl();

    w!(
        p,
        "// Statically allocated closure objects for constructors"
    );
    p.nl();
    for (tag, heap_obj) in pgm.heap_objs.iter().enumerate() {
        match heap_obj {
            HeapObj::Source(source_con) if !source_con.fields.is_empty() => {
                w!(p, "static uint64_t _con_closure_{tag}_fun(CLOSURE* self");
                for (i, ty) in source_con.fields.iter().enumerate() {
                    w!(p, ", {} p{i}", c_ty(ty));
                }
                w!(p, ") {{");
                p.indent();
                p.nl();
                let struct_name = heap_obj_struct_name(pgm, HeapObjIdx(tag as u32));
                let tag_name = heap_obj_tag_name(pgm, HeapObjIdx(tag as u32));
                wln!(p, "{struct_name}* _obj = malloc(sizeof({struct_name}));");
                wln!(p, "_obj->_tag = {tag_name};");
                for i in 0..source_con.fields.len() {
                    wln!(p, "_obj->_{i} = p{i};");
                }
                w!(p, "return (uint64_t)_obj;");
                p.dedent();
                p.nl();
                wln!(p, "}}");

                w!(
                    p,
                    "static CLOSURE _con_closure_{tag}_data = {{ .tag = CLOSURE_TAG, .fun = (void(*)(void))_con_closure_{tag}_fun }};",
                );
                p.nl();

                w!(p, "#define _con_closure_{tag} (&_con_closure_{tag}_data)");
                p.nl();
                p.nl();
            }
            _ => {}
        }
    }
    p.nl();

    w!(
        p,
        "// Statically allocated closure objects for top-level functions"
    );
    p.nl();
    for (i, fun) in pgm.funs.iter().enumerate() {
        w!(
            p,
            "static {} _fun_closure_{}_fun(CLOSURE* self",
            c_ty(&fun.return_ty),
            i
        );
        for (i, ty) in fun.params.iter().enumerate() {
            w!(p, ", {} p{}", c_ty(ty), i);
        }
        w!(p, ") {{");
        p.indent();
        p.nl();
        w!(p, "return (({}(*)(", c_ty(&fun.return_ty));
        for (i, ty) in fun.params.iter().enumerate() {
            if i != 0 {
                w!(p, ", ");
            }
            w!(p, "{}", c_ty(ty));
        }
        w!(p, "))(_fun_{i}))(");
        for i in 0..fun.params.len() {
            if i != 0 {
                w!(p, ", ");
            }
            w!(p, "p{i}");
        }
        w!(p, ");");
        p.dedent();
        p.nl();
        wln!(p, "}}");

        w!(
            p,
            "static CLOSURE _fun_closure_{i}_data = {{ .tag = CLOSURE_TAG, .fun = (void(*)(void))_fun_closure_{i}_fun }};",
        );
        p.nl();

        w!(p, "#define _fun_closure_{i} (&_fun_closure_{i}_data)");
        p.nl();
        p.nl();
    }
    p.nl();

    let mut cg = Cg {
        pgm,
        temp_counter: 0,
    };

    // Generate built-in functions first. Built-in functions don't depend on each other or source
    // functions, but source functions can depend on built-in functions.
    for (i, fun) in pgm.funs.iter().enumerate() {
        if let FunBody::Builtin(builtin) = &fun.body {
            builtin_fun_to_c(
                builtin,
                &fun.ty_args,
                &fun.params,
                &fun.return_ty,
                &fun.exceptions,
                i,
                pgm,
                &mut p,
            );
            p.nl();
        }
    }

    // Generate source functions after built-in functions as they may depend on built-in functions
    // and built-in functions are not forward-declared.
    for (i, fun) in pgm.funs.iter().enumerate() {
        if let FunBody::Source(source) = &fun.body {
            source_fun_to_c(fun, source, i, &mut cg, &mut p);
            p.nl();
        }
    }

    for (i, closure) in pgm.closures.iter().enumerate() {
        closure_to_c(closure, i, &mut cg, &mut p);
        p.nl();
    }

    generate_main_fn(pgm, main, &mut p);

    p.print()
}

fn forward_declare_fun(fun: &Fun, idx: usize, p: &mut Printer) {
    w!(p, "// {} {}", loc_display(&fun.name.loc), fun.name.node);
    if !fun.ty_args.is_empty() {
        w!(p, "[");
        for (i, ty_arg) in fun.ty_args.iter().enumerate() {
            if i > 0 {
                w!(p, ", ");
            }
            let mut ty_str = String::new();
            ty_arg.print(&mut ty_str);
            w!(p, "{}", ty_str);
        }
        w!(p, "]");
    }
    p.nl();
    let param_count = fun.params.len();
    w!(p, "static {} _fun_{}(", c_ty(&fun.return_ty), idx);
    if param_count == 0 {
        w!(p, "void");
    } else {
        for (i, ty) in fun.params.iter().enumerate() {
            if i > 0 {
                w!(p, ", ");
            }
            w!(p, "{} _p{}", c_ty(ty), i);
        }
    }
    wln!(p, ");");
}

fn forward_declare_closure(closure: &Closure, idx: usize, p: &mut Printer) {
    wln!(p, "// {}", loc_display(&closure.loc));
    w!(
        p,
        "static {} _closure_{}(CLOSURE* _closure_obj",
        c_ty(&closure.return_ty),
        idx
    );
    for (i, ty) in closure.params.iter().enumerate() {
        w!(p, ", {} _p{}", c_ty(ty), i);
    }
    wln!(p, ");");
}

fn gen_closure_struct(closure: &Closure, idx: usize, p: &mut Printer) {
    if closure.fvs.is_empty() {
        return;
    }

    wln!(p, "// {}", loc_display(&closure.loc));
    w!(p, "typedef struct {{");
    p.indent();
    p.nl();
    wln!(p, "uint64_t tag;");
    wln!(p, "void (*fun)(void);");
    for (i, fv) in closure.fvs.iter().enumerate() {
        if i != 0 {
            p.nl();
        }
        let ty = &closure.locals[fv.use_idx.as_usize()].ty;
        w!(p, "{} _{}; // {}", c_ty(ty), i, fv.id);
    }
    p.dedent();
    p.nl();
    wln!(p, "}} _Closure_{idx};");
    p.nl();
}

fn heap_obj_to_c(heap_obj: &HeapObj, tag: u32, p: &mut Printer) {
    match heap_obj {
        HeapObj::Builtin(builtin) => builtin_con_decl_to_c(builtin, tag, p),
        HeapObj::Source(source_con) => source_con_decl_to_c(source_con, tag, p),
        HeapObj::Record(record) => record_decl_to_c(record, tag, p),
    }
}

fn builtin_con_decl_to_c(builtin: &BuiltinConDecl, tag: u32, p: &mut Printer) {
    match builtin {
        BuiltinConDecl::Con | BuiltinConDecl::Fun => {
            // These types are not used in the C backend, instead we generate static `CLOSURE`s.
        }

        BuiltinConDecl::Closure => {
            wln!(p, "#define CLOSURE_TAG {}", tag);
            writedoc!(
                p,
                "
                typedef struct {{
                    uint64_t tag;
                    void (*fun)(void);
                    uint64_t captures[];
                }} CLOSURE;
                "
            );
        }

        BuiltinConDecl::Array => {
            wln!(p, "#define ARRAY_TAG {}", tag);
            writedoc!(
                p,
                "
                typedef struct {{
                    uint64_t tag;
                    uint64_t* data_ptr; // initially points to the the `data` at the end
                    uint64_t len;
                    uint64_t data[];
                }} ARRAY;
                "
            );
        }

        BuiltinConDecl::I8 => {
            wln!(p, "// I8 tag {}", tag);
        }

        BuiltinConDecl::U8 => {
            wln!(p, "// U8 tag {}", tag);
        }

        BuiltinConDecl::I32 => {
            wln!(p, "// I32 tag {}", tag);
        }

        BuiltinConDecl::U32 => {
            wln!(p, "// U32 tag {}", tag);
        }

        BuiltinConDecl::I64 => {
            wln!(p, "// I64 tag {}", tag);
        }

        BuiltinConDecl::U64 => {
            wln!(p, "// U64 tag {}", tag);
        }
    }
}

fn source_con_tag_name(source_con: &SourceConDecl) -> String {
    let mut tag_name = String::from("TAG_");
    tag_name.push_str(&source_con.name);
    for ty_arg in &source_con.ty_args {
        tag_name.push('_');
        ty_to_c(ty_arg, &mut tag_name);
    }
    tag_name
}

fn source_con_struct_name(source_con: &SourceConDecl) -> String {
    let mut name = source_con.name.to_string();
    for ty_arg in &source_con.ty_args {
        name.push('_');
        ty_to_c(ty_arg, &mut name);
    }
    name
}

fn record_struct_name(record: &RecordType) -> String {
    let mut name = String::from("Record");
    for (field_name, field_ty) in &record.fields {
        name.push('_');
        name.push_str(field_name);
        name.push('_');
        ty_to_c(field_ty, &mut name);
    }
    name
}

fn heap_obj_struct_name(pgm: &LoweredPgm, idx: HeapObjIdx) -> String {
    match &pgm.heap_objs[idx.0 as usize] {
        HeapObj::Source(source_con) => source_con_struct_name(source_con),
        HeapObj::Record(record) => record_struct_name(record),
        HeapObj::Builtin(_) => panic!("Builtin in heap_obj_struct_name"),
    }
}

fn heap_obj_tag_name(pgm: &LoweredPgm, idx: HeapObjIdx) -> String {
    match &pgm.heap_objs[idx.0 as usize] {
        HeapObj::Source(source_con) => source_con_tag_name(source_con),
        HeapObj::Record(record) => format!("TAG_{}", record_struct_name(record)),
        HeapObj::Builtin(_) => panic!("Builtin in heap_obj_tag_name"),
    }
}

fn sum_struct_name(ty_id: &Id, ty_args: &[mono::Type]) -> String {
    let mut struct_name = ty_id.to_string();
    for ty_arg in ty_args {
        struct_name.push('_');
        ty_to_c(ty_arg, &mut struct_name);
    }
    struct_name
}

/// Generate singleton variable name for a nullary source constructor.
fn source_con_singleton_name(source_con: &SourceConDecl) -> String {
    let mut name = String::from("_singleton_");
    name.push_str(&source_con.name);
    for ty_arg in &source_con.ty_args {
        name.push('_');
        ty_to_c(ty_arg, &mut name);
    }
    name
}

/// Get the singleton variable name for a heap object (nullary constructors only).
fn heap_obj_singleton_name(pgm: &LoweredPgm, idx: HeapObjIdx) -> String {
    match &pgm.heap_objs[idx.0 as usize] {
        HeapObj::Source(source_con) => source_con_singleton_name(source_con),
        HeapObj::Record(record) => format!("_singleton_{}", record_struct_name(record)),
        HeapObj::Builtin(_) => panic!("Builtin heap objects don't have singletons"),
    }
}

fn source_con_decl_to_c(source_con: &SourceConDecl, tag: u32, p: &mut Printer) {
    let SourceConDecl {
        name: _,
        idx,
        ty_args: _,
        fields,
    } = source_con;

    assert_eq!(idx.0, tag);

    let tag_name = source_con_tag_name(source_con);
    let struct_name = source_con_struct_name(source_con);

    wln!(p, "#define {} {}", tag_name, tag);

    w!(p, "typedef struct {} {{", struct_name);
    p.indent();
    p.nl();
    w!(p, "uint64_t _tag;");
    for (i, ty) in fields.iter().enumerate() {
        p.nl();
        w!(p, "{} _{};", c_ty(ty), i);
    }
    p.dedent();
    p.nl();
    wln!(p, "}} {};", struct_name);
}

fn record_decl_to_c(record: &RecordType, tag: u32, p: &mut Printer) {
    let struct_name = record_struct_name(record);

    wln!(p, "#define TAG_{} {}", struct_name, tag);

    w!(p, "typedef struct {} {{", struct_name);
    p.indent();
    p.nl();
    w!(p, "uint64_t _tag;");
    for (i, (_field_name, field_ty)) in record.fields.iter().enumerate() {
        p.nl();
        w!(p, "{} _{};", c_ty(field_ty), i);
    }
    p.dedent();
    p.nl();
    wln!(p, "}} {};", struct_name);
}

fn named_ty_to_c(named_ty: &mono::NamedType, out: &mut String) {
    out.push_str(&named_ty.name);
    for arg in &named_ty.args {
        out.push('_');
        ty_to_c(arg, out);
    }
}

fn is_value_type(ty: &mono::Type) -> bool {
    if let mono::Type::Named(mono::NamedType { name, args: _ }) = ty {
        matches!(
            name.as_str(),
            "I8" | "U8" | "I16" | "U16" | "I32" | "U32" | "I64" | "U64"
        )
    } else {
        false
    }
}

fn c_ty(ty: &mono::Type) -> String {
    // Special case for value types for now.
    if let mono::Type::Named(mono::NamedType { name, args: _ }) = ty {
        let name_str = name.as_str();
        if matches!(
            name_str,
            "I8" | "U8" | "I16" | "U16" | "I32" | "U32" | "I64" | "U64"
        ) {
            return name_str.to_string();
        }
        if matches!(name_str, "Array") {
            return "ARRAY*".to_string();
        }
    }
    if let mono::Type::Fn(_) = ty {
        return "CLOSURE*".to_string();
    }
    if let mono::Type::Never = ty {
        panic!();
    }
    let mut s = String::new();
    ty_to_c(ty, &mut s);
    s.push('*'); // make pointer
    s
}

fn ty_to_c(ty: &mono::Type, out: &mut String) {
    match ty {
        mono::Type::Named(named_ty) => {
            named_ty_to_c(named_ty, out);
        }

        mono::Type::Record { fields } => {
            out.push_str("Record");
            for (field_name, field_ty) in fields {
                w!(out, "_{}_", field_name);
                ty_to_c(field_ty, out);
            }
        }

        mono::Type::Variant { alts } => {
            out.push_str("Variant");
            for alt in alts.values() {
                out.push('_');
                named_ty_to_c(alt, out);
            }
        }

        mono::Type::Fn(mono::FnType { args, ret, exn }) => {
            out.push_str("Fn");
            match args {
                mono::FunArgs::Positional(positional_args) => {
                    for arg in positional_args {
                        out.push('_');
                        ty_to_c(arg, out);
                    }
                }
                mono::FunArgs::Named(named_args) => {
                    for (name, arg) in named_args {
                        out.push('_');
                        out.push_str(name);
                        out.push('_');
                        ty_to_c(arg, out);
                    }
                }
            }
            out.push('_');
            ty_to_c(ret, out);
            out.push('_');
            ty_to_c(exn, out);
        }

        mono::Type::Never => {
            out.push_str("Never");
        }
    }
}

fn builtin_fun_to_c(
    fun: &BuiltinFunDecl,
    ty_args: &[mono::Type],
    params: &[mono::Type],
    ret: &mono::Type,
    _exn: &mono::Type,
    idx: usize,
    pgm: &LoweredPgm,
    p: &mut Printer,
) {
    // Debug output of `fun` is too noisy, but it's better than not knowing what the generated
    // functions are for.
    wln!(p, "// {:?}", fun);
    match fun {
        BuiltinFunDecl::Panic => {
            w!(p, "static {} _fun_{}(Str* msg) {{", c_ty(ret), idx);
            p.indent();
            p.nl();
            wln!(p, "ARRAY* bytes_arr = msg->_0;");
            wln!(p, "uint32_t len = array_len(bytes_arr);");
            w!(p, "uint8_t* data_ptr = (uint8_t*)bytes_arr->data_ptr;");
            p.nl();
            wln!(p, "fprintf(stderr, \"PANIC: \");");
            wln!(p, "fwrite(data_ptr, 1, len, stderr);");
            wln!(p, "fprintf(stderr, \"\\n\");");
            w!(p, "exit(1);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::PrintStrNoNl => {
            w!(p, "static Record* _fun_{}(Str* str) {{", idx);
            p.indent();
            p.nl();
            wln!(p, "ARRAY* bytes_arr = str->_0;");
            wln!(p, "uint32_t len = array_len(bytes_arr);");
            w!(p, "uint8_t* data_ptr = (uint8_t*)bytes_arr->data_ptr;");
            p.nl();
            wln!(p, "fwrite(data_ptr, 1, len, stdout);");
            w!(
                p,
                "return {};",
                heap_obj_singleton_name(pgm, pgm.unit_con_idx)
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::ShrI8 => {
            w!(p, "static I8 _fun_{idx}(I8 a, I8 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a >> b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::ShrU8 => {
            w!(p, "static U8 _fun_{idx}(U8 a, U8 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a >> b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::ShrI32 => {
            w!(p, "static I32 _fun_{idx}(I32 a, I32 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a >> b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::ShrU32 => {
            w!(p, "static U32 _fun_{idx}(U32 a, U32 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a >> b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::BitAndI8 => {
            w!(p, "static I8 _fun_{idx}(I8 a, I8 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a & b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::BitAndU8 => {
            w!(p, "static U8 _fun_{idx}(U8 a, U8 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a & b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::BitAndI32 => {
            w!(p, "static I32 _fun_{idx}(I32 a, I32 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a & b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::BitAndU32 => {
            w!(p, "static U32 _fun_{idx}(U32 a, U32 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a & b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::BitOrI8 => {
            w!(p, "static I8 _fun_{idx}(I8 a, I8 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a | b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::BitOrU8 => {
            w!(p, "static U8 _fun_{idx}(U8 a, U8 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a | b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::BitOrI32 => {
            w!(p, "static I32 _fun_{idx}(I32 a, I32 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a | b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::BitOrU32 => {
            w!(p, "static U32 _fun_{idx}(U32 a, U32 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a | b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::BitXorU32 => {
            w!(p, "static U32 _fun_{idx}(U32 a, U32 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a ^ b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::ToStrI8 => {
            gen_tostr_fn(idx, "I8", "PRId8", p);
        }

        BuiltinFunDecl::ToStrU8 => {
            gen_tostr_fn(idx, "U8", "PRIu8", p);
        }

        BuiltinFunDecl::ToStrI32 => {
            gen_tostr_fn(idx, "I32", "PRId32", p);
        }

        BuiltinFunDecl::ToStrU32 => {
            gen_tostr_fn(idx, "U32", "PRIu32", p);
        }

        BuiltinFunDecl::ToStrU64 => {
            gen_tostr_fn(idx, "U64", "PRIu64", p);
        }

        BuiltinFunDecl::ToStrI64 => {
            gen_tostr_fn(idx, "I64", "PRId64", p);
        }

        BuiltinFunDecl::U8AsI8 => {
            w!(p, "static I8 _fun_{idx}(U8 a) {{");
            p.indent();
            p.nl();
            w!(p, "return (I8)a;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U8AsU32 => {
            w!(p, "static U32 _fun_{idx}(U8 a) {{");
            p.indent();
            p.nl();
            w!(p, "return (U32)a;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U32AsU8 => {
            w!(p, "static U8 _fun_{idx}(U32 a) {{");
            p.indent();
            p.nl();
            w!(p, "return (U8)a;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U32AsI32 => {
            w!(p, "static I32 _fun_{}(U32 a) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (I32)a;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U32AsU64 => {
            w!(p, "static U32 _fun_{}(U64 a) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (U32)a;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I8Shl => {
            w!(p, "static I8 _fun_{idx}(I8 a, I8 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a << b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U8Shl => {
            w!(p, "static U8 _fun_{idx}(U8 a, U8 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a << b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I32Shl => {
            w!(p, "static I32 _fun_{idx}(I32 a, I32 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a << b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U32Shl => {
            w!(p, "static U32 _fun_{idx}(U32 a, U32 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a << b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I8Cmp => gen_cmp_fn(idx, "I8", pgm, p),
        BuiltinFunDecl::U8Cmp => gen_cmp_fn(idx, "U8", pgm, p),
        BuiltinFunDecl::I32Cmp => gen_cmp_fn(idx, "I32", pgm, p),
        BuiltinFunDecl::U32Cmp => gen_cmp_fn(idx, "U32", pgm, p),
        BuiltinFunDecl::U64Cmp => gen_cmp_fn(idx, "U64", pgm, p),

        BuiltinFunDecl::I8Add => {
            w!(p, "static I8 _fun_{idx}(I8 a, I8 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a + b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U8Add => {
            w!(p, "static U8 _fun_{idx}(U8 a, U8 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a + b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I32Add => {
            w!(p, "static I32 _fun_{idx}(I32 a, I32 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a + b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U32Add => {
            w!(p, "static U32 _fun_{idx}(U32 a, U32 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a + b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U64Add => {
            w!(p, "static U64 _fun_{idx}(U64 a, U64 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a + b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I8Sub => {
            w!(p, "static I8 _fun_{idx}(I8 a, I8 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a - b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U8Sub => {
            w!(p, "static U8 _fun_{idx}(U8 a, U8 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a - b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I32Sub => {
            w!(p, "static I32 _fun_{idx}(I32 a, I32 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a - b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U32Sub => {
            w!(p, "static U32 _fun_{idx}(U32 a, U32 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a - b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I8Mul => {
            w!(p, "static I8 _fun_{idx}(I8 a, I8 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a * b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U8Mul => {
            w!(p, "static U8 _fun_{idx}(U8 a, U8 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a * b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I32Mul => {
            w!(p, "static I32 _fun_{idx}(I32 a, I32 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a * b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U32Mul => {
            w!(p, "static U32 _fun_{idx}(U32 a, U32 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a * b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U64Mul => {
            w!(p, "static U64 _fun_{idx}(U64 a, U64 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a * b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I8Div => {
            w!(p, "static I8 _fun_{}(I8 a, I8 b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return a / b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U8Div => {
            w!(p, "static U8 _fun_{idx}(U8 a, U8 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a / b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I32Div => {
            w!(p, "static I32 _fun_{idx}(I32 a, I32 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a / b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U32Div => {
            w!(p, "static U32 _fun_{}(U32 a, U32 b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return a / b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I8Eq => {
            w!(p, "static Bool* _fun_{idx}(I8 a, I8 b) {{");
            p.indent();
            p.nl();
            w!(
                p,
                "return (a == b) ? (Bool*){} : (Bool*){};",
                heap_obj_singleton_name(pgm, pgm.true_con_idx),
                heap_obj_singleton_name(pgm, pgm.false_con_idx)
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U8Eq => {
            w!(p, "static Bool* _fun_{idx}(U8 a, U8 b) {{");
            p.indent();
            p.nl();
            w!(
                p,
                "return (a == b) ? (Bool*){} : (Bool*){};",
                heap_obj_singleton_name(pgm, pgm.true_con_idx),
                heap_obj_singleton_name(pgm, pgm.false_con_idx)
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I32Eq => {
            w!(p, "static Bool* _fun_{}(I32 a, I32 b) {{", idx);
            p.indent();
            p.nl();
            w!(
                p,
                "return (a == b) ? (Bool*){} : (Bool*){};",
                heap_obj_singleton_name(pgm, pgm.true_con_idx),
                heap_obj_singleton_name(pgm, pgm.false_con_idx)
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U32Eq => {
            w!(p, "static Bool* _fun_{}(U32 a, U32 b) {{", idx);
            p.indent();
            p.nl();
            w!(
                p,
                "return (a == b) ? (Bool*){} : (Bool*){};",
                heap_obj_singleton_name(pgm, pgm.true_con_idx),
                heap_obj_singleton_name(pgm, pgm.false_con_idx)
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U32Mod => {
            w!(p, "static U32 _fun_{idx}(U32 a, U32 b) {{");
            p.indent();
            p.nl();
            w!(p, "return a % b;"); // TODO: I think is rem, not mod.
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I8Rem => {
            w!(p, "static I8 _fun_{}(I8 a, I8 b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return a % b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U8Rem => {
            w!(p, "static U8 _fun_{}(U8 a, U8 b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return a % b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I32Rem => {
            w!(p, "static I32 _fun_{}(I32 a, I32 b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return a % b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U32Rem => {
            w!(p, "static U32 _fun_{}(U32 a, U32 b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return a % b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I32AsU32 => {
            w!(p, "static U32 _fun_{}(I32 a) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (U32)a;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I32Abs => {
            w!(p, "static I32 _fun_{}(I32 a) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (v < 0 ? -v : v);"); // TODO FIXME
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I8Neg => {
            w!(p, "static I8 _fun_{}(I8 a) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return -a;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I32Neg => {
            w!(p, "static I32 _fun_{}(I32 a) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return -a;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::ThrowUnchecked => {
            w!(
                p,
                "static {} _fun_{}({} exn) {{",
                c_ty(ret),
                idx,
                c_ty(&params[0])
            );
            p.indent();
            p.nl();
            wln!(p, "throw_exn((uint64_t)exn);");
            w!(p, "__builtin_unreachable();");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::Try { ok_con, err_con } => {
            // prim try(cb: Fn() a / exn) Result[exn, a] / exn?
            // Type args: a, exn, exn? (implicit)
            let cb_ty = match &params[0] {
                mono::Type::Fn(ty) => ty,
                _ => panic!(),
            };
            w!(p, "static {} _fun_{idx}(CLOSURE* cb) {{", c_ty(ret));
            p.indent();
            p.nl();
            wln!(p, "ExnHandler handler;");
            wln!(p, "handler.prev = current_exn_handler;");
            wln!(p, "current_exn_handler = &handler;");
            w!(p, "if (setjmp(handler.buf) == 0) {{");
            p.indent();
            p.nl();
            wln!(p, "// Call the closure");
            let cb_ret = c_ty(&cb_ty.ret);
            wln!(
                p,
                "{cb_ret} (*fn)(CLOSURE*) = ({cb_ret} (*)(CLOSURE*))cb->fun;"
            );
            wln!(p, "{cb_ret} result = fn(cb);");
            wln!(p, "current_exn_handler = handler.prev;");
            wln!(p, "// Allocate Ok result");
            let ok_tag_name = heap_obj_tag_name(pgm, *ok_con);
            let ok_struct_name = heap_obj_struct_name(pgm, *ok_con);
            wln!(
                p,
                "{ok_struct_name}* ok = malloc(sizeof({ok_struct_name}));"
            );
            wln!(p, "ok->_tag = {ok_tag_name};");
            wln!(p, "ok->_0 = result;");
            w!(p, "return ({})ok;", c_ty(ret));
            p.dedent();
            p.nl();
            w!(p, "}} else {{");
            p.indent();
            p.nl();
            wln!(p, "// Exception was thrown");
            let err_tag_name = heap_obj_tag_name(pgm, *err_con);
            let err_struct_name = heap_obj_struct_name(pgm, *err_con);
            wln!(p, "current_exn_handler = handler.prev;");
            wln!(
                p,
                "{err_struct_name}* err = malloc(sizeof({err_struct_name}));"
            );
            wln!(p, "err->_tag = {};", err_tag_name);
            wln!(p, "err->_0 = ({})handler.exn_value;", c_ty(&ty_args[1]));
            w!(p, "return ({})err;", c_ty(ret));
            p.dedent();
            p.nl();
            w!(p, "}}");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        // Array functions /////////////////////////////////////////////////////////////////////////
        BuiltinFunDecl::ArrayNew { t } => {
            let repr = Repr::from_mono_ty(t);
            let fn_name = match repr {
                Repr::U8 => "array_new_u8",
                Repr::U32 => "array_new_u32",
                Repr::U64 => "array_new_u64",
            };
            w!(p, "static ARRAY* _fun_{}(U32 len) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return {}(len);", fn_name);
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::ArrayLen => {
            w!(p, "static U32 _fun_{}(ARRAY* arr) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return array_len(arr);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::ArrayGet { t } => {
            let repr = Repr::from_mono_ty(t);
            let fn_name = match repr {
                Repr::U8 => "array_get_u8",
                Repr::U32 => "array_get_u32",
                Repr::U64 => "array_get_u64",
            };
            w!(
                p,
                "static {} _fun_{}(ARRAY* arr, U32 idx) {{",
                c_ty(ret),
                idx
            );
            p.indent();
            p.nl();
            w!(p, "return ({}){}(arr, (uint32_t)idx);", c_ty(ret), fn_name);
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::ArraySet { t } => {
            let repr = Repr::from_mono_ty(t);
            let (fn_name, cast) = match repr {
                Repr::U8 => ("array_set_u8", "U8"),
                Repr::U32 => ("array_set_u32", "U32"),
                Repr::U64 => ("array_set_u64", "U64"),
            };
            w!(
                p,
                "static Record* _fun_{}(ARRAY* arr, U32 idx, {} val) {{",
                idx,
                c_ty(&params[2]),
            );
            p.indent();
            p.nl();
            wln!(p, "{fn_name}(arr, (uint32_t)idx, ({cast})val);");
            w!(
                p,
                "return {};",
                heap_obj_singleton_name(pgm, pgm.unit_con_idx)
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::ArraySlice { t } => {
            let repr = Repr::from_mono_ty(t);
            let fn_name = match repr {
                Repr::U8 => "array_slice_u8",
                Repr::U32 => "array_slice_u32",
                Repr::U64 => "array_slice_u64",
            };
            w!(
                p,
                "static ARRAY* _fun_{idx}(ARRAY* arr, U32 start, U32 end) {{",
            );
            p.indent();
            p.nl();
            w!(p, "return {}(arr, start, end);", fn_name);
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::ArrayCopyWithin { t } => {
            let repr = Repr::from_mono_ty(t);
            let fn_name = match repr {
                Repr::U8 => "array_copy_within_u8",
                Repr::U32 => "array_copy_within_u32",
                Repr::U64 => "array_copy_within_u64",
            };
            w!(
                p,
                "static Record* _fun_{}(ARRAY* arr, U32 src, U32 dst, U32 len) {{",
                idx
            );
            p.indent();
            p.nl();
            w!(p, "{}(arr, src, dst, len);", fn_name);
            p.nl();
            w!(
                p,
                "return {};",
                heap_obj_singleton_name(pgm, pgm.unit_con_idx)
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        // End of array functions //////////////////////////////////////////////////////////////////
        BuiltinFunDecl::ReadFileUtf8 => {
            w!(p, "static Str* _fun_{}(Str* path_str) {{", idx);
            p.indent();
            p.nl();
            wln!(p, "ARRAY* bytes_arr = path_str->_0;");
            wln!(p, "uint32_t path_len = array_len(bytes_arr);");
            w!(p, "uint8_t* path_data = (uint8_t*)bytes_arr->data_ptr;");
            p.nl();
            wln!(p, "char* path = (char*)malloc(path_len + 1);");
            wln!(p, "memcpy(path, path_data, path_len);");
            wln!(p, "path[path_len] = '\\0';");
            wln!(p, "FILE* f = fopen(path, \"rb\");");
            wln!(p, "free(path);");
            w!(
                p,
                "if (!f) {{ fprintf(stderr, \"Failed to open file\\n\"); exit(1); }}"
            );
            p.nl();
            wln!(p, "fseek(f, 0, SEEK_END);");
            wln!(p, "long size = ftell(f);");
            wln!(p, "fseek(f, 0, SEEK_SET);");
            wln!(p, "char* contents = (char*)malloc(size);");
            wln!(
                p,
                "if (fread(contents, 1, size, f) != (size_t)size) {{ fprintf(stderr, \"Failed to read file\\n\"); exit(1); }}"
            );
            wln!(p, "fclose(f);");
            w!(p, "Str* result = alloc_str(contents, size);");
            p.nl();
            wln!(p, "free(contents);");
            w!(p, "return result;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::GetArgs => {
            w!(p, "static ARRAY* _fun_{}(void) {{", idx);
            p.indent();
            p.nl();
            wln!(p, "ARRAY* arr = array_new_u64(g_argc);");
            w!(p, "for (int i = 0; i < g_argc; i++) {{");
            p.indent();
            p.nl();
            w!(p, "Str* arg_str = alloc_str(g_argv[i], strlen(g_argv[i]));",);
            p.nl();
            w!(p, "array_set_u64(arr, i, (U64)arg_str);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
            w!(p, "return arr;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }
    }
}

fn gen_tostr_fn(idx: usize, arg_ty: &str, fmt: &str, p: &mut Printer) {
    w!(p, "static Str* _fun_{}({arg_ty} a) {{", idx);
    p.indent();
    p.nl();
    wln!(p, "char buf[32];");
    w!(p, "int len = snprintf(buf, sizeof(buf), \"%\" {fmt} , a);",);
    p.nl();
    w!(p, "return alloc_str(buf, len);");
    p.dedent();
    p.nl();
    wln!(p, "}}");
}

fn gen_cmp_fn(idx: usize, arg_ty: &str, pgm: &LoweredPgm, p: &mut Printer) {
    w!(p, "static Ordering* _fun_{idx}({arg_ty} a, {arg_ty} b) {{");
    p.indent();
    p.nl();
    w!(
        p,
        "if (a < b) return (Ordering*){};",
        heap_obj_singleton_name(pgm, pgm.ordering_less_con_idx)
    );
    p.nl();
    w!(
        p,
        "if (a > b) return (Ordering*){};",
        heap_obj_singleton_name(pgm, pgm.ordering_greater_con_idx)
    );
    p.nl();
    w!(
        p,
        "return (Ordering*){};",
        heap_obj_singleton_name(pgm, pgm.ordering_equal_con_idx)
    );
    p.dedent();
    p.nl();
    wln!(p, "}}");
}

fn source_fun_to_c(fun: &Fun, source: &SourceFunDecl, idx: usize, cg: &mut Cg, p: &mut Printer) {
    let loc = &fun.name.loc;
    w!(p, "// {} {}", loc_display(loc), fun.name.node);
    if !fun.ty_args.is_empty() {
        w!(p, "[");
        for (i, ty_arg) in fun.ty_args.iter().enumerate() {
            if i > 0 {
                w!(p, ", ");
            }
            let mut ty_str = String::new();
            ty_arg.print(&mut ty_str);
            w!(p, "{}", ty_str);
        }
        w!(p, "]");
    }
    p.nl();
    w!(p, "static {} _fun_{}(", c_ty(&fun.return_ty), idx);
    for (i, ty) in fun.params.iter().enumerate() {
        if i > 0 {
            w!(p, ", ");
        }
        w!(p, "{} _{}", c_ty(ty), i);
    }
    w!(p, ") {{");
    p.indent();
    p.nl();

    // Declare locals. First few locals are for parameters, skip those.
    for (i, local) in source.locals.iter().enumerate().skip(fun.params.len()) {
        wln!(
            p,
            "{} _{}; // {}: {}",
            c_ty(&local.ty),
            i,
            local.name,
            local.ty
        );
    }

    // Declare result variable
    w!(p, "{} _result;", c_ty(&fun.return_ty));
    p.nl();

    // Generate body
    stmts_to_c(
        &source.body,
        Some(("_result", &fun.return_ty)),
        &source.locals,
        cg,
        p,
    );

    w!(p, "return _result;");
    p.dedent();
    p.nl();
    wln!(p, "}}");
}

fn closure_to_c(closure: &Closure, idx: usize, cg: &mut Cg, p: &mut Printer) {
    w!(
        p,
        "static {} _closure_{}(CLOSURE* _closure_obj",
        c_ty(&closure.return_ty),
        idx
    );
    for (i, ty) in closure.params.iter().enumerate() {
        w!(p, ", {} _{}", c_ty(ty), i);
    }
    w!(p, ") {{");
    p.indent();
    p.nl();

    // Declare locals.
    for (i, local) in closure.locals.iter().enumerate().skip(closure.params.len()) {
        wln!(
            p,
            "{} _{}; // {}: {}",
            c_ty(&local.ty),
            i,
            local.name,
            local.ty
        );
    }

    // Load free variables from closure object
    if !closure.fvs.is_empty() {
        for (i, fv) in closure.fvs.iter().enumerate() {
            w!(
                p,
                "_{} = ((_Closure_{}*)_closure_obj)->_{}; // {}",
                fv.use_idx.as_usize(),
                idx,
                i,
                fv.id
            );
            p.nl();
        }
    }

    // Declare result variable
    w!(p, "{} _result;", c_ty(&closure.return_ty));
    p.nl();

    // Generate body
    stmts_to_c(
        &closure.body,
        Some(("_result", &closure.return_ty)),
        &closure.locals,
        cg,
        p,
    );

    w!(p, "return _result;");
    p.dedent();
    p.nl();
    wln!(p, "}}");
}

fn stmts_to_c(
    stmts: &[mono::L<Stmt>],
    result_var: Option<(&str, &mono::Type)>,
    locals: &[LocalInfo],
    cg: &mut Cg,
    p: &mut Printer,
) {
    if stmts.is_empty() {
        if let Some((result_var, _)) = result_var {
            wln!(
                p,
                "{result_var} = {};",
                heap_obj_singleton_name(cg.pgm, cg.pgm.unit_con_idx)
            );
        }
        return;
    }
    let last_stmt_idx = stmts.len() - 1;
    for (i, stmt) in stmts.iter().enumerate() {
        stmt_to_c(
            &stmt.node,
            &stmt.loc,
            if i == last_stmt_idx { result_var } else { None },
            locals,
            cg,
            p,
        );
    }
}

fn stmt_to_c(
    stmt: &Stmt,
    loc: &Loc,
    result_var: Option<(&str, &mono::Type)>,
    locals: &[LocalInfo],
    cg: &mut Cg,
    p: &mut Printer,
) {
    match stmt {
        Stmt::Let(LetStmt { lhs, rhs, rhs_ty }) => {
            let rhs_temp = cg.fresh_temp();
            w!(p, "{} {} = ", c_ty(rhs_ty), rhs_temp);
            expr_to_c(&rhs.node, &rhs.loc, Some(rhs_ty), locals, cg, p);
            wln!(p, "; // {}", loc_display(&rhs.loc));
            wln!(p, "{};", pat_to_cond(&lhs.node, &rhs_temp, cg));
            if let Some((result_var, _)) = result_var {
                wln!(
                    p,
                    "{result_var} = {};",
                    heap_obj_singleton_name(cg.pgm, cg.pgm.unit_con_idx)
                );
            }
        }

        Stmt::Assign(AssignStmt { lhs, rhs }) => match &lhs.node {
            Expr::LocalVar(idx) => {
                let local_ty = &locals[idx.as_usize()].ty;
                w!(p, "_{} = ", idx.as_usize());
                expr_to_c(&rhs.node, &rhs.loc, Some(local_ty), locals, cg, p);
                wln!(p, ";");
                if let Some((result_var, _)) = result_var {
                    wln!(
                        p,
                        "{result_var} = {};",
                        heap_obj_singleton_name(cg.pgm, cg.pgm.unit_con_idx)
                    );
                }
            }
            Expr::FieldSel(FieldSelExpr {
                object,
                field: _,
                idx,
                object_ty,
                ty,
            }) => {
                let obj_temp = cg.fresh_temp();
                w!(p, "{} {} = ", c_ty(object_ty), obj_temp);
                expr_to_c(&object.node, &object.loc, Some(object_ty), locals, cg, p);
                wln!(p, "; // {}", loc_display(&object.loc));
                w!(p, "{}->_{} = ", obj_temp, idx);
                expr_to_c(&rhs.node, &rhs.loc, Some(ty), locals, cg, p);
                wln!(p, ";");
                if let Some((result_var, _)) = result_var {
                    wln!(
                        p,
                        "{result_var} = {};",
                        heap_obj_singleton_name(cg.pgm, cg.pgm.unit_con_idx)
                    );
                }
            }
            _ => {
                // Type checker only accepts variables and fields on the LHS.
                panic!(
                    "{}: BUG: Assign statement with fancy LHS",
                    loc_display(&lhs.loc)
                )
            }
        },

        Stmt::Expr(expr) => {
            if let Some((result_var, result_ty)) = result_var {
                w!(p, "{result_var} = ");
            }
            expr_to_c(
                expr,
                loc,
                result_var.map(|(_, result_ty)| result_ty),
                locals,
                cg,
                p,
            ); // TODO: expected type
            wln!(p, ";");
        }

        Stmt::While(WhileStmt { label, cond, body }) => {
            w!(p, "while (1) {{");
            p.indent();
            p.nl();
            let cond_temp = cg.fresh_temp();
            w!(p, "Bool* {cond_temp} = ");
            expr_to_c(
                &cond.node,
                &cond.loc,
                Some(&mono::Type::bool()),
                locals,
                cg,
                p,
            );
            wln!(p, ";");
            w!(
                p,
                "if ({} == (Bool*){}) break;",
                cond_temp,
                heap_obj_singleton_name(cg.pgm, cg.pgm.false_con_idx)
            );
            p.nl();
            stmts_to_c(body, None, locals, cg, p);
            if let Some(label) = label {
                w!(p, "_continue_{}:;", label);
            }
            p.dedent();
            p.nl();
            wln!(p, "}}");
            if let Some(label) = label {
                wln!(p, "_break_{}:;", label);
            }
            if let Some((result_var, _)) = result_var {
                wln!(
                    p,
                    "{result_var} = {};",
                    heap_obj_singleton_name(cg.pgm, cg.pgm.unit_con_idx)
                );
            }
        }

        Stmt::Break { label, level: _ } => {
            match label {
                Some(label) => w!(p, "goto _break_{};", label),
                None => w!(p, "break;"),
            }
            p.nl();
        }

        Stmt::Continue { label, level: _ } => {
            match label {
                Some(label) => w!(p, "goto _continue_{};", label),
                None => w!(p, "continue;"),
            }
            p.nl();
        }
    }
}

/// `expected_ty` is used to generate dummy values after `return` statements, based on the type.
///
/// In C, `({ ... return x; ... })` has type `void`, which can't be used (i.e. can't be in an
/// assignment RHS). So we generate `({ ... return x; dummy; })` instead. (where `dummy` is based on
/// the expected type)
fn expr_to_c(
    expr: &Expr,
    loc: &Loc,
    expected_ty: Option<&mono::Type>,
    locals: &[LocalInfo],
    cg: &mut Cg,
    p: &mut Printer,
) {
    match expr {
        Expr::LocalVar(idx) => {
            w!(p, "_{}", idx.as_usize());
        }

        Expr::Fun(fun_idx) => {
            // Return a closure object for the function
            w!(p, "_fun_closure_{}", fun_idx.as_usize());
        }

        Expr::Con(heap_obj_idx) => {
            // Return a constructor closure object
            w!(p, "_con_closure_{}", heap_obj_idx.0);
        }

        Expr::ConAlloc(heap_obj_idx, args, ty) => {
            if args.is_empty() {
                // Return singleton
                w!(
                    p,
                    "({}){}",
                    c_ty(ty),
                    heap_obj_singleton_name(cg.pgm, *heap_obj_idx)
                );
            } else {
                let struct_name = heap_obj_struct_name(cg.pgm, *heap_obj_idx);
                let tag_name = heap_obj_tag_name(cg.pgm, *heap_obj_idx);
                w!(p, "({{");
                p.indent();
                p.nl();
                wln!(p, "{struct_name}* _obj = malloc(sizeof({struct_name}));");
                wln!(p, "_obj->_tag = {tag_name};");
                for (i, arg) in args.iter().enumerate() {
                    w!(p, "_obj->_{i} = ");
                    expr_to_c(&arg.node, &arg.loc, None, locals, cg, p);
                    wln!(p, ";");
                }
                w!(p, "({})_obj;", c_ty(ty));
                p.dedent();
                p.nl();
                w!(p, "}})");
            }
        }

        Expr::FieldSel(FieldSelExpr {
            object,
            field: _,
            idx,
            object_ty,
            ty: _,
        }) => {
            // TODO: We need the object type here to be able to get the struct type
            w!(p, "(");
            expr_to_c(&object.node, &object.loc, Some(object_ty), locals, cg, p);
            w!(p, ")->_{}", idx);
        }

        Expr::Call(CallExpr { fun, args, fun_ty }) => {
            // Check if direct function call
            match &fun.node {
                Expr::Fun(fun_idx) => {
                    // Direct function call
                    w!(p, "_fun_{}(", fun_idx.as_usize());
                    for (i, arg) in args.iter().enumerate() {
                        if i > 0 {
                            w!(p, ", ");
                        }
                        expr_to_c(
                            &arg.node,
                            &arg.loc,
                            Some(&mono::Type::Fn(fun_ty.clone())),
                            locals,
                            cg,
                            p,
                        );
                    }
                    w!(p, ")");
                }
                other => {
                    // Closure call
                    w!(p, "({{");
                    p.indent();
                    p.nl();
                    let fun_temp = cg.fresh_temp();
                    w!(p, "CLOSURE* {} = ", fun_temp);
                    expr_to_c(
                        other,
                        &fun.loc,
                        Some(&mono::Type::Fn(fun_ty.clone())),
                        locals,
                        cg,
                        p,
                    );
                    wln!(p, ";");
                    wln!(p, "uint32_t _tag = get_tag({});", fun_temp);

                    // Closure call - need to pass closure object as first arg
                    w!(p, "{} (*_fn)(CLOSURE*", c_ty(&fun_ty.ret));
                    assert_eq!(args.len(), fun_ty.args.len());
                    let arg_tys: Vec<&mono::Type> = match &fun_ty.args {
                        mono::FunArgs::Positional(args) => args.iter().collect(),
                        mono::FunArgs::Named(args) => args.values().collect(),
                    };
                    let arg_ty_strs: Vec<String> = arg_tys.iter().map(|ty| c_ty(ty)).collect();
                    for arg_ty in arg_ty_strs.iter() {
                        w!(p, ", {arg_ty}");
                    }
                    w!(p, ") = ({} (*)(CLOSURE*", c_ty(&fun_ty.ret));
                    for arg_ty in arg_ty_strs.iter() {
                        w!(p, ", {arg_ty}");
                    }
                    wln!(p, "))((CLOSURE*){})->fun;", fun_temp);
                    w!(p, "_fn({}", fun_temp);
                    assert_eq!(args.len(), arg_ty_strs.len());
                    for (arg, arg_ty) in args.iter().zip(arg_tys.iter()) {
                        w!(p, ", ");
                        expr_to_c(&arg.node, &arg.loc, Some(arg_ty), locals, cg, p);
                    }
                    w!(p, ");");
                    p.dedent();
                    p.nl();
                    w!(p, "}})");
                }
            }
        }

        Expr::Int(val) => {
            w!(p, "{}ULL", val);
        }

        Expr::Str(s) => {
            w!(p, "alloc_str(\"");
            for byte in s.bytes() {
                if byte == b'"' || byte == b'\\' || !(32..=126).contains(&byte) {
                    // Use octal escapes as hex escapes doesn't have a digit limit, e.g.
                    // `\xaaaaa...` will consider all those `a`s as digits.
                    w!(p, "\\{:03o}", byte);
                } else {
                    w!(p, "{}", byte as char);
                }
            }
            w!(p, "\", {})", s.len());
        }

        Expr::BoolAnd(left, right) => {
            w!(p, "({{");
            p.indent();
            p.nl();
            w!(p, "Bool* _and_result = ");
            expr_to_c(
                &left.node,
                &left.loc,
                Some(&mono::Type::bool()),
                locals,
                cg,
                p,
            );
            wln!(p, ";");
            w!(
                p,
                "if (_and_result == (Bool*){}) {{",
                heap_obj_singleton_name(cg.pgm, cg.pgm.true_con_idx)
            );
            p.indent();
            p.nl();
            w!(p, "_and_result = ");
            expr_to_c(
                &right.node,
                &right.loc,
                Some(&mono::Type::bool()),
                locals,
                cg,
                p,
            );
            w!(p, ";");
            p.dedent();
            p.nl();
            wln!(p, "}}");
            w!(p, "_and_result;");
            p.dedent();
            p.nl();
            w!(p, "}})");
        }

        Expr::BoolOr(left, right) => {
            w!(p, "({{");
            p.indent();
            p.nl();
            w!(p, "Bool* _or_result = ");
            expr_to_c(
                &left.node,
                &left.loc,
                Some(&mono::Type::bool()),
                locals,
                cg,
                p,
            );
            wln!(p, ";");
            w!(
                p,
                "if (_or_result == (Bool*){}) {{",
                heap_obj_singleton_name(cg.pgm, cg.pgm.false_con_idx)
            );
            p.indent();
            p.nl();
            w!(p, "_or_result = ");
            expr_to_c(
                &right.node,
                &right.loc,
                Some(&mono::Type::bool()),
                locals,
                cg,
                p,
            );
            w!(p, ";");
            p.dedent();
            p.nl();
            wln!(p, "}}");
            w!(p, "_or_result;");
            p.dedent();
            p.nl();
            w!(p, "}})");
        }

        Expr::Return(expr) => {
            w!(p, "({{");
            p.indent();
            p.nl();
            w!(p, "return ");
            expr_to_c(&expr.node, &expr.loc, expected_ty, locals, cg, p);
            wln!(p, ";");
            match expected_ty {
                Some(ty) if is_value_type(ty) => w!(p, "0;"),
                Some(ty) => w!(p, "({})NULL;", c_ty(ty)),
                None => {}
            }
            p.dedent();
            p.nl();
            w!(p, "}})");
        }

        Expr::Match(MatchExpr {
            scrut,
            alts,
            scrut_ty,
        }) => {
            w!(p, "({{");
            p.indent();
            p.nl();
            let scrut_temp = cg.fresh_temp();
            w!(p, "{} {} = ", c_ty(scrut_ty), scrut_temp);
            expr_to_c(&scrut.node, &scrut.loc, Some(scrut_ty), locals, cg, p);
            wln!(p, "; // {}", loc_display(&scrut.loc));

            let match_temp = cg.fresh_temp();
            let expected_ty: Option<(&str, &mono::Type)> = match expected_ty {
                Some(expected_ty) => {
                    wln!(
                        p,
                        "{} {match_temp}; // {}",
                        c_ty(expected_ty),
                        loc_display(loc)
                    );
                    Some((match_temp.as_ref(), expected_ty))
                }
                None => None,
            };

            for (i, alt) in alts.iter().enumerate() {
                if i > 0 {
                    w!(p, " else ");
                }
                // Generate pattern match condition
                let cond = pat_to_cond(&alt.pat.node, &scrut_temp, cg);
                w!(p, "if ({}", cond);

                // Add guard if present
                if let Some(guard) = &alt.guard {
                    w!(p, " && (");
                    expr_to_c(
                        &guard.node,
                        &guard.loc,
                        Some(&mono::Type::bool()),
                        locals,
                        cg,
                        p,
                    );
                    w!(
                        p,
                        " == (Bool*){})",
                        heap_obj_singleton_name(cg.pgm, cg.pgm.true_con_idx)
                    );
                }

                w!(p, ") {{");
                p.indent();
                p.nl();
                // Generate RHS
                stmts_to_c(&alt.rhs, expected_ty, locals, cg, p);
                p.dedent();
                p.nl();
                w!(p, "}}");
            }
            w!(p, " else {{");
            p.indent();
            p.nl();
            wln!(p, "fprintf(stderr, \"Non-exhaustive pattern match\\n\");");
            w!(p, "exit(1);");
            p.dedent();
            p.nl();
            wln!(p, "}}");

            if let Some((match_temp, _)) = expected_ty {
                w!(p, "{match_temp};");
            }

            p.dedent();
            p.nl();
            w!(p, "}})");
        }

        Expr::If(IfExpr {
            branches,
            else_branch,
            expr_ty,
        }) => {
            w!(p, "({{");
            p.indent();
            p.nl();

            let if_temp = if expr_ty.is_never() {
                None
            } else {
                let temp = cg.fresh_temp();
                wln!(p, "{} {temp}; // {}", c_ty(expr_ty), loc_display(loc));
                Some(temp)
            };

            for (i, (cond, body)) in branches.iter().enumerate() {
                if i > 0 {
                    w!(p, " else ");
                }
                let cond_temp = cg.fresh_temp();
                w!(p, "{{");
                p.indent();
                p.nl();
                w!(p, "Bool* {} = ", cond_temp);
                expr_to_c(
                    &cond.node,
                    &cond.loc,
                    Some(&mono::Type::bool()),
                    locals,
                    cg,
                    p,
                );
                wln!(p, ";");
                w!(
                    p,
                    "if ({} == (Bool*){}) {{",
                    cond_temp,
                    heap_obj_singleton_name(cg.pgm, cg.pgm.true_con_idx)
                );
                p.indent();
                p.nl();
                stmts_to_c(
                    body,
                    if_temp.as_ref().map(|if_temp| (if_temp.as_str(), expr_ty)),
                    locals,
                    cg,
                    p,
                );
                p.dedent();
                p.nl();
                w!(p, "}}");
            }

            match else_branch {
                Some(else_body) => {
                    w!(p, " else {{");
                    p.indent();
                    p.nl();
                    stmts_to_c(
                        else_body,
                        if_temp.as_ref().map(|if_temp| (if_temp.as_str(), expr_ty)),
                        locals,
                        cg,
                        p,
                    );
                    p.dedent();
                    p.nl();
                    w!(p, "}}");
                }
                None => {
                    p.nl();
                    if let Some(if_temp) = if_temp.as_ref() {
                        w!(
                            p,
                            "{if_temp} = {};",
                            heap_obj_singleton_name(cg.pgm, cg.pgm.unit_con_idx)
                        );
                    }
                }
            }

            // Close all the blocks we opened for conditions
            for _ in 0..branches.len() {
                p.dedent();
                p.nl();
                w!(p, " }}");
            }
            p.nl();
            if let Some(if_temp) = if_temp.as_ref() {
                w!(p, "{if_temp};");
            }
            p.dedent();
            p.nl();
            w!(p, "}})");
        }

        Expr::ClosureAlloc(closure_idx) => {
            let closure = &cg.pgm.closures[closure_idx.as_usize()];
            let idx = closure_idx.as_usize();
            w!(p, "({{");
            p.indent();
            p.nl();
            if closure.fvs.is_empty() {
                wln!(p, "CLOSURE* _clos = (CLOSURE*)malloc(sizeof(CLOSURE));");
                wln!(p, "_clos->tag = CLOSURE_TAG;");
                w!(p, "_clos->fun = (void(*)(void))_closure_{};", idx);
                p.nl();
            } else {
                wln!(
                    p,
                    "_Closure_{idx}* _clos = (_Closure_{idx}*)malloc(sizeof(_Closure_{idx}));"
                );
                wln!(p, "_clos->tag = CLOSURE_TAG;");
                w!(p, "_clos->fun = (void(*)(void))_closure_{};", idx);
                p.nl();
                for (i, fv) in closure.fvs.iter().enumerate() {
                    w!(
                        p,
                        "_clos->_{} = _{}; // {}",
                        i,
                        fv.alloc_idx.as_usize(),
                        fv.id
                    );
                    p.nl();
                }
            }
            w!(p, "(CLOSURE*)_clos;");
            p.dedent();
            p.nl();
            w!(p, "}})");
        }

        Expr::Is(IsExpr { expr, pat, expr_ty }) => {
            w!(p, "({{");
            p.indent();
            p.nl();
            let expr_temp = cg.fresh_temp();
            w!(p, "{} {} = ", c_ty(expr_ty), expr_temp);
            expr_to_c(&expr.node, &expr.loc, Some(expr_ty), locals, cg, p);
            wln!(p, "; // {}", loc_display(&expr.loc));
            wln!(p, "Bool* _is_result;");
            w!(p, "if ({}) {{", pat_to_cond(&pat.node, &expr_temp, cg));
            p.indent();
            p.nl();
            w!(
                p,
                "_is_result = (Bool*){};",
                heap_obj_singleton_name(cg.pgm, cg.pgm.true_con_idx)
            );
            p.dedent();
            p.nl();
            w!(p, "}} else {{");
            p.indent();
            p.nl();
            w!(
                p,
                "_is_result = (Bool*){};",
                heap_obj_singleton_name(cg.pgm, cg.pgm.false_con_idx)
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
            w!(p, "_is_result;");
            p.dedent();
            p.nl();
            w!(p, "}})");
        }

        Expr::Do(stmts, ty) => {
            w!(p, "({{");
            p.indent();
            p.nl();
            let expr_temp = cg.fresh_temp();
            wln!(p, "{} {expr_temp}; // {}", c_ty(ty), loc_display(loc));
            stmts_to_c(stmts, Some((&expr_temp, ty)), locals, cg, p);
            w!(p, "{expr_temp};");
            p.dedent();
            p.nl();
            w!(p, "}})");
        }

        Expr::Variant(expr) => {
            // Variants are represented as their underlying type
            expr_to_c(&expr.node, &expr.loc, None, locals, cg, p); // TODO: expected type
        }
    }
}

/// Generate a C condition expression for pattern matching.
fn pat_to_cond(pat: &Pat, scrutinee: &str, cg: &mut Cg) -> String {
    match pat {
        Pat::Ignore => "1".to_string(),

        Pat::Var(idx) => {
            format!("({{ _{} = {}; 1; }})", idx.as_usize(), scrutinee)
        }

        Pat::Con(ConPat { con, fields }) => {
            let struct_name = heap_obj_struct_name(cg.pgm, *con);
            let tag_name = heap_obj_tag_name(cg.pgm, *con);
            let mut cond = format!("(get_tag({}) == {})", scrutinee, tag_name);
            for (i, field_pat) in fields.iter().enumerate() {
                let field_expr = format!("(({struct_name}*){scrutinee})->_{i}");
                let field_cond = pat_to_cond(&field_pat.node, &field_expr, cg);
                cond = format!("({} && {})", cond, field_cond);
            }
            cond
        }

        Pat::Str(s) => {
            let mut escaped = String::new();
            for byte in s.bytes() {
                if byte == b'"' || byte == b'\\' || !(32..=126).contains(&byte) {
                    // Same as `Expr::Str`, use octal escape here instead of hex.
                    escaped.push_str(&format!("\\{:03o}", byte));
                } else {
                    escaped.push(byte as char);
                }
            }
            format!(
                "(get_tag({}) == {} && str_eq({}, \"{}\", {}))",
                scrutinee,
                cg.pgm.str_con_idx.0,
                scrutinee,
                escaped,
                s.len()
            )
        }

        Pat::Char(c) => {
            let tag_name = heap_obj_tag_name(cg.pgm, cg.pgm.char_con_idx);
            format!(
                "(get_tag({}) == {} && ((Char*){})->_0 == {})",
                scrutinee, tag_name, scrutinee, *c as u32
            )
        }

        Pat::Or(p1, p2) => {
            let c1 = pat_to_cond(&p1.node, scrutinee, cg);
            let c2 = pat_to_cond(&p2.node, scrutinee, cg);
            format!("({} || {})", c1, c2)
        }

        Pat::Variant(inner) => pat_to_cond(&inner.node, scrutinee, cg),
    }
}

fn generate_main_fn(pgm: &LoweredPgm, main: &str, p: &mut Printer) {
    let main_idx = pgm
        .funs
        .iter()
        .enumerate()
        .find_map(|(i, fun)| match &fun.body {
            FunBody::Source(_) if fun.name.node.as_str() == main => Some(i),
            _ => None,
        })
        .unwrap_or_else(|| panic!("Main function {main} is not defined"));

    p.nl();
    w!(p, "int main(int argc, char** argv) {{");
    p.indent();
    p.nl();
    wln!(p, "g_argc = argc;");
    wln!(p, "g_argv = argv;");
    wln!(p, "_fun_{}();", main_idx);
    w!(p, "return 0;");
    p.dedent();
    p.nl();
    wln!(p, "}}");
}

#[derive(Debug, Default)]
struct Printer {
    lines: Vec<String>,
    current_line: String,
    indent: u32,
}

impl Printer {
    fn nl(&mut self) {
        let line = std::mem::replace(&mut self.current_line, " ".repeat(self.indent as usize * 4));
        self.lines.push(line)
    }

    fn print(mut self) -> String {
        self.nl();
        let mut out = String::with_capacity(self.lines.iter().map(|l| l.len()).sum());
        for (i, line) in self.lines.iter().enumerate() {
            if i != 0 {
                out.push('\n');
            }
            out.push_str(line);
        }
        out
    }

    fn indent(&mut self) {
        self.indent += 1;
    }

    fn dedent(&mut self) {
        self.indent -= 1;
    }
}

impl Write for Printer {
    fn write_str(&mut self, s: &str) -> std::fmt::Result {
        self.current_line.push_str(s);
        Ok(())
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Top sort

/// Topologically sort user-defined types into SCCs.
///
/// - `type_objs`: Maps named types (both products and sums) to their heap object indices.
/// - `record_objs`: Same as `type_objs`, but for records.
fn top_sort(
    type_objs: &HashMap<Id, HashMap<Vec<mono::Type>, TypeObjs>>,
    record_objs: &HashMap<RecordType, HeapObjIdx>,
    heap_objs: &[HeapObj],
) -> Vec<HashSet<HeapObjIdx>> {
    let mut idx_gen = SccIdxGen::default();

    let mut output: Vec<HashSet<HeapObjIdx>> = Vec::with_capacity(heap_objs.len());

    // Because the object indices are consecutive numbers from 0 to number of objects, we can use an
    // array to map object indices to things.
    //
    // Assign the first indices to built-ins right away: they can't be analysed and they don't have
    // dependencies, and user-defined types can depend on them. So they need to come first. (I think
    // they may already come first in `heap_objs` so they'll get the first SCC indices, but we don't
    // have to rely on that, we can just give the the first indices here)
    let mut nodes: Box<[SccNode]> = heap_objs
        .iter()
        .enumerate()
        .map(|(heap_obj_idx, heap_obj)| SccNode {
            idx: match heap_obj {
                HeapObj::Builtin(_) => {
                    output.push(std::iter::once(HeapObjIdx(heap_obj_idx as u32)).collect());
                    Some(idx_gen.next())
                }
                HeapObj::Source(_) | HeapObj::Record(_) => None,
            },
            low_link: None,
            on_stack: false,
        })
        .collect();

    let mut stack: Vec<HeapObjIdx> = Vec::with_capacity(10);

    for (heap_obj_idx, _) in heap_objs.iter().enumerate() {
        if nodes[heap_obj_idx].idx.is_none() {
            _scc(
                type_objs,
                record_objs,
                heap_objs,
                HeapObjIdx(heap_obj_idx as u32),
                &mut idx_gen,
                &mut nodes,
                &mut stack,
                &mut output,
            );
        }
    }

    output
}

#[derive(Debug)]
struct SccNode {
    idx: Option<SccIdx>,
    low_link: Option<SccIdx>,
    on_stack: bool,
}

#[derive(Debug, Default)]
struct SccIdxGen {
    next: u32,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
struct SccIdx(u32);

impl SccIdxGen {
    fn next(&mut self) -> SccIdx {
        let next = self.next;
        self.next += 1;
        SccIdx(next)
    }
}

fn _scc(
    type_objs: &HashMap<Id, HashMap<Vec<mono::Type>, TypeObjs>>,
    record_objs: &HashMap<RecordType, HeapObjIdx>,
    heap_objs: &[HeapObj],
    heap_obj_idx: HeapObjIdx,
    idx_gen: &mut SccIdxGen,
    nodes: &mut [SccNode],
    stack: &mut Vec<HeapObjIdx>,
    output: &mut Vec<HashSet<HeapObjIdx>>,
) {
    let idx = idx_gen.next();

    nodes[heap_obj_idx.as_usize()].idx = Some(idx);
    nodes[heap_obj_idx.as_usize()].low_link = Some(idx);
    nodes[heap_obj_idx.as_usize()].on_stack = true;

    stack.push(heap_obj_idx);

    // Add dependencies to the output.
    let deps = heap_obj_deps(type_objs, record_objs, heap_objs, heap_obj_idx);
    for dep_obj in deps {
        if nodes[dep_obj.as_usize()].idx.is_none() {
            // Dependency not visited yet.
            _scc(
                type_objs,
                record_objs,
                heap_objs,
                dep_obj,
                idx_gen,
                nodes,
                stack,
                output,
            );
            let current_low_link = nodes[heap_obj_idx.as_usize()].low_link.unwrap();
            let dep_low_link = nodes[dep_obj.as_usize()].low_link.unwrap();
            nodes[heap_obj_idx.as_usize()].low_link = Some(current_low_link.min(dep_low_link));
        } else if nodes[dep_obj.as_usize()].on_stack {
            // Dependency is on stack, so in the current SCC.
            let current_low_link = nodes[heap_obj_idx.as_usize()].low_link.unwrap();
            let dep_idx = nodes[dep_obj.as_usize()].idx.unwrap();
            nodes[heap_obj_idx.as_usize()].low_link = Some(current_low_link.min(dep_idx));
        }
    }

    // If current node is  aroot node, pop the stack and generate an SCC.
    if nodes[heap_obj_idx.as_usize()].low_link == nodes[heap_obj_idx.as_usize()].idx {
        let mut scc: HashSet<HeapObjIdx> = Default::default();
        loop {
            let dep = stack.pop().unwrap();
            nodes[dep.as_usize()].on_stack = false;
            scc.insert(dep);
            if dep == heap_obj_idx {
                break;
            }
        }

        output.push(scc);
    }
}

fn heap_obj_deps(
    type_objs: &HashMap<Id, HashMap<Vec<mono::Type>, TypeObjs>>,
    record_objs: &HashMap<RecordType, HeapObjIdx>,
    heap_objs: &[HeapObj],
    heap_obj_idx: HeapObjIdx,
) -> HashSet<HeapObjIdx> {
    let mut deps: HashSet<HeapObjIdx> = Default::default();

    match &heap_objs[heap_obj_idx.as_usize()] {
        HeapObj::Builtin(_) => {}

        HeapObj::Source(source_decl) => {
            for field in source_decl.fields.iter() {
                type_heap_obj_deps(type_objs, record_objs, field, &mut deps);
            }
        }

        HeapObj::Record(record_type) => {
            for field in record_type.fields.values() {
                type_heap_obj_deps(type_objs, record_objs, field, &mut deps);
            }
        }
    }

    deps
}

fn type_heap_obj_deps(
    type_objs: &HashMap<Id, HashMap<Vec<mono::Type>, TypeObjs>>,
    record_objs: &HashMap<RecordType, HeapObjIdx>,
    ty: &mono::Type,
    deps: &mut HashSet<HeapObjIdx>,
) {
    match ty {
        mono::Type::Named(ty) => {
            named_type_heap_obj_deps(type_objs, ty, deps);
        }

        mono::Type::Record { fields } => {
            let record_idx = record_objs
                .get(&RecordType {
                    fields: fields.clone(),
                })
                .unwrap();
            deps.insert(*record_idx);
            for ty in fields.values() {
                type_heap_obj_deps(type_objs, record_objs, ty, deps);
            }
        }

        mono::Type::Variant { alts } => {
            for ty in alts.values() {
                named_type_heap_obj_deps(type_objs, ty, deps);
            }
        }

        mono::Type::Fn(mono::FnType { args, ret, exn }) => {
            match args {
                mono::FunArgs::Positional(args) => {
                    for arg in args {
                        type_heap_obj_deps(type_objs, record_objs, arg, deps);
                    }
                }
                mono::FunArgs::Named(args) => {
                    for arg in args.values() {
                        type_heap_obj_deps(type_objs, record_objs, arg, deps);
                    }
                }
            }

            type_heap_obj_deps(type_objs, record_objs, ret, deps);
            type_heap_obj_deps(type_objs, record_objs, exn, deps);
        }

        mono::Type::Never => {}
    }
}

fn named_type_heap_obj_deps(
    type_objs: &HashMap<Id, HashMap<Vec<mono::Type>, TypeObjs>>,
    ty: &mono::NamedType,
    deps: &mut HashSet<HeapObjIdx>,
) {
    let ty_map = match type_objs.get(&ty.name) {
        Some(ty_map) => ty_map,
        None => return, // builtin
    };

    match ty_map.get(&ty.args).unwrap() {
        TypeObjs::Product(idx) => {
            deps.insert(*idx);
        }
        TypeObjs::Sum(idxs) => deps.extend(idxs.iter().cloned()),
    }
}
