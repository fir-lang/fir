/*
TODOs:

- Consider creating a `struct` for every constructor, to make debugging in gdb easier.

- Make sure signed integers wrap on overflow and underflow in a defined way. Update the interpreter
  to do the same. Add tests. (`__builtin_add_overflow` etc.)

  In the future we'll probably trap by default and require explicitly allowing overflowing.
  (`checkedAdd`, `uncheckedAdd` etc.)
*/

/*
This module compiles lowered syntax to C.

## Heap objects

All heap objects are allocated with `malloc`. First word of every allocation is a 64-bit tag.

For now, fields are all `uint64_t`s, same as the interpreter.

For now we don't reclaim memory: all allocations leak.

In the future: we may try Boehm or some other conservative GC.

## Stack values

For now, arguments and locals are all `uint64_t`, same as the interpreter.

## Types

Product types (including records) will be compiled to C structs.

Sum types: every constructor will have its own struct and structs, with different fields and sizes.

For now: all constructors (not just types!) have unique tags. This is to allow a simple variant
implementation where value-to-variant conversions are no-op. In the future: variants will be stack
allocated, value-to-variant conversion will just add a tag word.

## Functions and constructors

Every function and constructor will be compiled to two C definitions:

- An actual C function that runs the function and constructor.

- A static object (with same layout as heap allocations) for the closures of the constructor or
  function.

## Closures

Every closure in the program will have its own unique type, similar to types.

## Exprs

Block expressions like `match` and `if` will be compiled with a destination variable, for the value
generated by the `match`/`if`/etc.

- `LocalVar`: C variable.

- `Fun`: reference to the top-level closure of the function.

- `Con`: same as `Fun`.

- `ConAlloc`: allocate the heap object with `malloc` + initialize fields.

- `FieldSel`: evaluate object, then `object->field`.

- `Call`: special case `Fun` calls to call the function directly. For others: the function will
  evaluate to a closure. Call the closure entry.

- `Int`: compile to a C integer.

- `Str`: allocate an array for the UTF-8 encoding, then allocate `Str(array)`.

- `BoolAnd`:
  ```
  ({
    bool b = <evaluate left>;
    if (b) {
      b = <evaluate right>;
    }
    b
  })
  ```

- `BoolOr`: similar to `BoolAnd`.

- `Return`: C `return`.

- `Match`: compile each branch as `if <scrutinee> is <pattern> { <body> }`.
  Chain all branches with `else if`.

  Branch return values will need to be written to the "destination" variable.

- `If`: similar.

- `ClosureAlloc`: allocate closure.

- `Is`: see pattern matching below.

- `Do`: We may be able to use statement expressions:
   https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html.

   Or create and pass destination.

- Variant: Compile as-is. Variant expressions need to be boxed, and all boxed objects have a tag.

  In the future: variants will be stack allocated, and value-to-variant conversion will just add a
  tag word.

## Prims

- `try`: `setjmp`
- `throw`: `longjmp`

When a Fir expression is in C expression context: compile it directly.
In C statement context: wrap the generated code with `({ ... })`.
Reference: https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html
*/

use crate::ast::Id;
use crate::collections::*;
use crate::lowering::*;
use crate::mono_ast as mono;
use crate::utils::loc_display;

use indoc::writedoc;

use std::fmt::Write;

macro_rules! w {
    ($($arg:tt)*) => {
        ::core::write!($($arg)*).unwrap()
    };
}

macro_rules! wln {
    ($p:expr, $($arg:tt)*) => {{
        ::core::write!($p, $($arg)*).unwrap();
        $p.nl();
    }};
}

/// Code generation context.
struct Cg<'a> {
    pgm: &'a LoweredPgm,

    /// Counter for generating fresh temporary variables.
    temp_counter: u32,
}

impl<'a> Cg<'a> {
    fn fresh_temp(&mut self) -> String {
        let n = self.temp_counter;
        self.temp_counter += 1;
        format!("_t{}", n)
    }
}

pub(crate) fn to_c(pgm: &LoweredPgm, main: &str) -> String {
    let mut p = Printer::default();

    // Header includes and runtime definitions
    let _ = writedoc!(
        p,
        "
        #include <inttypes.h>
        #include <setjmp.h>
        #include <stdbool.h>
        #include <stdint.h>
        #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>

        // Tags for builtin heap objects
        #define CON_TAG 0
        #define FUN_TAG 1
        #define CLOSURE_TAG 2
        #define ARRAY_TAG 3

        // Array header layout (matches interpreter):
        // word 0: tag
        // word 1: data pointer (scaled by element size for direct indexing)
        // word 2: length (in elements)
        // Data is allocated separately so slices can share underlying storage.
        #define ARRAY_TAG_IDX 0
        #define ARRAY_DATA_PTR_IDX 1
        #define ARRAY_LEN_IDX 2

        // Exception handling using setjmp/longjmp
        typedef struct ExnHandler {{
            jmp_buf buf;
            struct ExnHandler* prev;
            uint64_t exn_value;
        }} ExnHandler;

        static ExnHandler* current_exn_handler = NULL;

        static void throw_exn(uint64_t exn) {{
            if (current_exn_handler == NULL) {{
                fprintf(stderr, \"Uncaught exception\\n\");
                exit(1);
            }}
            current_exn_handler->exn_value = exn;
            longjmp(current_exn_handler->buf, 1);
        }}

        static uint64_t* alloc_words(size_t n) {{
            return (uint64_t*)malloc(n * sizeof(uint64_t));
        }}

        static uint32_t get_tag(uint64_t obj) {{
            return (uint32_t)*(uint64_t*)obj;
        }}

        // Array allocation and access functions.
        // For the C backend, we store actual byte pointers in ARRAY_DATA_PTR_IDX.
        // This differs from the interpreter which uses scaled indices into a single heap.
        // Slicing creates a new header pointing to the same underlying data.

        static uint64_t array_new_u8(uint32_t len) {{
            size_t data_words = (len + 7) / 8;
            uint64_t* arr = alloc_words(3 + data_words);
            arr[ARRAY_TAG_IDX] = ARRAY_TAG;
            arr[ARRAY_DATA_PTR_IDX] = (uint64_t)(arr + 3);
            arr[ARRAY_LEN_IDX] = len;
            memset(arr + 3, 0, data_words * 8);
            return (uint64_t)arr;
        }}

        static uint64_t array_get_u8(uint64_t arr, uint32_t idx) {{
            uint8_t* data = (uint8_t*)((uint64_t*)arr)[ARRAY_DATA_PTR_IDX];
            return (uint64_t)data[idx];
        }}

        static void array_set_u8(uint64_t arr, uint32_t idx, uint64_t val) {{
            uint8_t* data = (uint8_t*)((uint64_t*)arr)[ARRAY_DATA_PTR_IDX];
            data[idx] = (uint8_t)val;
        }}

        static uint64_t array_slice_u8(uint64_t arr, uint32_t start, uint32_t end) {{
            uint64_t* new_arr = alloc_words(3);
            new_arr[ARRAY_TAG_IDX] = ARRAY_TAG;
            uint8_t* data = (uint8_t*)((uint64_t*)arr)[ARRAY_DATA_PTR_IDX];
            new_arr[ARRAY_DATA_PTR_IDX] = (uint64_t)(data + start);
            new_arr[ARRAY_LEN_IDX] = end - start;
            return (uint64_t)new_arr;
        }}

        static void array_copy_within_u8(uint64_t arr, uint32_t src, uint32_t dst, uint32_t len) {{
            uint8_t* data = (uint8_t*)((uint64_t*)arr)[ARRAY_DATA_PTR_IDX];
            memmove(data + dst, data + src, len);
        }}

        static uint64_t array_new_u32(uint32_t len) {{
            size_t data_words = (len + 1) / 2;
            uint64_t* arr = alloc_words(3 + data_words);
            arr[ARRAY_TAG_IDX] = ARRAY_TAG;
            arr[ARRAY_DATA_PTR_IDX] = (uint64_t)(arr + 3);
            arr[ARRAY_LEN_IDX] = len;
            memset(arr + 3, 0, data_words * 8);
            return (uint64_t)arr;
        }}

        static uint64_t array_get_u32(uint64_t arr, uint32_t idx) {{
            uint32_t* data = (uint32_t*)((uint64_t*)arr)[ARRAY_DATA_PTR_IDX];
            return (uint64_t)data[idx];
        }}

        static void array_set_u32(uint64_t arr, uint32_t idx, uint64_t val) {{
            uint32_t* data = (uint32_t*)((uint64_t*)arr)[ARRAY_DATA_PTR_IDX];
            data[idx] = (uint32_t)val;
        }}

        static uint64_t array_slice_u32(uint64_t arr, uint32_t start, uint32_t end) {{
            uint64_t* new_arr = alloc_words(3);
            new_arr[ARRAY_TAG_IDX] = ARRAY_TAG;
            uint32_t* data = (uint32_t*)((uint64_t*)arr)[ARRAY_DATA_PTR_IDX];
            new_arr[ARRAY_DATA_PTR_IDX] = (uint64_t)(data + start);
            new_arr[ARRAY_LEN_IDX] = end - start;
            return (uint64_t)new_arr;
        }}

        static void array_copy_within_u32(uint64_t arr, uint32_t src, uint32_t dst, uint32_t len) {{
            uint32_t* data = (uint32_t*)((uint64_t*)arr)[ARRAY_DATA_PTR_IDX];
            memmove(data + dst, data + src, len * sizeof(uint32_t));
        }}

        static uint64_t array_new_u64(uint32_t len) {{
            uint64_t* arr = alloc_words(3 + len);
            arr[ARRAY_TAG_IDX] = ARRAY_TAG;
            arr[ARRAY_DATA_PTR_IDX] = (uint64_t)(arr + 3);
            arr[ARRAY_LEN_IDX] = len;
            memset(arr + 3, 0, len * 8);
            return (uint64_t)arr;
        }}

        static uint64_t array_get_u64(uint64_t arr, uint32_t idx) {{
            uint64_t* data = (uint64_t*)((uint64_t*)arr)[ARRAY_DATA_PTR_IDX];
            return data[idx];
        }}

        static void array_set_u64(uint64_t arr, uint32_t idx, uint64_t val) {{
            uint64_t* data = (uint64_t*)((uint64_t*)arr)[ARRAY_DATA_PTR_IDX];
            data[idx] = val;
        }}

        static uint64_t array_slice_u64(uint64_t arr, uint32_t start, uint32_t end) {{
            uint64_t* new_arr = alloc_words(3);
            new_arr[ARRAY_TAG_IDX] = ARRAY_TAG;
            uint64_t* data = (uint64_t*)((uint64_t*)arr)[ARRAY_DATA_PTR_IDX];
            new_arr[ARRAY_DATA_PTR_IDX] = (uint64_t)(data + start);
            new_arr[ARRAY_LEN_IDX] = end - start;
            return (uint64_t)new_arr;
        }}

        static void array_copy_within_u64(uint64_t arr, uint32_t src, uint32_t dst, uint32_t len) {{
            uint64_t* data = (uint64_t*)((uint64_t*)arr)[ARRAY_DATA_PTR_IDX];
            memmove(data + dst, data + src, len * sizeof(uint64_t));
        }}

        static uint32_t array_len(uint64_t arr) {{
            return (uint32_t)((uint64_t*)arr)[ARRAY_LEN_IDX];
        }}

        // String comparison for pattern matching
        static bool str_eq(uint64_t str1, const char* str2, size_t len2) {{
            uint64_t* s1 = (uint64_t*)str1;
            uint64_t bytes_arr = s1[1]; // _bytes field
            uint32_t len1 = array_len(bytes_arr);
            if (len1 != len2) return false;
            uint8_t* data = (uint8_t*)((uint64_t*)bytes_arr)[ARRAY_DATA_PTR_IDX];
            return memcmp(data, str2, len1) == 0;
        }}

        // Allocate string from bytes
        static uint64_t alloc_str(uint64_t str_tag, const char* bytes, size_t len) {{
            uint64_t arr = array_new_u8(len);
            uint8_t* data = (uint8_t*)((uint64_t*)arr)[ARRAY_DATA_PTR_IDX];
            memcpy(data, bytes, len);

            uint64_t* str = alloc_words(2);
            str[0] = str_tag;
            str[1] = arr;
            return (uint64_t)str;
        }}

        // Globals for CLI args
        static int g_argc;
        static char** g_argv;

        "
    );
    p.nl();

    for (i, fun) in pgm.funs.iter().enumerate() {
        forward_declare_fun(pgm, fun, i, &mut p);
    }
    p.nl();

    for (i, closure) in pgm.closures.iter().enumerate() {
        forward_declare_closure(pgm, closure, i, &mut p);
    }
    p.nl();

    let heap_objs_sorted = top_sort(&pgm.type_objs, &pgm.heap_objs);
    for heap_obj_idx in heap_objs_sorted.iter().flatten() {
        heap_obj_to_c(
            &pgm.heap_objs[heap_obj_idx.as_usize()],
            heap_obj_idx.0,
            &mut p,
        );
        p.nl();
    }

    p.nl();
    w!(
        p,
        "// Statically allocated singletons for nullary constructors"
    );
    p.nl();
    for (tag, heap_obj) in pgm.heap_objs.iter().enumerate() {
        match heap_obj {
            HeapObj::Source(source_con) if source_con.fields.is_empty() => {
                let singleton_name = source_con_singleton_name(source_con);
                let tag_name = source_con_tag_name(source_con);
                w!(
                    p,
                    "static uint64_t {}_data[] = {{ {} }};",
                    singleton_name,
                    tag_name
                );
                p.nl();
                w!(
                    p,
                    "#define {} ((uint64_t){}_data)",
                    singleton_name,
                    singleton_name
                );
                p.nl();
            }
            HeapObj::Record(record) if record.fields.is_empty() => {
                w!(
                    p,
                    "static uint64_t _singleton_record_{}_data[] = {{ {} }};",
                    tag,
                    tag
                );
                p.nl();
                w!(
                    p,
                    "#define _singleton_record_{} ((uint64_t)_singleton_record_{}_data)",
                    tag,
                    tag
                );
                p.nl();
            }
            _ => {}
        }
    }
    p.nl();

    w!(
        p,
        "// Statically allocated closure objects for constructors"
    );
    p.nl();
    for (tag, heap_obj) in pgm.heap_objs.iter().enumerate() {
        match heap_obj {
            HeapObj::Source(source_con) if !source_con.fields.is_empty() => {
                let tag_name = source_con_tag_name(source_con);
                w!(
                    p,
                    "static uint64_t _con_closure_{}_data[] = {{ CON_CON_TAG, {} }};",
                    tag,
                    tag_name
                );
                p.nl();
                w!(
                    p,
                    "#define _con_closure_{} ((uint64_t)_con_closure_{}_data)",
                    tag,
                    tag
                );
                p.nl();
            }
            _ => {}
        }
    }
    p.nl();

    w!(
        p,
        "// Statically allocated closure objects for top-level functions"
    );
    p.nl();
    for i in 0..pgm.funs.len() {
        w!(
            p,
            "static uint64_t _fun_closure_{}_data[] = {{ FUN_CON_TAG, (uint64_t)_fun_{} }};",
            i,
            i
        );
        p.nl();
        w!(
            p,
            "#define _fun_closure_{} ((uint64_t)_fun_closure_{}_data)",
            i,
            i
        );
        p.nl();
    }
    p.nl();

    let mut cg = Cg {
        pgm,
        temp_counter: 0,
    };

    // Generate built-in functions first. Built-in functions don't depend on each other or source
    // functions, but source functions can depend on built-in functions.
    for (i, fun) in pgm.funs.iter().enumerate() {
        if let Fun::Builtin(builtin) = fun {
            builtin_fun_to_c(builtin, i, pgm, &mut p);
            p.nl();
        }
    }

    // Generate source functions after built-in functions as they may depend on built-in functions
    // and built-in functions are not forward-declared.
    for (i, fun) in pgm.funs.iter().enumerate() {
        if let Fun::Source(source) = fun {
            source_fun_to_c(source, i, &mut cg, &mut p);
            p.nl();
        }
    }

    for (i, closure) in pgm.closures.iter().enumerate() {
        closure_to_c(closure, i, &mut cg, &mut p);
        p.nl();
    }

    generate_main_fn(pgm, main, &mut p);

    p.print()
}

fn forward_declare_fun(_pgm: &LoweredPgm, fun: &Fun, idx: usize, p: &mut Printer) {
    let param_count = match fun {
        Fun::Builtin(builtin) => builtin_fun_param_count(builtin),
        Fun::Source(source) => source.params.len(),
    };

    w!(p, "static uint64_t _fun_{}(", idx);
    if param_count == 0 {
        w!(p, "void");
    } else {
        for i in 0..param_count {
            if i > 0 {
                w!(p, ", ");
            }
            w!(p, "uint64_t _p{}", i);
        }
    }
    wln!(p, ");");
}

/// Returns the number of parameters for a built-in function.
fn builtin_fun_param_count(fun: &BuiltinFunDecl) -> usize {
    match fun {
        BuiltinFunDecl::Panic => 1,
        BuiltinFunDecl::PrintStrNoNl => 1,
        BuiltinFunDecl::ShrI8
        | BuiltinFunDecl::ShrU8
        | BuiltinFunDecl::ShrI32
        | BuiltinFunDecl::ShrU32
        | BuiltinFunDecl::BitAndI8
        | BuiltinFunDecl::BitAndU8
        | BuiltinFunDecl::BitAndI32
        | BuiltinFunDecl::BitAndU32
        | BuiltinFunDecl::BitOrI8
        | BuiltinFunDecl::BitOrU8
        | BuiltinFunDecl::BitOrI32
        | BuiltinFunDecl::BitOrU32
        | BuiltinFunDecl::BitXorU32 => 2,
        BuiltinFunDecl::ToStrI8
        | BuiltinFunDecl::ToStrU8
        | BuiltinFunDecl::ToStrI32
        | BuiltinFunDecl::ToStrU32
        | BuiltinFunDecl::ToStrU64
        | BuiltinFunDecl::ToStrI64 => 1,
        BuiltinFunDecl::U8AsI8
        | BuiltinFunDecl::U8AsU32
        | BuiltinFunDecl::U32AsU8
        | BuiltinFunDecl::U32AsI32
        | BuiltinFunDecl::U32AsU64 => 1,
        BuiltinFunDecl::I8Shl
        | BuiltinFunDecl::U8Shl
        | BuiltinFunDecl::I32Shl
        | BuiltinFunDecl::U32Shl => 2,
        BuiltinFunDecl::I8Cmp
        | BuiltinFunDecl::U8Cmp
        | BuiltinFunDecl::I32Cmp
        | BuiltinFunDecl::U32Cmp
        | BuiltinFunDecl::U64Cmp => 2,
        BuiltinFunDecl::I8Add
        | BuiltinFunDecl::U8Add
        | BuiltinFunDecl::I32Add
        | BuiltinFunDecl::U32Add
        | BuiltinFunDecl::U64Add => 2,
        BuiltinFunDecl::I8Sub
        | BuiltinFunDecl::U8Sub
        | BuiltinFunDecl::I32Sub
        | BuiltinFunDecl::U32Sub => 2,
        BuiltinFunDecl::I8Mul
        | BuiltinFunDecl::U8Mul
        | BuiltinFunDecl::I32Mul
        | BuiltinFunDecl::U32Mul
        | BuiltinFunDecl::U64Mul => 2,
        BuiltinFunDecl::I8Div
        | BuiltinFunDecl::U8Div
        | BuiltinFunDecl::I32Div
        | BuiltinFunDecl::U32Div => 2,
        BuiltinFunDecl::I8Eq
        | BuiltinFunDecl::U8Eq
        | BuiltinFunDecl::I32Eq
        | BuiltinFunDecl::U32Eq => 2,
        BuiltinFunDecl::U32Mod => 2,
        BuiltinFunDecl::I8Rem
        | BuiltinFunDecl::U8Rem
        | BuiltinFunDecl::I32Rem
        | BuiltinFunDecl::U32Rem => 2,
        BuiltinFunDecl::I32AsU32 | BuiltinFunDecl::I32Abs => 1,
        BuiltinFunDecl::I8Neg | BuiltinFunDecl::I32Neg => 1,
        BuiltinFunDecl::ThrowUnchecked => 1,
        BuiltinFunDecl::Try { .. } => 1,
        BuiltinFunDecl::ArrayNew { .. } => 1,
        BuiltinFunDecl::ArrayLen => 1,
        BuiltinFunDecl::ArrayGet { .. } => 2,
        BuiltinFunDecl::ArraySet { .. } => 3,
        BuiltinFunDecl::ArraySlice { .. } => 3,
        BuiltinFunDecl::ArrayCopyWithin { .. } => 4,
        BuiltinFunDecl::ReadFileUtf8 => 1,
        BuiltinFunDecl::GetArgs => 0,
    }
}

fn forward_declare_closure(_pgm: &LoweredPgm, closure: &Closure, idx: usize, p: &mut Printer) {
    w!(p, "static uint64_t _closure_{}(uint64_t _closure_obj", idx);
    for (i, _) in closure.params.iter().enumerate() {
        w!(p, ", uint64_t _p{}", i);
    }
    wln!(p, ");");
}

fn heap_obj_to_c(heap_obj: &HeapObj, tag: u32, p: &mut Printer) {
    match heap_obj {
        HeapObj::Builtin(builtin) => builtin_con_decl_to_c(builtin, tag, p),
        HeapObj::Source(source_con) => source_con_decl_to_c(source_con, tag, p),
        HeapObj::Record(record) => record_decl_to_c(record, tag, p),
    }
}

fn builtin_con_decl_to_c(builtin: &BuiltinConDecl, tag: u32, p: &mut Printer) {
    match builtin {
        BuiltinConDecl::Con => {
            wln!(p, "#define CON_CON_TAG {}", tag);
        }

        BuiltinConDecl::Fun => {
            wln!(p, "#define FUN_CON_TAG {}", tag);
        }

        BuiltinConDecl::Closure => {
            wln!(p, "#define CLOSURE_CON_TAG {}", tag);
        }

        BuiltinConDecl::Array => {
            // ARRAY_TAG is defined in the header
        }

        BuiltinConDecl::I8 => {
            wln!(p, "// I8 tag {}", tag);
        }

        BuiltinConDecl::U8 => {
            wln!(p, "// U8 tag {}", tag);
        }

        BuiltinConDecl::I32 => {
            wln!(p, "// I32 tag {}", tag);
        }

        BuiltinConDecl::U32 => {
            wln!(p, "// U32 tag {}", tag);
        }

        BuiltinConDecl::I64 => {
            wln!(p, "// I64 tag {}", tag);
        }

        BuiltinConDecl::U64 => {
            wln!(p, "// U64 tag {}", tag);
        }
    }
}

/// Generate a symbolic tag name for a source constructor.
fn source_con_tag_name(source_con: &SourceConDecl) -> String {
    let mut tag_name = String::from("TAG_");
    tag_name.push_str(&source_con.name);
    for ty_arg in &source_con.ty_args {
        tag_name.push('_');
        ty_to_c(ty_arg, &mut tag_name);
    }
    tag_name
}

/// Get the symbolic tag name for a heap object.
/// Returns the symbolic name for source constructors, or the numeric tag for builtins/records.
fn heap_obj_tag_name(pgm: &LoweredPgm, idx: HeapObjIdx) -> String {
    match &pgm.heap_objs[idx.0 as usize] {
        HeapObj::Source(source_con) => source_con_tag_name(source_con),
        HeapObj::Builtin(_) | HeapObj::Record(_) => format!("{}", idx.0),
    }
}

/// Generate singleton variable name for a nullary source constructor.
fn source_con_singleton_name(source_con: &SourceConDecl) -> String {
    let mut name = String::from("_singleton_");
    name.push_str(&source_con.name);
    for ty_arg in &source_con.ty_args {
        name.push('_');
        ty_to_c(ty_arg, &mut name);
    }
    name
}

/// Get the singleton variable name for a heap object (nullary constructors only).
fn heap_obj_singleton_name(pgm: &LoweredPgm, idx: HeapObjIdx) -> String {
    match &pgm.heap_objs[idx.0 as usize] {
        HeapObj::Source(source_con) => source_con_singleton_name(source_con),
        HeapObj::Record(_) => format!("_singleton_record_{}", idx.0),
        HeapObj::Builtin(_) => panic!("Builtin heap objects don't have singletons"),
    }
}

fn source_con_decl_to_c(source_con: &SourceConDecl, tag: u32, p: &mut Printer) {
    let SourceConDecl {
        name: _,
        idx,
        ty_args: _,
        fields,
    } = source_con;

    assert_eq!(idx.0, tag);

    let tag_name = source_con_tag_name(source_con);

    w!(p, "#define {} {}", tag_name, tag);
    if !fields.is_empty() {
        w!(p, " // {} field(s)", fields.len());
    }
    p.nl();
}

fn record_decl_to_c(record: &RecordType, tag: u32, p: &mut Printer) {
    w!(p, "// tag {}: Record", tag);
    if !record.fields.is_empty() {
        w!(p, " ({} field(s))", record.fields.len());
    }
    p.nl();
}

fn named_ty_to_c(named_ty: &mono::NamedType, out: &mut String) {
    out.push_str(&named_ty.name);
    for arg in &named_ty.args {
        out.push('_');
        ty_to_c(arg, out);
    }
}

fn ty_to_c(ty: &mono::Type, out: &mut String) {
    match ty {
        mono::Type::Named(named_ty) => {
            named_ty_to_c(named_ty, out);
        }

        mono::Type::Record { fields } => {
            out.push_str("Record");
            for (field_name, field_ty) in fields {
                w!(out, "_{}_", field_name);
                ty_to_c(field_ty, out);
            }
        }

        mono::Type::Variant { alts } => {
            out.push_str("Variant");
            for alt in alts.values() {
                out.push('_');
                named_ty_to_c(alt, out);
            }
        }

        mono::Type::Fn(mono::FnType { args, ret, exn }) => {
            out.push_str("Fn");
            match args {
                mono::FunArgs::Positional(positional_args) => {
                    for arg in positional_args {
                        out.push('_');
                        ty_to_c(arg, out);
                    }
                }
                mono::FunArgs::Named(named_args) => {
                    for (name, arg) in named_args {
                        out.push('_');
                        out.push_str(name);
                        out.push('_');
                        ty_to_c(arg, out);
                    }
                }
            }
            out.push('_');
            ty_to_c(ret, out);
            out.push('_');
            ty_to_c(exn, out);
        }

        mono::Type::Never => {
            out.push_str("Never");
        }
    }
}

fn builtin_fun_to_c(fun: &BuiltinFunDecl, idx: usize, pgm: &LoweredPgm, p: &mut Printer) {
    // Debug output of `fun` is too noisy, but it's better than not knowing what the generated
    // functions are for.
    wln!(p, "// {:?}", fun);
    match fun {
        BuiltinFunDecl::Panic => {
            w!(p, "static uint64_t _fun_{}(uint64_t msg) {{", idx);
            p.indent();
            p.nl();
            wln!(p, "uint64_t* str = (uint64_t*)msg;");
            wln!(p, "uint64_t bytes_arr = str[1];");
            wln!(p, "uint32_t len = array_len(bytes_arr);");
            w!(
                p,
                "uint8_t* data = (uint8_t*)((uint64_t*)bytes_arr)[ARRAY_DATA_PTR_IDX];"
            );
            p.nl();
            wln!(p, "fprintf(stderr, \"PANIC: \");");
            wln!(p, "fwrite(data, 1, len, stderr);");
            wln!(p, "fprintf(stderr, \"\\n\");");
            w!(p, "exit(1);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::PrintStrNoNl => {
            w!(p, "static uint64_t _fun_{}(uint64_t str) {{", idx);
            p.indent();
            p.nl();
            wln!(p, "uint64_t* s = (uint64_t*)str;");
            wln!(p, "uint64_t bytes_arr = s[1];");
            wln!(p, "uint32_t len = array_len(bytes_arr);");
            w!(
                p,
                "uint8_t* data = (uint8_t*)((uint64_t*)bytes_arr)[ARRAY_DATA_PTR_IDX];"
            );
            p.nl();
            wln!(p, "fwrite(data, 1, len, stdout);");
            w!(
                p,
                "return {};",
                heap_obj_singleton_name(pgm, pgm.unit_con_idx)
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::ShrI8 => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(
                p,
                "return (uint64_t)(uint8_t)((int8_t)(uint8_t)a >> (int8_t)(uint8_t)b);"
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::ShrU8 => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)((uint8_t)a >> (uint8_t)b);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::ShrI32 => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(
                p,
                "return (uint64_t)(uint32_t)((int32_t)(uint32_t)a >> (int32_t)(uint32_t)b);"
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::ShrU32 => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)((uint32_t)a >> (uint32_t)b);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::BitAndI8 | BuiltinFunDecl::BitAndU8 => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)((uint8_t)a & (uint8_t)b);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::BitAndI32 | BuiltinFunDecl::BitAndU32 => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)((uint32_t)a & (uint32_t)b);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::BitOrI8 | BuiltinFunDecl::BitOrU8 => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)((uint8_t)a | (uint8_t)b);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::BitOrI32 | BuiltinFunDecl::BitOrU32 => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)((uint32_t)a | (uint32_t)b);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::BitXorU32 => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)((uint32_t)a ^ (uint32_t)b);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::ToStrI8 => {
            gen_tostr_fn(idx, "int8_t", "(int8_t)(uint8_t)", "PRId8", pgm, p);
        }

        BuiltinFunDecl::ToStrU8 => {
            gen_tostr_fn(idx, "uint8_t", "(uint8_t)", "PRIu8", pgm, p);
        }

        BuiltinFunDecl::ToStrI32 => {
            gen_tostr_fn(idx, "int32_t", "(int32_t)(uint32_t)", "PRId32", pgm, p);
        }

        BuiltinFunDecl::ToStrU32 => {
            gen_tostr_fn(idx, "uint32_t", "(uint32_t)", "PRIu32", pgm, p);
        }

        BuiltinFunDecl::ToStrU64 => {
            gen_tostr_fn(idx, "uint64_t", "", "PRIu64", pgm, p);
        }

        BuiltinFunDecl::ToStrI64 => {
            gen_tostr_fn(idx, "int64_t", "(int64_t)", "PRId64", pgm, p);
        }

        BuiltinFunDecl::U8AsI8 => {
            w!(p, "static uint64_t _fun_{}(uint64_t a) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)(uint8_t)(int8_t)(uint8_t)a;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U8AsU32 => {
            w!(p, "static uint64_t _fun_{}(uint64_t a) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)(uint32_t)(uint8_t)a;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U32AsU8 => {
            w!(p, "static uint64_t _fun_{}(uint64_t a) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)(uint8_t)(uint32_t)a;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U32AsI32 => {
            w!(p, "static uint64_t _fun_{}(uint64_t a) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)(uint32_t)(int32_t)(uint32_t)a;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U32AsU64 => {
            w!(p, "static uint64_t _fun_{}(uint64_t a) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)(uint32_t)a;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I8Shl => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(
                p,
                "return (uint64_t)(uint8_t)((int8_t)(uint8_t)a << (int8_t)(uint8_t)b);"
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U8Shl => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)((uint8_t)a << (uint8_t)b);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I32Shl => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(
                p,
                "return (uint64_t)(uint32_t)((int32_t)(uint32_t)a << (int32_t)(uint32_t)b);"
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U32Shl => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)((uint32_t)a << (uint32_t)b);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I8Cmp => gen_cmp_fn(idx, "(int8_t)(uint8_t)", pgm, p),
        BuiltinFunDecl::U8Cmp => gen_cmp_fn(idx, "(uint8_t)", pgm, p),
        BuiltinFunDecl::I32Cmp => gen_cmp_fn(idx, "(int32_t)(uint32_t)", pgm, p),
        BuiltinFunDecl::U32Cmp => gen_cmp_fn(idx, "(uint32_t)", pgm, p),
        BuiltinFunDecl::U64Cmp => gen_cmp_fn(idx, "", pgm, p),

        BuiltinFunDecl::I8Add => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(
                p,
                "return (uint64_t)(uint8_t)((int8_t)(uint8_t)a + (int8_t)(uint8_t)b);"
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U8Add => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)((uint8_t)a + (uint8_t)b);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I32Add => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(
                p,
                "return (uint64_t)(uint32_t)((int32_t)(uint32_t)a + (int32_t)(uint32_t)b);"
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U32Add => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)((uint32_t)a + (uint32_t)b);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U64Add => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return a + b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I8Sub => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(
                p,
                "return (uint64_t)(uint8_t)((int8_t)(uint8_t)a - (int8_t)(uint8_t)b);"
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U8Sub => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)((uint8_t)a - (uint8_t)b);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I32Sub => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(
                p,
                "return (uint64_t)(uint32_t)((int32_t)(uint32_t)a - (int32_t)(uint32_t)b);"
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U32Sub => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)((uint32_t)a - (uint32_t)b);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I8Mul => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(
                p,
                "return (uint64_t)(uint8_t)((int8_t)(uint8_t)a * (int8_t)(uint8_t)b);"
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U8Mul => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)((uint8_t)a * (uint8_t)b);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I32Mul => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(
                p,
                "return (uint64_t)(uint32_t)((int32_t)(uint32_t)a * (int32_t)(uint32_t)b);"
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U32Mul => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)((uint32_t)a * (uint32_t)b);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U64Mul => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return a * b;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I8Div => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(
                p,
                "return (uint64_t)(uint8_t)((int8_t)(uint8_t)a / (int8_t)(uint8_t)b);"
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U8Div => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)((uint8_t)a / (uint8_t)b);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I32Div => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(
                p,
                "return (uint64_t)(uint32_t)((int32_t)(uint32_t)a / (int32_t)(uint32_t)b);"
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U32Div => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)((uint32_t)a / (uint32_t)b);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I8Eq | BuiltinFunDecl::U8Eq => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(
                p,
                "return ((uint8_t)a == (uint8_t)b) ? {} : {};",
                heap_obj_singleton_name(pgm, pgm.true_con_idx),
                heap_obj_singleton_name(pgm, pgm.false_con_idx)
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I32Eq | BuiltinFunDecl::U32Eq => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(
                p,
                "return ((uint32_t)a == (uint32_t)b) ? {} : {};",
                heap_obj_singleton_name(pgm, pgm.true_con_idx),
                heap_obj_singleton_name(pgm, pgm.false_con_idx)
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U32Mod => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)((uint32_t)a % (uint32_t)b);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I8Rem => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(
                p,
                "return (uint64_t)(uint8_t)((int8_t)(uint8_t)a % (int8_t)(uint8_t)b);"
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U8Rem => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)((uint8_t)a % (uint8_t)b);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I32Rem => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(
                p,
                "return (uint64_t)(uint32_t)((int32_t)(uint32_t)a % (int32_t)(uint32_t)b);"
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::U32Rem => {
            w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)((uint32_t)a % (uint32_t)b);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I32AsU32 => {
            w!(p, "static uint64_t _fun_{}(uint64_t a) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)(uint32_t)(int32_t)(uint32_t)a;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I32Abs => {
            w!(p, "static uint64_t _fun_{}(uint64_t a) {{", idx);
            p.indent();
            p.nl();
            wln!(p, "int32_t v = (int32_t)(uint32_t)a;");
            w!(p, "return (uint64_t)(uint32_t)(v < 0 ? -v : v);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I8Neg => {
            w!(p, "static uint64_t _fun_{}(uint64_t a) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)(uint8_t)(-(int8_t)(uint8_t)a);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::I32Neg => {
            w!(p, "static uint64_t _fun_{}(uint64_t a) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)(uint32_t)(-(int32_t)(uint32_t)a);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::ThrowUnchecked => {
            w!(p, "static uint64_t _fun_{}(uint64_t exn) {{", idx);
            p.indent();
            p.nl();
            wln!(p, "throw_exn(exn);");
            w!(p, "return 0; // unreachable");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::Try { ok_con, err_con } => {
            let ok_tag_name = heap_obj_tag_name(pgm, *ok_con);
            let err_tag_name = heap_obj_tag_name(pgm, *err_con);
            w!(p, "static uint64_t _fun_{}(uint64_t cb) {{", idx);
            p.indent();
            p.nl();
            wln!(p, "ExnHandler handler;");
            wln!(p, "handler.prev = current_exn_handler;");
            wln!(p, "current_exn_handler = &handler;");
            w!(p, "if (setjmp(handler.buf) == 0) {{");
            p.indent();
            p.nl();
            wln!(p, "// Call the closure");
            wln!(p, "uint64_t* closure = (uint64_t*)cb;");
            wln!(
                p,
                "uint64_t (*fn)(uint64_t) = (uint64_t (*)(uint64_t))((uint64_t*)cb)[1];"
            );
            wln!(p, "uint64_t result = fn(cb);");
            wln!(p, "current_exn_handler = handler.prev;");
            wln!(p, "// Allocate Ok result");
            wln!(p, "uint64_t* ok = alloc_words(2);");
            wln!(p, "ok[0] = {};", ok_tag_name);
            wln!(p, "ok[1] = result;");
            w!(p, "return (uint64_t)ok;");
            p.dedent();
            p.nl();
            w!(p, "}} else {{");
            p.indent();
            p.nl();
            wln!(p, "// Exception was thrown");
            wln!(p, "current_exn_handler = handler.prev;");
            wln!(p, "uint64_t* err = alloc_words(2);");
            wln!(p, "err[0] = {};", err_tag_name);
            wln!(p, "err[1] = handler.exn_value;");
            w!(p, "return (uint64_t)err;");
            p.dedent();
            p.nl();
            w!(p, "}}");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::ArrayNew { t } => {
            let repr = Repr::from_mono_ty(t);
            let fn_name = match repr {
                Repr::U8 => "array_new_u8",
                Repr::U32 => "array_new_u32",
                Repr::U64 => "array_new_u64",
            };
            w!(p, "static uint64_t _fun_{}(uint64_t len) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return {}((uint32_t)len);", fn_name);
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::ArrayLen => {
            w!(p, "static uint64_t _fun_{}(uint64_t arr) {{", idx);
            p.indent();
            p.nl();
            w!(p, "return (uint64_t)array_len(arr);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::ArrayGet { t } => {
            let repr = Repr::from_mono_ty(t);
            let fn_name = match repr {
                Repr::U8 => "array_get_u8",
                Repr::U32 => "array_get_u32",
                Repr::U64 => "array_get_u64",
            };
            w!(
                p,
                "static uint64_t _fun_{}(uint64_t arr, uint64_t idx) {{",
                idx
            );
            p.indent();
            p.nl();
            w!(p, "return {}(arr, (uint32_t)idx);", fn_name);
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::ArraySet { t } => {
            let repr = Repr::from_mono_ty(t);
            let fn_name = match repr {
                Repr::U8 => "array_set_u8",
                Repr::U32 => "array_set_u32",
                Repr::U64 => "array_set_u64",
            };
            w!(
                p,
                "static uint64_t _fun_{}(uint64_t arr, uint64_t idx, uint64_t val) {{",
                idx
            );
            p.indent();
            p.nl();
            wln!(p, "{}(arr, (uint32_t)idx, val);", fn_name);
            w!(
                p,
                "return {};",
                heap_obj_singleton_name(pgm, pgm.unit_con_idx)
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::ArraySlice { t } => {
            let repr = Repr::from_mono_ty(t);
            let fn_name = match repr {
                Repr::U8 => "array_slice_u8",
                Repr::U32 => "array_slice_u32",
                Repr::U64 => "array_slice_u64",
            };
            w!(
                p,
                "static uint64_t _fun_{}(uint64_t arr, uint64_t start, uint64_t end) {{",
                idx
            );
            p.indent();
            p.nl();
            w!(
                p,
                "return {}(arr, (uint32_t)start, (uint32_t)end);",
                fn_name
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::ArrayCopyWithin { t } => {
            let repr = Repr::from_mono_ty(t);
            let fn_name = match repr {
                Repr::U8 => "array_copy_within_u8",
                Repr::U32 => "array_copy_within_u32",
                Repr::U64 => "array_copy_within_u64",
            };
            w!(
                p,
                "static uint64_t _fun_{}(uint64_t arr, uint64_t src, uint64_t dst, uint64_t len) {{",
                idx
            );
            p.indent();
            p.nl();
            w!(
                p,
                "{}(arr, (uint32_t)src, (uint32_t)dst, (uint32_t)len);",
                fn_name
            );
            p.nl();
            w!(
                p,
                "return {};",
                heap_obj_singleton_name(pgm, pgm.unit_con_idx)
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::ReadFileUtf8 => {
            w!(p, "static uint64_t _fun_{}(uint64_t path_str) {{", idx);
            p.indent();
            p.nl();
            wln!(p, "uint64_t* s = (uint64_t*)path_str;");
            wln!(p, "uint64_t bytes_arr = s[1];");
            wln!(p, "uint32_t path_len = array_len(bytes_arr);");
            w!(
                p,
                "uint8_t* path_data = (uint8_t*)((uint64_t*)bytes_arr)[ARRAY_DATA_PTR_IDX];"
            );
            p.nl();
            wln!(p, "char* path = (char*)malloc(path_len + 1);");
            wln!(p, "memcpy(path, path_data, path_len);");
            wln!(p, "path[path_len] = '\\0';");
            wln!(p, "FILE* f = fopen(path, \"rb\");");
            wln!(p, "free(path);");
            w!(
                p,
                "if (!f) {{ fprintf(stderr, \"Failed to open file\\n\"); exit(1); }}"
            );
            p.nl();
            wln!(p, "fseek(f, 0, SEEK_END);");
            wln!(p, "long size = ftell(f);");
            wln!(p, "fseek(f, 0, SEEK_SET);");
            wln!(p, "char* contents = (char*)malloc(size);");
            wln!(
                p,
                "if (fread(contents, 1, size, f) != (size_t)size) {{ fprintf(stderr, \"Failed to read file\\n\"); exit(1); }}"
            );
            wln!(p, "fclose(f);");
            w!(
                p,
                "uint64_t result = alloc_str({}, contents, size);",
                pgm.str_con_idx.0
            );
            p.nl();
            wln!(p, "free(contents);");
            w!(p, "return result;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }

        BuiltinFunDecl::GetArgs => {
            w!(p, "static uint64_t _fun_{}(void) {{", idx);
            p.indent();
            p.nl();
            wln!(p, "uint64_t arr = array_new_u64(g_argc);");
            w!(p, "for (int i = 0; i < g_argc; i++) {{");
            p.indent();
            p.nl();
            w!(
                p,
                "uint64_t arg_str = alloc_str({}, g_argv[i], strlen(g_argv[i]));",
                pgm.str_con_idx.0
            );
            p.nl();
            w!(p, "array_set_u64(arr, i, arg_str);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
            w!(p, "return arr;");
            p.dedent();
            p.nl();
            wln!(p, "}}");
        }
    }
}

fn gen_tostr_fn(
    idx: usize,
    c_type: &str,
    cast: &str,
    fmt: &str,
    pgm: &LoweredPgm,
    p: &mut Printer,
) {
    w!(p, "static uint64_t _fun_{}(uint64_t a) {{", idx);
    p.indent();
    p.nl();
    wln!(p, "char buf[32];");
    w!(
        p,
        "int len = snprintf(buf, sizeof(buf), \"%\" {} , ({}){}a);",
        fmt,
        c_type,
        cast
    );
    p.nl();
    w!(p, "return alloc_str({}, buf, len);", pgm.str_con_idx.0);
    p.dedent();
    p.nl();
    wln!(p, "}}");
}

fn gen_cmp_fn(idx: usize, cast: &str, pgm: &LoweredPgm, p: &mut Printer) {
    w!(p, "static uint64_t _fun_{}(uint64_t a, uint64_t b) {{", idx);
    p.indent();
    p.nl();
    w!(
        p,
        "if ({}a < {}b) return {};",
        cast,
        cast,
        heap_obj_singleton_name(pgm, pgm.ordering_less_con_idx)
    );
    p.nl();
    w!(
        p,
        "if ({}a > {}b) return {};",
        cast,
        cast,
        heap_obj_singleton_name(pgm, pgm.ordering_greater_con_idx)
    );
    p.nl();
    w!(
        p,
        "return {};",
        heap_obj_singleton_name(pgm, pgm.ordering_equal_con_idx)
    );
    p.dedent();
    p.nl();
    wln!(p, "}}");
}

fn source_fun_to_c(fun: &SourceFunDecl, idx: usize, cg: &mut Cg, p: &mut Printer) {
    let loc = &fun.name.loc;
    w!(
        p,
        "// {}:{}:{} {}",
        loc.module,
        loc.line_start + 1,
        loc.col_start + 1,
        fun.name.node
    );
    if !fun.ty_args.is_empty() {
        w!(p, "[");
        for (i, ty_arg) in fun.ty_args.iter().enumerate() {
            if i > 0 {
                w!(p, ", ");
            }
            let mut ty_str = String::new();
            ty_arg.print(&mut ty_str);
            w!(p, "{}", ty_str);
        }
        w!(p, "]");
    }
    p.nl();
    w!(p, "static uint64_t _fun_{}(", idx);
    for (i, _) in fun.params.iter().enumerate() {
        if i > 0 {
            w!(p, ", ");
        }
        w!(p, "uint64_t _p{}", i);
    }
    w!(p, ") {{");
    p.indent();
    p.nl();

    // Declare all locals
    for (i, local) in fun.locals.iter().enumerate() {
        wln!(p, "uint64_t _{} = 0; // {}: {}", i, local.name, local.ty);
    }

    // Copy parameters to locals
    for (i, _) in fun.params.iter().enumerate() {
        wln!(p, "_{} = _p{};", i, i);
    }

    // Declare result variable
    w!(
        p,
        "uint64_t _result = {};",
        heap_obj_singleton_name(cg.pgm, cg.pgm.unit_con_idx)
    );
    p.nl();

    // Generate body
    for stmt in &fun.body {
        stmt_to_c(&stmt.node, &fun.locals, cg, p);
    }

    w!(p, "return _result;");
    p.dedent();
    p.nl();
    wln!(p, "}}");
}

fn closure_to_c(closure: &Closure, idx: usize, cg: &mut Cg, p: &mut Printer) {
    w!(p, "static uint64_t _closure_{}(uint64_t _closure_obj", idx);
    for (i, _) in closure.params.iter().enumerate() {
        w!(p, ", uint64_t _p{}", i);
    }
    w!(p, ") {{");
    p.indent();
    p.nl();

    // Declare all locals
    for (i, local) in closure.locals.iter().enumerate() {
        wln!(p, "uint64_t _{} = 0; // {}: {}", i, local.name, local.ty);
    }

    // Load free variables from closure object
    for (i, fv) in closure.fvs.iter().enumerate() {
        w!(
            p,
            "_{} = ((uint64_t*)_closure_obj)[{}]; // {}",
            fv.use_idx.as_usize(),
            2 + i,
            fv.id
        );
        p.nl();
    }

    // Copy parameters to locals
    for (i, _) in closure.params.iter().enumerate() {
        wln!(p, "_{} = _p{};", i, i);
    }

    // Declare result variable
    w!(
        p,
        "uint64_t _result = {};",
        heap_obj_singleton_name(cg.pgm, cg.pgm.unit_con_idx)
    );
    p.nl();

    // Generate body
    for stmt in &closure.body {
        stmt_to_c(&stmt.node, &closure.locals, cg, p);
    }

    w!(p, "return _result;");
    p.dedent();
    p.nl();
    wln!(p, "}}");
}

fn stmt_to_c(stmt: &Stmt, locals: &[LocalInfo], cg: &mut Cg, p: &mut Printer) {
    match stmt {
        Stmt::Let(LetStmt { lhs, rhs }) => {
            let rhs_temp = cg.fresh_temp();
            w!(p, "uint64_t {} = ", rhs_temp);
            expr_to_c(&rhs.node, locals, cg, p);
            wln!(p, ";");
            wln!(p, "{};", pat_to_cond(&lhs.node, &rhs_temp, cg));
            wln!(p, "_result = {};", rhs_temp);
        }

        Stmt::Assign(AssignStmt { lhs, rhs }) => match &lhs.node {
            Expr::LocalVar(idx) => {
                w!(p, "_{} = ", idx.as_usize());
                expr_to_c(&rhs.node, locals, cg, p);
                wln!(p, ";");
                w!(
                    p,
                    "_result = {};",
                    heap_obj_singleton_name(cg.pgm, cg.pgm.unit_con_idx)
                );
                p.nl();
            }
            Expr::FieldSel(FieldSelExpr {
                object,
                field: _,
                idx,
            }) => {
                let obj_temp = cg.fresh_temp();
                w!(p, "uint64_t {} = ", obj_temp);
                expr_to_c(&object.node, locals, cg, p);
                wln!(p, ";");
                w!(p, "((uint64_t*){})[{}] = ", obj_temp, 1 + idx);
                expr_to_c(&rhs.node, locals, cg, p);
                wln!(p, ";");
                w!(
                    p,
                    "_result = {};",
                    heap_obj_singleton_name(cg.pgm, cg.pgm.unit_con_idx)
                );
                p.nl();
            }
            _ => {
                // Type checker only accepts variables and fields on the LHS.
                panic!(
                    "{}: BUG: Assign statement with fancy LHS",
                    loc_display(&lhs.loc)
                )
            }
        },

        Stmt::Expr(expr) => {
            w!(p, "_result = ");
            expr_to_c(&expr.node, locals, cg, p);
            wln!(p, ";");
        }

        Stmt::While(WhileStmt { label, cond, body }) => {
            w!(p, "while (1) {{");
            p.indent();
            p.nl();
            let cond_temp = cg.fresh_temp();
            w!(p, "uint64_t {} = ", cond_temp);
            expr_to_c(&cond.node, locals, cg, p);
            wln!(p, ";");
            w!(
                p,
                "if ({} == {}) break;",
                cond_temp,
                heap_obj_singleton_name(cg.pgm, cg.pgm.false_con_idx)
            );
            p.nl();
            for stmt in body {
                stmt_to_c(&stmt.node, locals, cg, p);
            }
            if let Some(label) = label {
                w!(p, "_continue_{}:;", label);
            }
            p.dedent();
            p.nl();
            wln!(p, "}}");
            if let Some(label) = label {
                wln!(p, "_break_{}:;", label);
            }
            w!(
                p,
                "_result = {};",
                heap_obj_singleton_name(cg.pgm, cg.pgm.unit_con_idx)
            );
            p.nl();
        }

        Stmt::Break { label, level: _ } => {
            match label {
                Some(label) => w!(p, "goto _break_{};", label),
                None => w!(p, "break;"),
            }
            p.nl();
        }

        Stmt::Continue { label, level: _ } => {
            match label {
                Some(label) => w!(p, "goto _continue_{};", label),
                None => w!(p, "continue;"),
            }
            p.nl();
        }
    }
}

fn expr_to_c(expr: &Expr, locals: &[LocalInfo], cg: &mut Cg, p: &mut Printer) {
    match expr {
        Expr::LocalVar(idx) => {
            w!(p, "_{}", idx.as_usize());
        }

        Expr::Fun(fun_idx) => {
            // Return a closure object for the function
            w!(p, "_fun_closure_{}", fun_idx.as_usize());
        }

        Expr::Con(heap_obj_idx) => {
            // Return a constructor closure object
            w!(p, "_con_closure_{}", heap_obj_idx.0);
        }

        Expr::ConAlloc(heap_obj_idx, args) => {
            if args.is_empty() {
                // Return singleton
                w!(p, "{}", heap_obj_singleton_name(cg.pgm, *heap_obj_idx));
            } else {
                // Allocate object
                w!(p, "({{");
                p.indent();
                p.nl();
                wln!(p, "uint64_t* _obj = alloc_words({});", 1 + args.len());
                let tag_name = heap_obj_tag_name(cg.pgm, *heap_obj_idx);
                wln!(p, "_obj[0] = {};", tag_name);
                for (i, arg) in args.iter().enumerate() {
                    w!(p, "_obj[{}] = ", 1 + i);
                    expr_to_c(&arg.node, locals, cg, p);
                    wln!(p, ";");
                }
                w!(p, "(uint64_t)_obj;");
                p.dedent();
                p.nl();
                w!(p, "}})");
            }
        }

        Expr::FieldSel(FieldSelExpr {
            object,
            field: _,
            idx,
        }) => {
            w!(p, "((uint64_t*)(");
            expr_to_c(&object.node, locals, cg, p);
            w!(p, "))[{}]", 1 + idx);
        }

        Expr::Call(CallExpr { fun, args }) => {
            // Check if direct function call
            match &fun.node {
                Expr::Fun(fun_idx) => {
                    // Direct function call
                    w!(p, "_fun_{}(", fun_idx.as_usize());
                    for (i, arg) in args.iter().enumerate() {
                        if i > 0 {
                            w!(p, ", ");
                        }
                        expr_to_c(&arg.node, locals, cg, p);
                    }
                    w!(p, ")");
                }
                _ => {
                    // Closure call
                    w!(p, "({{");
                    p.indent();
                    p.nl();
                    let fun_temp = cg.fresh_temp();
                    w!(p, "uint64_t {} = ", fun_temp);
                    expr_to_c(&fun.node, locals, cg, p);
                    wln!(p, ";");
                    wln!(p, "uint32_t _tag = get_tag({});", fun_temp);
                    wln!(p, "uint64_t _call_result;");

                    // Check tag and dispatch
                    w!(p, "if (_tag == CON_CON_TAG) {{");
                    p.indent();
                    p.nl();
                    w!(
                        p,
                        "uint32_t _con_tag = (uint32_t)((uint64_t*){})[ 1];",
                        fun_temp
                    );
                    p.nl();
                    wln!(p, "uint64_t* _obj = alloc_words({});", 1 + args.len());
                    wln!(p, "_obj[0] = _con_tag;");
                    for (i, arg) in args.iter().enumerate() {
                        w!(p, "_obj[{}] = ", 1 + i);
                        expr_to_c(&arg.node, locals, cg, p);
                        wln!(p, ";");
                    }
                    w!(p, "_call_result = (uint64_t)_obj;");
                    p.dedent();
                    p.nl();
                    w!(p, "}} else if (_tag == FUN_CON_TAG) {{");
                    p.indent();
                    p.nl();
                    // Cast to function pointer and call
                    let arg_count = args.len();
                    w!(p, "uint64_t (*_fn)(");
                    for i in 0..arg_count {
                        if i > 0 {
                            w!(p, ", ");
                        }
                        w!(p, "uint64_t");
                    }
                    w!(p, ") = (uint64_t (*)(");
                    for i in 0..arg_count {
                        if i > 0 {
                            w!(p, ", ");
                        }
                        w!(p, "uint64_t");
                    }
                    wln!(p, "))((uint64_t*){})[ 1];", fun_temp);
                    w!(p, "_call_result = _fn(");
                    for (i, arg) in args.iter().enumerate() {
                        if i > 0 {
                            w!(p, ", ");
                        }
                        expr_to_c(&arg.node, locals, cg, p);
                    }
                    w!(p, ");");
                    p.dedent();
                    p.nl();
                    w!(p, "}} else {{");
                    p.indent();
                    p.nl();
                    // Closure call - need to pass closure object as first arg
                    w!(p, "uint64_t (*_fn)(uint64_t");
                    for _ in 0..args.len() {
                        w!(p, ", uint64_t");
                    }
                    w!(p, ") = (uint64_t (*)(uint64_t");
                    for _ in 0..args.len() {
                        w!(p, ", uint64_t");
                    }
                    wln!(p, "))((uint64_t*){})[ 1];", fun_temp);
                    w!(p, "_call_result = _fn({}", fun_temp);
                    for arg in args {
                        w!(p, ", ");
                        expr_to_c(&arg.node, locals, cg, p);
                    }
                    w!(p, ");");
                    p.dedent();
                    p.nl();
                    wln!(p, "}}");
                    w!(p, "_call_result;");
                    p.dedent();
                    p.nl();
                    w!(p, "}})");
                }
            }
        }

        Expr::Int(val) => {
            w!(p, "{}ULL", val);
        }

        Expr::Str(s) => {
            w!(p, "alloc_str({}, \"", cg.pgm.str_con_idx.0);
            for byte in s.bytes() {
                if byte == b'"' || byte == b'\\' || !(32..=126).contains(&byte) {
                    // Use octal escapes as hex escapes doesn't have a digit limit, e.g.
                    // `\xaaaaa...` will consider all those `a`s as digits.
                    w!(p, "\\{:03o}", byte);
                } else {
                    w!(p, "{}", byte as char);
                }
            }
            w!(p, "\", {})", s.len());
        }

        Expr::BoolAnd(left, right) => {
            w!(p, "({{");
            p.indent();
            p.nl();
            w!(p, "uint64_t _and_result = ");
            expr_to_c(&left.node, locals, cg, p);
            wln!(p, ";");
            w!(
                p,
                "if (_and_result == {}) {{",
                heap_obj_singleton_name(cg.pgm, cg.pgm.true_con_idx)
            );
            p.indent();
            p.nl();
            w!(p, "_and_result = ");
            expr_to_c(&right.node, locals, cg, p);
            w!(p, ";");
            p.dedent();
            p.nl();
            wln!(p, "}}");
            w!(p, "_and_result;");
            p.dedent();
            p.nl();
            w!(p, "}})");
        }

        Expr::BoolOr(left, right) => {
            w!(p, "({{");
            p.indent();
            p.nl();
            w!(p, "uint64_t _or_result = ");
            expr_to_c(&left.node, locals, cg, p);
            wln!(p, ";");
            w!(
                p,
                "if (_or_result == {}) {{",
                heap_obj_singleton_name(cg.pgm, cg.pgm.false_con_idx)
            );
            p.indent();
            p.nl();
            w!(p, "_or_result = ");
            expr_to_c(&right.node, locals, cg, p);
            w!(p, ";");
            p.dedent();
            p.nl();
            wln!(p, "}}");
            w!(p, "_or_result;");
            p.dedent();
            p.nl();
            w!(p, "}})");
        }

        Expr::Return(expr) => {
            w!(p, "({{");
            p.indent();
            p.nl();
            w!(p, "return ");
            expr_to_c(&expr.node, locals, cg, p);
            wln!(p, ";");
            w!(p, "0; // unreachable");
            p.dedent();
            p.nl();
            w!(p, "}})");
        }

        Expr::Match(MatchExpr { scrutinee, alts }) => {
            w!(p, "({{");
            p.indent();
            p.nl();
            let scrut_temp = cg.fresh_temp();
            w!(p, "uint64_t {} = ", scrut_temp);
            expr_to_c(&scrutinee.node, locals, cg, p);
            wln!(p, ";");
            wln!(p, "uint64_t _match_result = 0;");

            for (i, alt) in alts.iter().enumerate() {
                if i > 0 {
                    w!(p, " else ");
                }
                // Generate pattern match condition
                let cond = pat_to_cond(&alt.pat.node, &scrut_temp, cg);
                w!(p, "if ({}", cond);

                // Add guard if present
                if let Some(guard) = &alt.guard {
                    w!(p, " && (");
                    expr_to_c(&guard.node, locals, cg, p);
                    w!(
                        p,
                        " == {})",
                        heap_obj_singleton_name(cg.pgm, cg.pgm.true_con_idx)
                    );
                }

                w!(p, ") {{");
                p.indent();
                p.nl();
                // Generate RHS
                for stmt in &alt.rhs {
                    stmt_to_c(&stmt.node, locals, cg, p);
                }
                w!(p, "_match_result = _result;");
                p.dedent();
                p.nl();
                w!(p, "}}");
            }
            w!(p, " else {{");
            p.indent();
            p.nl();
            wln!(p, "fprintf(stderr, \"Non-exhaustive pattern match\\n\");");
            w!(p, "exit(1);");
            p.dedent();
            p.nl();
            wln!(p, "}}");
            w!(p, "_match_result;");
            p.dedent();
            p.nl();
            w!(p, "}})");
        }

        Expr::If(IfExpr {
            branches,
            else_branch,
        }) => {
            w!(p, "({{");
            p.indent();
            p.nl();
            wln!(p, "uint64_t _if_result = 0;");

            for (i, (cond, body)) in branches.iter().enumerate() {
                if i > 0 {
                    w!(p, " else ");
                }
                let cond_temp = cg.fresh_temp();
                w!(p, "{{");
                p.indent();
                p.nl();
                w!(p, "uint64_t {} = ", cond_temp);
                expr_to_c(&cond.node, locals, cg, p);
                wln!(p, ";");
                w!(
                    p,
                    "if ({} == {}) {{",
                    cond_temp,
                    heap_obj_singleton_name(cg.pgm, cg.pgm.true_con_idx)
                );
                p.indent();
                p.nl();
                for stmt in body {
                    stmt_to_c(&stmt.node, locals, cg, p);
                }
                w!(p, "_if_result = _result;");
                p.dedent();
                p.nl();
                w!(p, "}}");
            }

            match else_branch {
                Some(else_body) => {
                    w!(p, " else {{");
                    p.indent();
                    p.nl();
                    for stmt in else_body {
                        stmt_to_c(&stmt.node, locals, cg, p);
                    }
                    w!(p, "_if_result = _result;");
                    p.dedent();
                    p.nl();
                    w!(p, "}}");
                }
                None => {
                    w!(
                        p,
                        "_if_result = {};",
                        heap_obj_singleton_name(cg.pgm, cg.pgm.unit_con_idx)
                    );
                }
            }

            // Close all the blocks we opened for conditions
            for _ in 0..branches.len() {
                p.dedent();
                p.nl();
                w!(p, " }}");
            }
            p.nl();
            w!(p, "_if_result;");
            p.dedent();
            p.nl();
            w!(p, "}})");
        }

        Expr::ClosureAlloc(closure_idx) => {
            let closure = &cg.pgm.closures[closure_idx.as_usize()];
            w!(p, "({{");
            p.indent();
            p.nl();
            w!(
                p,
                "uint64_t* _clos = alloc_words({});",
                2 + closure.fvs.len()
            );
            p.nl();
            wln!(p, "_clos[0] = CLOSURE_CON_TAG;");
            w!(
                p,
                "_clos[1] = (uint64_t)_closure_{};",
                closure_idx.as_usize()
            );
            p.nl();
            for (i, fv) in closure.fvs.iter().enumerate() {
                w!(
                    p,
                    "_clos[{}] = _{}; // {}",
                    2 + i,
                    fv.alloc_idx.as_usize(),
                    fv.id
                );
                p.nl();
            }
            w!(p, "(uint64_t)_clos;");
            p.dedent();
            p.nl();
            w!(p, "}})");
        }

        Expr::Is(IsExpr { expr, pat }) => {
            w!(p, "({{");
            p.indent();
            p.nl();
            let expr_temp = cg.fresh_temp();
            w!(p, "uint64_t {} = ", expr_temp);
            expr_to_c(&expr.node, locals, cg, p);
            wln!(p, ";");
            let cond = pat_to_cond(&pat.node, &expr_temp, cg);
            wln!(p, "uint64_t _is_result;");
            w!(p, "if ({}) {{", cond);
            p.indent();
            p.nl();
            w!(
                p,
                "_is_result = {};",
                heap_obj_singleton_name(cg.pgm, cg.pgm.true_con_idx)
            );
            p.dedent();
            p.nl();
            w!(p, "}} else {{");
            p.indent();
            p.nl();
            w!(
                p,
                "_is_result = {};",
                heap_obj_singleton_name(cg.pgm, cg.pgm.false_con_idx)
            );
            p.dedent();
            p.nl();
            wln!(p, "}}");
            w!(p, "_is_result;");
            p.dedent();
            p.nl();
            w!(p, "}})");
        }

        Expr::Do(stmts) => {
            w!(p, "({{");
            p.indent();
            p.nl();
            for stmt in stmts {
                stmt_to_c(&stmt.node, locals, cg, p);
            }
            w!(p, "_result;");
            p.dedent();
            p.nl();
            w!(p, "}})");
        }

        Expr::Variant(expr) => {
            // Variants are represented as their underlying type
            expr_to_c(&expr.node, locals, cg, p);
        }
    }
}

/// Generate a C condition expression for pattern matching.
fn pat_to_cond(pat: &Pat, scrutinee: &str, cg: &mut Cg) -> String {
    match pat {
        Pat::Ignore => "1".to_string(),

        Pat::Var(idx) => {
            format!("({{ _{} = {}; 1; }})", idx.as_usize(), scrutinee)
        }

        Pat::Con(ConPat { con, fields }) => {
            let tag_name = heap_obj_tag_name(cg.pgm, *con);
            let mut cond = format!("(get_tag({}) == {})", scrutinee, tag_name);
            for (i, field_pat) in fields.iter().enumerate() {
                let field_expr = format!("((uint64_t*){})[{}]", scrutinee, 1 + i);
                let field_cond = pat_to_cond(&field_pat.node, &field_expr, cg);
                cond = format!("({} && {})", cond, field_cond);
            }
            cond
        }

        Pat::Str(s) => {
            let mut escaped = String::new();
            for byte in s.bytes() {
                if byte == b'"' || byte == b'\\' || !(32..=126).contains(&byte) {
                    // Same as `Expr::Str`, use octal escape here instead of hex.
                    escaped.push_str(&format!("\\{:03o}", byte));
                } else {
                    escaped.push(byte as char);
                }
            }
            format!(
                "(get_tag({}) == {} && str_eq({}, \"{}\", {}))",
                scrutinee,
                cg.pgm.str_con_idx.0,
                scrutinee,
                escaped,
                s.len()
            )
        }

        Pat::Char(c) => {
            let tag_name = heap_obj_tag_name(cg.pgm, cg.pgm.char_con_idx);
            format!(
                "(get_tag({}) == {} && ((uint64_t*){})[1] == {})",
                scrutinee, tag_name, scrutinee, *c as u32
            )
        }

        Pat::Or(p1, p2) => {
            let c1 = pat_to_cond(&p1.node, scrutinee, cg);
            let c2 = pat_to_cond(&p2.node, scrutinee, cg);
            format!("({} || {})", c1, c2)
        }

        Pat::Variant(inner) => pat_to_cond(&inner.node, scrutinee, cg),
    }
}

fn generate_main_fn(pgm: &LoweredPgm, main: &str, p: &mut Printer) {
    let main_idx = pgm
        .funs
        .iter()
        .enumerate()
        .find_map(|(i, fun)| match fun {
            Fun::Source(source) if source.name.node.as_str() == main => Some(i),
            _ => None,
        })
        .unwrap_or_else(|| panic!("Main function {main} is not defined"));

    p.nl();
    w!(p, "int main(int argc, char** argv) {{");
    p.indent();
    p.nl();
    wln!(p, "g_argc = argc;");
    wln!(p, "g_argv = argv;");
    wln!(p, "_fun_{}();", main_idx);
    w!(p, "return 0;");
    p.dedent();
    p.nl();
    wln!(p, "}}");
}

#[derive(Debug, Default)]
struct Printer {
    lines: Vec<String>,
    current_line: String,
    indent: u32,
}

impl Printer {
    fn nl(&mut self) {
        let line = std::mem::replace(&mut self.current_line, " ".repeat(self.indent as usize * 4));
        self.lines.push(line)
    }

    fn print(mut self) -> String {
        self.nl();
        let mut out = String::with_capacity(self.lines.iter().map(|l| l.len()).sum());
        for (i, line) in self.lines.iter().enumerate() {
            if i != 0 {
                out.push('\n');
            }
            out.push_str(line);
        }
        out
    }

    fn indent(&mut self) {
        self.indent += 1;
    }

    fn dedent(&mut self) {
        self.indent -= 1;
    }
}

impl Write for Printer {
    fn write_str(&mut self, s: &str) -> std::fmt::Result {
        self.current_line.push_str(s);
        Ok(())
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Top sort

/// Topologically sort user-defined types into SCCs.
fn top_sort(
    type_objs: &HashMap<Id, HashMap<Vec<mono::Type>, Vec<HeapObjIdx>>>,
    heap_objs: &[HeapObj],
) -> Vec<HashSet<HeapObjIdx>> {
    let mut idx_gen = SccIdxGen::default();

    let mut output: Vec<HashSet<HeapObjIdx>> = Vec::with_capacity(heap_objs.len());

    // Because the object indices are consecutive numbers from 0 to number of objects, we can use an
    // array to map object indices to things.
    //
    // Assign the first indices to built-ins right away: they can't be analysed and they don't have
    // dependencies, and user-defined types can depend on them. So they need to come first. (I think
    // they may already come first in `heap_objs` so they'll get the first SCC indices, but we don't
    // have to rely on that, we can just give the the first indices here)
    let mut nodes: Box<[SccNode]> = heap_objs
        .iter()
        .enumerate()
        .map(|(heap_obj_idx, heap_obj)| SccNode {
            idx: match heap_obj {
                HeapObj::Builtin(_) => {
                    output.push(std::iter::once(HeapObjIdx(heap_obj_idx as u32)).collect());
                    Some(idx_gen.next())
                }
                HeapObj::Source(_) | HeapObj::Record(_) => None,
            },
            low_link: None,
            on_stack: false,
        })
        .collect();

    let mut stack: Vec<HeapObjIdx> = Vec::with_capacity(10);

    for (heap_obj_idx, _) in heap_objs.iter().enumerate() {
        if nodes[heap_obj_idx].idx.is_none() {
            _scc(
                type_objs,
                heap_objs,
                HeapObjIdx(heap_obj_idx as u32),
                &mut idx_gen,
                &mut nodes,
                &mut stack,
                &mut output,
            );
        }
    }

    output
}

#[derive(Debug)]
struct SccNode {
    idx: Option<SccIdx>,
    low_link: Option<SccIdx>,
    on_stack: bool,
}

#[derive(Debug, Default)]
struct SccIdxGen {
    next: u32,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
struct SccIdx(u32);

impl SccIdxGen {
    fn next(&mut self) -> SccIdx {
        let next = self.next;
        self.next += 1;
        SccIdx(next)
    }
}

fn _scc(
    type_objs: &HashMap<Id, HashMap<Vec<mono::Type>, Vec<HeapObjIdx>>>,
    heap_objs: &[HeapObj],
    heap_obj_idx: HeapObjIdx,
    idx_gen: &mut SccIdxGen,
    nodes: &mut [SccNode],
    stack: &mut Vec<HeapObjIdx>,
    output: &mut Vec<HashSet<HeapObjIdx>>,
) {
    let idx = idx_gen.next();

    nodes[heap_obj_idx.as_usize()].idx = Some(idx);
    nodes[heap_obj_idx.as_usize()].low_link = Some(idx);
    nodes[heap_obj_idx.as_usize()].on_stack = true;

    stack.push(heap_obj_idx);

    // Add dependencies to the output.
    let deps = heap_obj_deps(type_objs, heap_objs, heap_obj_idx);
    for dep_obj in deps {
        if nodes[dep_obj.as_usize()].idx.is_none() {
            // Dependency not visited yet.
            _scc(type_objs, heap_objs, dep_obj, idx_gen, nodes, stack, output);
            let current_low_link = nodes[heap_obj_idx.as_usize()].low_link.unwrap();
            let dep_low_link = nodes[dep_obj.as_usize()].low_link.unwrap();
            nodes[heap_obj_idx.as_usize()].low_link = Some(current_low_link.min(dep_low_link));
        } else if nodes[dep_obj.as_usize()].on_stack {
            // Dependency is on stack, so in the current SCC.
            let current_low_link = nodes[heap_obj_idx.as_usize()].low_link.unwrap();
            let dep_idx = nodes[dep_obj.as_usize()].idx.unwrap();
            nodes[heap_obj_idx.as_usize()].low_link = Some(current_low_link.min(dep_idx));
        }
    }

    // If current node is  aroot node, pop the stack and generate an SCC.
    if nodes[heap_obj_idx.as_usize()].low_link == nodes[heap_obj_idx.as_usize()].idx {
        let mut scc: HashSet<HeapObjIdx> = Default::default();
        loop {
            let dep = stack.pop().unwrap();
            nodes[dep.as_usize()].on_stack = false;
            scc.insert(dep);
            if dep == heap_obj_idx {
                break;
            }
        }

        output.push(scc);
    }
}

fn heap_obj_deps(
    type_objs: &HashMap<Id, HashMap<Vec<mono::Type>, Vec<HeapObjIdx>>>,
    heap_objs: &[HeapObj],
    heap_obj_idx: HeapObjIdx,
) -> HashSet<HeapObjIdx> {
    let mut deps: HashSet<HeapObjIdx> = Default::default();

    match &heap_objs[heap_obj_idx.as_usize()] {
        HeapObj::Builtin(_) => {}

        HeapObj::Source(source_decl) => {
            for field in source_decl.fields.iter() {
                type_heap_obj_deps(type_objs, field, &mut deps);
            }
        }

        HeapObj::Record(record_type) => {
            for field in record_type.fields.values() {
                type_heap_obj_deps(type_objs, field, &mut deps);
            }
        }
    }

    deps
}

fn type_heap_obj_deps(
    type_objs: &HashMap<Id, HashMap<Vec<mono::Type>, Vec<HeapObjIdx>>>,
    ty: &mono::Type,
    deps: &mut HashSet<HeapObjIdx>,
) {
    match ty {
        mono::Type::Named(ty) => {
            named_type_heap_obj_deps(type_objs, ty, deps);
        }

        mono::Type::Record { fields } => {
            for ty in fields.values() {
                type_heap_obj_deps(type_objs, ty, deps);
            }
        }

        mono::Type::Variant { alts } => {
            for ty in alts.values() {
                named_type_heap_obj_deps(type_objs, ty, deps);
            }
        }

        mono::Type::Fn(mono::FnType { args, ret, exn }) => {
            match args {
                mono::FunArgs::Positional(args) => {
                    for arg in args {
                        type_heap_obj_deps(type_objs, arg, deps);
                    }
                }
                mono::FunArgs::Named(args) => {
                    for arg in args.values() {
                        type_heap_obj_deps(type_objs, arg, deps);
                    }
                }
            }

            type_heap_obj_deps(type_objs, ret, deps);
            type_heap_obj_deps(type_objs, exn, deps);
        }

        mono::Type::Never => {}
    }
}

fn named_type_heap_obj_deps(
    type_objs: &HashMap<Id, HashMap<Vec<mono::Type>, Vec<HeapObjIdx>>>,
    ty: &mono::NamedType,
    deps: &mut HashSet<HeapObjIdx>,
) {
    let ty_map = match type_objs.get(&ty.name) {
        Some(ty_map) => ty_map,
        None => return, // builtin
    };

    deps.extend(ty_map.get(&ty.args).unwrap().iter().cloned());
}
