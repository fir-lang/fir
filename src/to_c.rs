/*
This module compiles lowered syntax to C.

## Heap objects

All heap objects are allocated with `mallc` and have a `u32` tag.

For now we don't reclaim memory: all allocations leak.

In the future: we may try Boehm or some other conservative GC.

## Types

Product types (including records) will be compiled to C structs.

Sum types: every constructor will have its own struct and structs, with different fields and sizes.

Sum type constructors will have different (unique in entire program) tags, which will be used to
discriminate in pattern matching.

## Functions and constructors

Every function and constructor will be compiled to two C definitions:

- An actual C function that runs the function and constructor.
- A static object (with same layout as heap allocations) for the closures of the constructor or
  function.

## Closures

Every closure in the program will have its own unique type, similar to types.

## Exprs

Block expressions like `match` and `if` will be compiled with a destination variable, for the value
generated by the `match`/`if`/etc.

- `LocalVar`: C variable.

- `Fun`: reference to the top-level closure of the function.

- `Con`: same as `Con`.

- `ConAlloc`: allocate the heap object with `malloc` + initialize fields.

- `FieldSel`: evaluate object, then `object->field`.

- `Call`: special case `Fun` calls to call the function directly. For others: the function will
  evaluate to a closure. Call the closure entry.

- `Int`: compile to C integer.

- `Str`: allocate an array for the UTF-8 encoding, then allocate `type Str(...)`.

- `BoolAnd`:
  ```
  ({
    bool b = <evaluate left>;
    if (b) {
      b = <evaluate right>;
    }
    b
  })
  ```

- `BoolOr`: similar to `BoolAnd`.

- `Return`: C `return`

- `Match`: compile each branch as `if <scrutinee> is <pattern> { <body> }`.
  Chain all branches with `else if`.

  Branch return values will need to be written to the "destination" variable.

- `If`: similar.

- `ClosureAlloc`: allocate closure.

- `Is`: see pattern matching below.

- `Do`: We may be able to use statement expressions:
   https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html.

   Or create and pass destination.

- Variant: we need to create structs for these. TODO
*/

use crate::ast;
use crate::lowering::*;
