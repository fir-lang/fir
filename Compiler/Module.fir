import [
    Compiler/Ast,
    Compiler/Defs,
    Compiler/TypeCheck,
    Compiler/TypeCheck/Ty,
    Compiler/TypeCheck/TyCon,
]


#[derive(ToDoc)]
type PackageUri(
    _uri: Str,
)


#[derive(ToDoc)]
type ModuleIdx(
    ## Index of the module in the program.
    _idx: U32,
)


impl Eq[ModuleIdx]:
    __eq(self: ModuleIdx, other: ModuleIdx) Bool:
        self._idx == other._idx


impl Hash[ModuleIdx]:
    hash(self: ModuleIdx) U32:
        self._idx


#[derive(ToDoc)]
type Module(
    ## The module's package.
    _package: PackageUri,

    ## File path of the module's file.
    # TODO: Is this absolute? Or relative? If relative, relative to what?
    # For now we only use this for errors so it doesn't matter too much.
    _filePath: Str,

    ## Path of the module in its package.
    _path: Vec[Str],

    _idx: ModuleIdx,

    # --------------------------------------------------------------------------
    # ASTs of definitions in the module.
    #
    # These don't include imported things.
    #
    # Generated by `Program.loadedCachedModule`.

    ## Functions defined in the module.
    _funItems: HashMap[Str, FunDecl],

    ## Associated functions (including methods, but not trait methods) defined
    ## in the module.
    _assocItems: HashMap[Str, HashMap[Str, FunDecl]],

    ## Types defined in the module.
    _tyItems: HashMap[Str, TypeDecl],

    ## Traits defined in the module.
    _traitItems: HashMap[Str, TraitDecl],

    ## Impls defined in the module.
    _impls: Vec[ImplDecl],

    ## Imported modules. These are used when resolving identifiers.
    _imports: Vec[ModuleIdx],

    ## Tokens of the module. ASTs in the other fields for definitions in the
    ## current module refer to tokens in this array.
    _tokens: Array[Token],

    # --------------------------------------------------------------------------
    # Environments for name resolving.
    #
    # At this stage we still can't create type constructors and schemes, but the
    # environments can refer to things in other modules.
    #
    # Conceptually the values here are references to items, potentially in other
    # modules.

    ## Term environment of the module, used for name resolving.
    _termEnv: HashMap[Str, VarDefIdx],

    ## Associated item environment of the module, used for name resolving.
    _assocTermEnv: HashMap[Str, HashMap[Str, AssocVarDefIdx]],

    ## Type environment of the module, used for name resolving.
    _tyEnv: HashMap[Str, TyDefIdx],

    # --------------------------------------------------------------------------

    _tcEnv: Option[ModuleTcEnv],

    # --------------------------------------------------------------------------

    ## Strongly connected component index of the module in the program.
    ## Generated by the dependency analysis.
    _sccIdx: Option[U32],
)


Module.tokenText(self, idx: TokenIdx) Str:
    self._tokens.get(idx.idx).text


Module.idText(self, id: Id) Str:
    self.tokenText(id.token)


Module.tokenLoc(self, token: TokenIdx) Loc:
    let token = self._tokens.get(token.idx)
    Loc(file = self._filePath, line = token.line, col = token.col)


Module.loc[Tokens[t]](self, t: t) Loc:
    self.tokenLoc(t.firstToken())


Module.tyCon(self, tyIdx: TyDefIdx) TyCon:
    assert(self._idx == tyIdx._mod)
    let tcEnv = self._tcEnv.unwrap()
    let item = tcEnv._cons.get(tyIdx._name).unwrap()
    assert(item.idx == tyIdx)
    item.info


# ------------------------------------------------------------------------------
# Generated ToDoc implementations


impl ToDoc[ModuleIdx]:
    toDoc(self: ModuleIdx) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("_idx =") + Doc.nested(4, Doc.break_(1) + self._idx.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("ModuleIdx") + Doc.char('(') + args)


impl ToDoc[Module]:
    toDoc(self: Module) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("_package =")
                + Doc.nested(4, Doc.break_(1) + self._package.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_filePath =")
                + Doc.nested(4, Doc.break_(1) + self._filePath.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_path =")
                + Doc.nested(4, Doc.break_(1) + self._path.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_idx =") + Doc.nested(4, Doc.break_(1) + self._idx.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_funItems =")
                + Doc.nested(4, Doc.break_(1) + self._funItems.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_assocItems =")
                + Doc.nested(4, Doc.break_(1) + self._assocItems.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_tyItems =")
                + Doc.nested(4, Doc.break_(1) + self._tyItems.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_traitItems =")
                + Doc.nested(4, Doc.break_(1) + self._traitItems.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_impls =")
                + Doc.nested(4, Doc.break_(1) + self._impls.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_imports =")
                + Doc.nested(4, Doc.break_(1) + self._imports.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_tokens =")
                + Doc.nested(4, Doc.break_(1) + self._tokens.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_termEnv =")
                + Doc.nested(4, Doc.break_(1) + self._termEnv.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_assocTermEnv =")
                + Doc.nested(4, Doc.break_(1) + self._assocTermEnv.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_tyEnv =")
                + Doc.nested(4, Doc.break_(1) + self._tyEnv.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_sccIdx =")
                + Doc.nested(4, Doc.break_(1) + self._sccIdx.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("Module") + Doc.char('(') + args)
