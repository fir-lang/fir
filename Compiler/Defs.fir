## Defines identifiers, packages, modules, module-level items.


import [Compiler/Ast]


# ------------------------------------------------------------------------------
# Identifiers


## A term variable id.
##
## This can refer to: local variables, top-level variables, associated
## functions.
#[derive(ToDoc)]
type VarId(
    token: TokenIdx,
    _resolved: Option[VarDefIdx],
)


VarId.new(token: TokenIdx) VarId:
    VarId(token, _resolved = Option.None)


VarId.resolve(self, def: VarDefIdx):
    assert(self._resolved is Option.None)
    self._resolved = Option.Some(def)


#[derive(ToDoc)]
type AssocVarId(
    token: TokenIdx,
    _resolved: Option[AssocVarDefIdx],
)


## A type id.
##
## These can refer to: product and sum types, traits.
#[derive(ToDoc)]
type TyId(
    token: TokenIdx,
    _resolved: Option[TyDefIdx],
)


TyId.new(token: TokenIdx) TyId:
    TyId(token, _resolved = Option.None)


TyId.resolve(self, def: TyDefIdx):
    assert(self._resolved is Option.None)
    self._resolved = Option.Some(def)


# ------------------------------------------------------------------------------
# Packages and modules


#[derive(ToDoc)]
type PackageUri(
    _uri: Str,
)


#[derive(ToDoc)]
type ModuleIdx(
    ## Index of the module in the program.
    _idx: U32,
)


impl Eq[ModuleIdx]:
    __eq(self: ModuleIdx, other: ModuleIdx) Bool:
        self._idx == other._idx


impl Hash[ModuleIdx]:
    hash(self: ModuleIdx) U32:
        self._idx


#[derive(ToDoc)]
type Module(
    ## The module's package.
    _package: PackageUri,

    ## File path of the module's file.
    # TODO: Is this absolute? Or relative? If relative, relative to what?
    # For now we only use this for errors so it doesn't matter too much.
    _filePath: Str,

    ## Path of the module in its package.
    _path: Vec[Str],

    _idx: ModuleIdx,

    ## Functions defined in the module.
    _funItems: HashMap[Str, FunDecl],

    ## Associated functions (including methods, but not trait methods) defined
    ## in the module.
    _assocItems: HashMap[Str, HashMap[Str, FunDecl]],

    ## Types defined in the module.
    _tyItems: HashMap[Str, TypeDecl],

    ## Traits defined in the module.
    _traitItems: HashMap[Str, TraitDecl],

    ## Impls defined in the module.
    _impls: Vec[ImplDecl],

    ## Imported modules. These are used when resolving identifiers.
    _imports: Vec[ModuleIdx],

    ## Tokens of the module. ASTs in the other fields for definitions in the
    ## current module refer to tokens in this array.
    _tokens: Array[Token],

    ## Term environment of the module, used for name resolving.
    _termEnv: HashMap[Str, VarDefIdx],

    ## Associated item environment of the module, used for name resolving.
    _assocTermEnv: HashMap[Str, HashMap[Str, AssocVarDefIdx]],

    ## Type environment of the module, used for name resolving.
    _tyEnv: HashMap[Str, TyDefIdx],

    ## Strongly connected component index of the module in the program.
    ## Generated by the dependency analysis.
    _sccIdx: Option[U32],
)


# ------------------------------------------------------------------------------
# Function items


#[derive(ToDoc)]
type VarDefIdx:
    Local
    Top(TopVarDefIdx)


impl Eq[VarDefIdx]:
    __eq(self: VarDefIdx, other: VarDefIdx) Bool:
        match (left = self, right = other):
            (left = VarDefIdx.Local, right = VarDefIdx.Local): Bool.True
            (left = VarDefIdx.Top(l1), right = VarDefIdx.Top(r1)): l1 == r1
            _: Bool.False


#[derive(ToDoc)]
type TopVarDefIdx(
    ## Module of the variable.
    _mod: ModuleIdx,

    ## Name of the variable in the module.
    ##
    ## This name can be different than the use site name.
    _name: Str,
)


impl Eq[TopVarDefIdx]:
    __eq(self: TopVarDefIdx, other: TopVarDefIdx) Bool:
        self._mod == other._mod and self._name == other._name


#[derive(ToDoc)]
type AssocVarDefIdx(
    ## Module of the type.
    ##
    ## Note: both the type and the associated function definition need to be in
    ## the same module, which should also be the type's module. (mainly to keep
    ## things simple)
    _mod: ModuleIdx,

    ## Name of the associated function's type in `_tyModule`.
    _tyName: Str,

    ## Name of the associated function in `_varModule`.
    _varName: Str,
)


impl Eq[AssocVarDefIdx]:
    __eq(self: AssocVarDefIdx, other: AssocVarDefIdx) Bool:
        self._mod == other._mod
            and self._tyName == other._tyName
            and self._varName == other._varName


# ------------------------------------------------------------------------------
# Type items


#[derive(ToDoc)]
type TyDefIdx:
    Trait(TraitDefIdx)
    Type(TyDefIdx_)


impl Eq[TyDefIdx]:
    __eq(self: TyDefIdx, other: TyDefIdx) Bool:
        match (left = self, right = other):
            (left = TyDefIdx.Trait(l1), right = TyDefIdx.Trait(r1)): l1 == r1
            (left = TyDefIdx.Type(l1), right = TyDefIdx.Type(r1)): l1 == r1
            _: Bool.False


#[derive(ToDoc)]
type TraitDefIdx(
    ## The trait's module.
    _mod: ModuleIdx,

    ## Name of the trait in `_mod`.
    _name: Str,
)


impl Eq[TraitDefIdx]:
    __eq(self: TraitDefIdx, other: TraitDefIdx) Bool:
        self._mod == other._mod and self._name == other._name


#[derive(ToDoc)]
type TyDefIdx_(
    ## The type's module.
    _mod: ModuleIdx,

    ## Name of the type in `_mod`.
    _name: Str,
)


impl Eq[TyDefIdx_]:
    __eq(self: TyDefIdx_, other: TyDefIdx_) Bool:
        self._mod == other._mod and self._name == other._name


# ------------------------------------------------------------------------------


impl ToDoc[VarId]:
    toDoc(self: VarId) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("token =")
                + Doc.nested(4, Doc.break_(1) + self.token.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_resolved =")
                + Doc.nested(4, Doc.break_(1) + self._resolved.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("VarId") + Doc.char('(') + args)


impl ToDoc[AssocVarId]:
    toDoc(self: AssocVarId) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("token =")
                + Doc.nested(4, Doc.break_(1) + self.token.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_resolved =")
                + Doc.nested(4, Doc.break_(1) + self._resolved.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("AssocVarId") + Doc.char('(') + args)


impl ToDoc[TyId]:
    toDoc(self: TyId) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("token =")
                + Doc.nested(4, Doc.break_(1) + self.token.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_resolved =")
                + Doc.nested(4, Doc.break_(1) + self._resolved.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("TyId") + Doc.char('(') + args)


impl ToDoc[PackageUri]:
    toDoc(self: PackageUri) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("_uri =") + Doc.nested(4, Doc.break_(1) + self._uri.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("PackageUri") + Doc.char('(') + args)


impl ToDoc[ModuleIdx]:
    toDoc(self: ModuleIdx) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("_idx =") + Doc.nested(4, Doc.break_(1) + self._idx.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("ModuleIdx") + Doc.char('(') + args)


impl ToDoc[Module]:
    toDoc(self: Module) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("_package =")
                + Doc.nested(4, Doc.break_(1) + self._package.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_path =")
                + Doc.nested(4, Doc.break_(1) + self._path.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_idx =") + Doc.nested(4, Doc.break_(1) + self._idx.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_funItems =")
                + Doc.nested(4, Doc.break_(1) + self._funItems.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_assocItems =")
                + Doc.nested(4, Doc.break_(1) + self._assocItems.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_tyItems =")
                + Doc.nested(4, Doc.break_(1) + self._tyItems.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_traitItems =")
                + Doc.nested(4, Doc.break_(1) + self._traitItems.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_impls =")
                + Doc.nested(4, Doc.break_(1) + self._impls.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_imports =")
                + Doc.nested(4, Doc.break_(1) + self._imports.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_tokens =")
                + Doc.nested(4, Doc.break_(1) + self._tokens.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_termEnv =")
                + Doc.nested(4, Doc.break_(1) + self._termEnv.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_assocTermEnv =")
                + Doc.nested(4, Doc.break_(1) + self._assocTermEnv.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_tyEnv =")
                + Doc.nested(4, Doc.break_(1) + self._tyEnv.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_sccIdx =")
                + Doc.nested(4, Doc.break_(1) + self._sccIdx.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("Module") + Doc.char('(') + args)


impl ToDoc[VarDefIdx]:
    toDoc(self: VarDefIdx) Doc:
        match self:
            VarDefIdx.Local: Doc.str("VarDefIdx.Local")
            VarDefIdx.Top(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("VarDefIdx.Top") + Doc.char('(') + args)


impl ToDoc[TopVarDefIdx]:
    toDoc(self: TopVarDefIdx) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("_mod =") + Doc.nested(4, Doc.break_(1) + self._mod.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_name =")
                + Doc.nested(4, Doc.break_(1) + self._name.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("TopVarDefIdx") + Doc.char('(') + args)


impl ToDoc[AssocVarDefIdx]:
    toDoc(self: AssocVarDefIdx) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("_mod =") + Doc.nested(4, Doc.break_(1) + self._mod.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_tyName =")
                + Doc.nested(4, Doc.break_(1) + self._tyName.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_varName =")
                + Doc.nested(4, Doc.break_(1) + self._varName.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("AssocVarDefIdx") + Doc.char('(') + args)


impl ToDoc[TyDefIdx]:
    toDoc(self: TyDefIdx) Doc:
        match self:
            TyDefIdx.Trait(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("TyDefIdx.Trait") + Doc.char('(') + args)
            TyDefIdx.Type(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("TyDefIdx.Type") + Doc.char('(') + args)


impl ToDoc[TraitDefIdx]:
    toDoc(self: TraitDefIdx) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("_mod =") + Doc.nested(4, Doc.break_(1) + self._mod.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_name =")
                + Doc.nested(4, Doc.break_(1) + self._name.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("TraitDefIdx") + Doc.char('(') + args)


impl ToDoc[TyDefIdx_]:
    toDoc(self: TyDefIdx_) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("_mod =") + Doc.nested(4, Doc.break_(1) + self._mod.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_name =")
                + Doc.nested(4, Doc.break_(1) + self._name.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("TyDefIdx_") + Doc.char('(') + args)
