import [
    Compiler/Ast,
    Compiler/TypeCheck/Error,
    Compiler/TypeCheck/Ty,
    Compiler/TypeCheck/TyMap,
]


convertAstTy(module: Module, tys: TyMap, astTy: Type, loc: Loc) Ty / TypeError:
    match astTy:
        Type.Named(namedTy): convertNamedTy(module, tys, namedTy, loc)

        Type.Var(var_):
            let varText = module.idText(var_)
            tys.getVar(varText).unwrapOrElse(
                ||:
                    throw(
                        TypeError(loc, msg = "Unbound type variable `varText`",),
                    ),
            )

        Type.Record(RecordType(fields, extension, isRow, ..)):
            let labels: HashMap[LocalId, Ty] = HashMap.withCapacity(fields.len())

            for namedField: Named[Type] in fields.iter():
                let name = module.idText(
                    namedField.name.unwrapOrElse(
                        ||:
                            throw(
                                TypeError(
                                    loc,
                                    msg =
                                        "Records with unnamed fields not supported yet",
                                ),
                            ),
                    ),
                )
                let ty = convertAstTy(module, tys, namedField.node, loc)
                let old = labels.insert(LocalId(name), ty)
                if old is Option.Some(_):
                    throw(
                        TypeError(
                            loc,
                            msg =
                                "Field `name` defined multiple times in record",
                        ),
                    )

            let extension = extension.map(
                |extId|:
                    let extIdText = module.idText(extId)
                    tys.getVar(extIdText).unwrapOrElse(
                        ||:
                            throw(
                                TypeError(
                                    loc,
                                    msg = "Unbound type variable `extIdText`",
                                ),
                            ),
                    ),
            )

            Ty.Anonymous(labels, extension, kind = RecordOrVariant.Record, isRow)

        Type.Variant(VariantType(alts, extension, isRow, ..)):
            let labels: HashMap[LocalId, Ty] = HashMap.withCapacity(alts.len())

            for alt: NamedType in alts.iter():
                let ty = convertNamedTy(module, tys, alt, loc)
                let tyNameText = alt.name.name
                let old = labels.insert(LocalId(name = tyNameText), ty)
                if old is Option.Some(_):
                    throw(
                        TypeError(
                            loc,
                            msg =
                                "Type `tyNameText` used multiple times in variant type",
                        ),
                    )

            let extension = extension.map(
                |extId|:
                    let extIdText = module.idText(extId)
                    tys.getVar(extIdText).unwrapOrElse(
                        ||:
                            throw(
                                TypeError(
                                    loc,
                                    msg = "Unbound type variable `extIdText`",
                                ),
                            ),
                    ),
            )

            Ty.Anonymous(
                labels,
                extension,
                kind = RecordOrVariant.Variant,
                isRow,
            )

        Type.Fn_(FnType(args, ret, exceptions, ..)):
            let args = FunArgs.Positional(
                Vec.fromIter(
                    args.iter().map(
                        |ty: Type| Ty: convertAstTy(module, tys, ty, loc),
                    ),
                ),
            )

            let ret = match ret:
                Option.None: Ty.unit()
                Option.Some(ret): convertAstTy(module, tys, ret, loc)

            let exceptions = exceptions.unwrapOrElse(
                ||:
                    throw(
                        TypeError(
                            loc,
                            msg = "Function type without exception type",
                        ),
                    ),
            )

            let exceptions = convertAstTy(module, tys, exceptions, loc)

            Ty.Fun(args, ret, exn = Option.Some(exceptions))


convertNamedTy(module: Module, tys: TyMap, namedTy: NamedType, loc: Loc) Ty / TypeError:
    let tyName = namedTy.name.name
    let tyArgs = namedTy.args
    let numTyArgs = namedTy.numTyArgs()

    let tyCon = tys.getCon(tyName).unwrapOrElse(
        ||: throw(TypeError(loc, msg = "Unknown type `tyName`")),
    )

    if tyCon.arity() != numTyArgs:
        throw(
            TypeError(
                loc,
                msg =
                    "Incorrect number of type arguments to `tyName`, expected `tyCon.arity()`, found `numTyArgs`",
            ),
        )

    if numTyArgs == 0:
        return Ty.Con(id = namedTy.name)

    let convertedArgs: Vec[Ty] = Vec.fromIter(
        tyArgs.unwrap().args.iter().map(
            |astTy: Type| Ty: convertAstTy(module, tys, astTy, loc),
        ),
    )

    Ty.App(conId = namedTy.name, args = convertedArgs)
