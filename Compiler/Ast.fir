import [
    Compiler/Defs,
    Compiler/Token,
]


trait Tokens[t]:
    firstToken(self: t, tokens: Array[Token]) TokenIdx

    lastToken(self: t, tokens: Array[Token]) TokenIdx


#[derive(ToDoc)]
type Id(
    token: TokenIdx,
)


impl Tokens[Id]:
    firstToken(self: Id, tokens: Array[Token]) TokenIdx:
        self.token

    lastToken(self: Id, tokens: Array[Token]) TokenIdx:
        self.token


## A top-level declaration.
#[derive(ToDoc)]
type TopDecl:
    ## A type declaration: `type T: ...`.
    Type(TypeDecl)

    ## A function declaration: `f(...) = ...`.
    Fun(FunDecl)

    ## An import declaration.
    Import(ImportDecl)

    ## A trait declaration.
    Trait(TraitDecl)

    ## An `impl` block, implementing a trait or associated methods for a type.
    Impl(ImplDecl)


## A type declaration: `type Vec[t]: ...`.
#[derive(ToDoc)]
type TypeDecl(
    ## When the type is a primitive, the `prim` token.
    prim_: Option[TokenIdx],

    ## The type name. `Vec` in the example.
    name: Id,

    ## Type parameters of the type. `[t]` in the example.
    typeParams: Vec[Id],

    ## Kinds of `type_params`. Filled in by kind inference.
    typeParamKinds: Vec[Kind],

    ## Constructors of the type.
    rhs: Option[TypeDeclRhs],
)


impl Tokens[TypeDecl]:
    firstToken(self: TypeDecl, tokens: Array[Token]) TokenIdx:
        self.prim_.unwrapOr(self.name.token)

    lastToken(self: TypeDecl, tokens: Array[Token]) TokenIdx:
        panic("TOOD")


## Constructors of a type declaration.
#[derive(ToDoc)]
type TypeDeclRhs:
    ## A sum type, with more than one constructor.
    Sum(Vec[ConDecl])

    ## A product type uses the type name as the constructor and only has fields.
    Product(ConFields)


## A sum type constructor.
#[derive(ToDoc)]
type ConDecl(
    name: Id,
    fields: ConFields,
    _lastToken: TokenIdx,
)


impl Tokens[ConDecl]:
    firstToken(self: ConDecl, tokens: Array[Token]) TokenIdx:
        self.name.token

    lastToken(self: ConDecl, tokens: Array[Token]) TokenIdx:
        self._lastToken


#[derive(ToDoc)]
type ConFields:
    Empty
    Named(Vec[NamedField])
    Unnamed(Vec[Type])


#[derive(ToDoc)]
type NamedField(
    name: Id,
    ty: Type,
)


#[derive(ToDoc)]
type FunDecl(
    ## When the function is a primitive, the `prim` token.
    prim_: Option[TokenIdx],

    ## Only in associated functions: the parent type. E.g. `Vec` in `Vec.push(...): ...`.
    parentTy: Option[TyId],

    ## Name of the function.
    name: Id,

    ## Type signature of the function.
    sig: FunSig,

    ## Body (code) of the function. Not available in `prim` functions.
    body: Option[Vec[Stmt]],
)


impl Tokens[FunDecl]:
    firstToken(self: FunDecl, tokens: Array[Token]) TokenIdx:
        if self.prim_ is Option.Some(t):
            return t

        if self.parentTy is Option.Some(tyId):
            return tyId.token

        self.name.token

    lastToken(self: FunDecl, tokens: Array[Token]) TokenIdx:
        match self.body:
            Option.Some(stmts): stmts.last().unwrap().lastToken(tokens)
            Option.None: self.sig.lastToken(tokens)


#[derive(ToDoc)]
type FunSig(
    ## Type parameters, generated by the type checker.
    typeParams: Vec[TypeParam],

    context: Option[Context],
    self_: SelfParam,
    params: Vec[FunArg],
    returnTy: Option[Type],
    exceptions: Option[Type],

    ## The '(' token of the argument list. We need to store at least one token
    ## in this node as the minimal node (without context, with empty argument
    ## list, and without return or exception types) won't have any other AST
    ## nodes.
    lparen: TokenIdx,
)


impl Tokens[FunSig]:
    firstToken(self: FunSig, tokens: Array[Token]) TokenIdx:
        if self.context is Option.Some(context):
            return context.firstToken(tokens)

        self.lparen

    lastToken(self: FunSig, tokens: Array[Token]) TokenIdx:
        if self.exceptions is Option.Some(exceptions):
            return exceptions.lastToken(tokens)

        if self.returnTy is Option.Some(returnTy):
            return returnTy.lastToken(tokens)

        let token = self.params.last().map(
            \(lastParam): lastParam.lastToken(tokens),
        ).unwrapOr(self.lparen)

        let rparen = nextNonTrivia(token, tokens).unwrap()
        assert(tokens.get(rparen.idx).kind is TokenKind.RParen)

        rparen


#[derive(ToDoc)]
type FunArg(
    name: Id,
    ty: Option[Type],
)


impl Tokens[FunArg]:
    firstToken(self: FunArg, tokens: Array[Token]) TokenIdx:
        self.name.token

    lastToken(self: FunArg, tokens: Array[Token]) TokenIdx:
        self.ty.map(\(ty): ty.lastToken(tokens)).unwrapOr(self.name.token)


#[derive(ToDoc)]
type SelfParam:
    No
    Implicit
    Explicit(Type)


#[derive(ToDoc)]
type ImportDecl(
    ## Import paths, e.g. `[Fir/Prelude, Compiler/Parser]`.
    paths: Vec[Vec[Id]],
)


#[derive(ToDoc)]
type TraitDecl(
    ## Trait name.
    name: Id,

    ## Type parameters of the trait.
    typeParams: Vec[Id],

    ## Kinds of `type_params`. Filled in by kind inference.
    typeParamKinds: Vec[Kind],

    ## Methods of the trait.
    items: Vec[FunDecl],
)


## An `impl` block, implementing a trait for a type.
##
## ```
## impl[ToStr[a]] ToStr[Vec[a]]:
##   toStr(self) Str: ...
##
## impl Iterator[VecIter[a], a]:
##   next(self) Option[a]: ...
## ```
#[derive(ToDoc)]
type ImplDecl(
    ## Type parameters, generated by the type checker.
    typeParams: Vec[TypeParam],

    ## Predicates of the `impl` block.
    ##
    ## In the example: `[ToStr[a]]`.
    context: Option[Context],

    ## The trait name.
    ##
    ## In the example: `ToStr`.
    trait_: TyId,

    ## Type parameters of the trait.
    ##
    ## In the example: `[Vec[a]]`.
    tys: Vec[Type],

    ## Method implementations.
    items: Vec[FunDecl],

    # The `impl` token.
    _firstToken: TokenIdx,
)


#[derive(ToDoc)]
type Type:
    ## A type constructor, potentially applied some number of arguments. E.g. `I32`, `Vec[T]`.
    Named(NamedType)

    ## A type variable.
    ##
    ## We don't have higher-kinded types for now, so type variables cannot be applied.
    Var(Id)

    ## An anonymous record type, e.g. `(x: I32, y: I32)`, `(a: Str, ..R)`.
    Record(RecordType)

    ## An anonymous variant type, e.g. `[Error(msg: Str), Ok, ..R]`.
    Variant(VariantType)

    ## A function type: `Fn(I32): Bool`.
    Fn_(FnType)


impl Tokens[Type]:
    firstToken(self: Type, tokens: Array[Token]) TokenIdx:
        match self:
            Type.Named(ty): ty.firstToken(tokens)
            Type.Var(id): id.token
            Type.Record(ty): ty.firstToken(tokens)
            Type.Variant(ty): ty.firstToken(tokens)
            Type.Fn_(ty): ty.firstToken(tokens)

    lastToken(self: Type, tokens: Array[Token]) TokenIdx:
        match self:
            Type.Named(ty): ty.lastToken(tokens)
            Type.Var(id): id.token
            Type.Record(ty): ty.lastToken(tokens)
            Type.Variant(ty): ty.lastToken(tokens)
            Type.Fn_(ty): ty.lastToken(tokens)


#[derive(ToDoc)]
type RecordType(
    fields: Vec[Named[Type]],
    extension: Option[Id],
    isRow: Bool,

    # Left paren.
    _firstToken: TokenIdx,

    # Right paren.
    _lastToken: TokenIdx,
)


impl Tokens[RecordType]:
    firstToken(self: RecordType, tokens: Array[Token]) TokenIdx:
        self._firstToken

    lastToken(self: RecordType, tokens: Array[Token]) TokenIdx:
        self._lastToken


#[derive(ToDoc)]
type VariantType(
    alts: Vec[NamedType],
    extension: Option[Id],
    isRow: Bool,

    # Left bracket.
    _firstToken: TokenIdx,

    # Right bracket.
    _lastToken: TokenIdx,
)


impl Tokens[VariantType]:
    firstToken(self: VariantType, tokens: Array[Token]) TokenIdx:
        self._firstToken

    lastToken(self: VariantType, tokens: Array[Token]) TokenIdx:
        self._lastToken


#[derive(ToDoc)]
type FnType(
    args: Vec[Type],

    ## Optional return type of the function.
    ret: Option[Type],

    ## Same as `FunSig.exceptions`.
    exceptions: Option[Type],

    # The 'Fn' token.
    _firstToken: TokenIdx,

    # The ')' token terminating the argument list. Used as last token when `ret` and `exceptions`
    # are both not available.
    _rparen: TokenIdx,
)


impl Tokens[FnType]:
    firstToken(self: FnType, tokens: Array[Token]) TokenIdx:
        self._firstToken

    lastToken(self: FnType, tokens: Array[Token]) TokenIdx:
        if self.exceptions is Option.Some(ty):
            return ty.lastToken(tokens)

        if self.ret is Option.Some(ty):
            return ty.lastToken(tokens)

        self._rparen


## Type parameter and predicates of an `impl` or function.
##
## E.g. `[Iterator[iter, item], Debug[item]]`.
#[derive(ToDoc)]
type Context(
    ## Predicates: `Iterator[iter, item]` and `Debug[item]` in the example.
    preds: Vec[Type],

    # Left bracket.
    _firstToken: TokenIdx,

    # Right bracket.
    _lastToken: TokenIdx,
)


#[derive(ToDoc)]
type TypeParam(
    name: LocalId,
    kind: Kind,
)


impl Tokens[Context]:
    firstToken(self: Context, tokens: Array[Token]) TokenIdx:
        self._firstToken

    lastToken(self: Context, tokens: Array[Token]) TokenIdx:
        self._lastToken


## A named type, e.g. `I32`, `Vec[I32]`, `Iterator[coll, Str]`.
#[derive(ToDoc)]
type NamedType(
    ## Name of the type constructor, e.g. `I32`, `Vec`, `Iterator`.
    name: TyId,

    ## Arguments of the type constructor.
    args: Option[TyArgs],
)


NamedType.numTyArgs(self) U32:
    match self.args:
        Option.None: 0
        Option.Some(args): args.args.len()


impl Tokens[NamedType]:
    firstToken(self: NamedType, tokens: Array[Token]) TokenIdx:
        self.name.token

    lastToken(self: NamedType, tokens: Array[Token]) TokenIdx:
        match self.args:
            Option.Some(args): args.lastToken(tokens)
            Option.None: self.name.token


#[derive(ToDoc)]
type Named[t](
    name: Option[Id],
    node: t,
)


impl[Tokens[t]] Tokens[Named[t]]:
    firstToken(self: Named[t], tokens: Array[Token]) TokenIdx:
        match self.name:
            Option.Some(name): name.token
            Option.None: self.node.firstToken(tokens)

    lastToken(self: Named[t], tokens: Array[Token]) TokenIdx:
        self.node.lastToken(tokens)


#[derive(ToDoc)]
type Stmt:
    Let(LetStmt)
    Assign(AssignStmt)
    Expr(Expr)
    For(ForStmt)
    While(WhileStmt)
    Loop(LoopStmt)
    Break(BreakStmt)
    Continue(ContinueStmt)


impl Tokens[Stmt]:
    firstToken(self: Stmt, tokens: Array[Token]) TokenIdx:
        match self:
            Stmt.Let(e): e.firstToken(tokens)
            Stmt.Assign(e): e.firstToken(tokens)
            Stmt.Expr(e): e.firstToken(tokens)
            Stmt.For(e): e.firstToken(tokens)
            Stmt.While(e): e.firstToken(tokens)
            Stmt.Loop(e): e.firstToken(tokens)
            Stmt.Break(e): e.firstToken(tokens)
            Stmt.Continue(e): e.firstToken(tokens)

    lastToken(self: Stmt, tokens: Array[Token]) TokenIdx:
        match self:
            Stmt.Let(e): e.lastToken(tokens)
            Stmt.Assign(e): e.lastToken(tokens)
            Stmt.Expr(e): e.lastToken(tokens)
            Stmt.For(e): e.lastToken(tokens)
            Stmt.While(e): e.lastToken(tokens)
            Stmt.Loop(e): e.lastToken(tokens)
            Stmt.Break(e): e.lastToken(tokens)
            Stmt.Continue(e): e.lastToken(tokens)


## A let statement: `let x: T = expr`.
#[derive(ToDoc)]
type LetStmt(
    lhs: Pat,
    ty: Option[Type],
    rhs: Expr,
    _firstToken: TokenIdx,
)


impl Tokens[LetStmt]:
    firstToken(self: LetStmt, tokens: Array[Token]) TokenIdx:
        self._firstToken

    lastToken(self: LetStmt, tokens: Array[Token]) TokenIdx:
        self.rhs.lastToken(tokens)


#[derive(ToDoc)]
type AssignStmt(
    lhs: Expr,
    rhs: Expr,
    op: AssignOp,
)


impl Tokens[AssignStmt]:
    firstToken(self: AssignStmt, tokens: Array[Token]) TokenIdx:
        self.lhs.firstToken(tokens)

    lastToken(self: AssignStmt, tokens: Array[Token]) TokenIdx:
        self.rhs.lastToken(tokens)


#[derive(ToDoc)]
type AssignOp:
    Eq
    PlusEq
    MinusEq
    StarEq
    CaretEq


#[derive(ToDoc)]
type ForStmt(
    label: Option[Id],
    pat: Pat,

    ## Type annotation on the loop variable, the `item` type in `Iterator[iter, item]`.
    astTy: Option[Type],

    ## `ast_ty`, converted to type checking types by the type checker.
    tcTy: Option[Ty],

    expr: Expr,

    ## Filled in by the type checker: the iterator type. `iter` in `Iterator[iter, item]`.
    exprTy: Option[Ty],

    body: Vec[Stmt],

    _firstToken: TokenIdx,
)


impl Tokens[ForStmt]:
    firstToken(self: ForStmt, tokens: Array[Token]) TokenIdx:
        self._firstToken

    lastToken(self: ForStmt, tokens: Array[Token]) TokenIdx:
        self.body.last().unwrap().lastToken(tokens)


#[derive(ToDoc)]
type WhileStmt(
    label: Option[Id],
    cond: Expr,
    body: Vec[Stmt],
    _firstToken: TokenIdx,
)


impl Tokens[WhileStmt]:
    firstToken(self: WhileStmt, tokens: Array[Token]) TokenIdx:
        self._firstToken

    lastToken(self: WhileStmt, tokens: Array[Token]) TokenIdx:
        self.body.last().unwrap().lastToken(tokens)


#[derive(ToDoc)]
type LoopStmt(
    body: Vec[Stmt],
    _firstToken: TokenIdx,
)


impl Tokens[LoopStmt]:
    firstToken(self: LoopStmt, tokens: Array[Token]) TokenIdx:
        self._firstToken

    lastToken(self: LoopStmt, tokens: Array[Token]) TokenIdx:
        self.body.last().unwrap().lastToken(tokens)


#[derive(ToDoc)]
type BreakStmt(
    label: Option[Id],

    ## How many levels of loops to break. Parser initializes this as 0, type checker updates
    ## based on the labels of enclosing loops.
    level: U32,

    _firstToken: TokenIdx,
)


impl Tokens[BreakStmt]:
    firstToken(self: BreakStmt, tokens: Array[Token]) TokenIdx:
        self._firstToken

    lastToken(self: BreakStmt, tokens: Array[Token]) TokenIdx:
        match self.label:
            Option.Some(id): id.lastToken(tokens)
            Option.None: self._firstToken


#[derive(ToDoc)]
type ContinueStmt(
    label: Option[Id],

    ## Same as `BreakStmt.level`.
    level: U32,

    _firstToken: TokenIdx,
)


impl Tokens[ContinueStmt]:
    firstToken(self: ContinueStmt, tokens: Array[Token]) TokenIdx:
        self._firstToken

    lastToken(self: ContinueStmt, tokens: Array[Token]) TokenIdx:
        match self.label:
            Option.Some(id): id.lastToken(tokens)
            Option.None: self._firstToken


#[derive(ToDoc)]
type Pat:
    ## Matches anything, binds it to variable.
    Var(VarPat)

    ## Matches a constructor.
    Con(ConPat)

    Record(RecordPat)

    ## Underscore, aka. wildcard.
    Ignore(TokenIdx)

    ## Matches the string.
    Str(Str, TokenIdx)

    ## Matches the character.
    Char(Char, TokenIdx)

    ## Or pattern: `<pat1> | <pat2> | ...`. At least two patterns.
    Or(Vec[Pat])

    ## Variant pattern: `~"hi"`, `~Option.Some(_)`.
    Variant(Pat)


impl Tokens[Pat]:
    firstToken(self: Pat, tokens: Array[Token]) TokenIdx:
        match self:
            Pat.Var(pat): pat.firstToken(tokens)

            Pat.Con(pat): pat.firstToken(tokens)

            Pat.Record(pat): pat.firstToken(tokens)

            Pat.Ignore(tok) | Pat.Str(_, tok) | Pat.Char(_, tok): tok

            Pat.Or(ps): ps.get(0).firstToken(tokens)

            Pat.Variant(pat): pat.firstToken(tokens)

    lastToken(self: Pat, tokens: Array[Token]) TokenIdx:
        match self:
            Pat.Var(pat): pat.lastToken(tokens)

            Pat.Con(pat): pat.lastToken(tokens)

            Pat.Record(pat): pat.lastToken(tokens)

            Pat.Ignore(tok) | Pat.Char(_, tok): tok

            # A string pattern is always a `BEGIN_STR` and `END_STR`,
            # interpolation not allowed.
            Pat.Str(_, tok): TokenIdx(idx = tok.idx + 1)

            Pat.Or(ps): ps.last().unwrap().lastToken(tokens)

            Pat.Variant(pat): pat.lastToken(tokens)


#[derive(ToDoc)]
type VarPat(
    var_: Id,

    ## Inferred type of the binder. Filled in by the type checker.
    ty: Option[Ty],
)


impl Tokens[VarPat]:
    firstToken(self: VarPat, tokens: Array[Token]) TokenIdx:
        self.var_.firstToken(tokens)

    lastToken(self: VarPat, tokens: Array[Token]) TokenIdx:
        self.var_.lastToken(tokens)


#[derive(ToDoc)]
type ConPat(
    con: Con,
    fields: Vec[Named[Pat]],
    ignoreRest: Bool,
    _lastToken: TokenIdx,
)


impl Tokens[ConPat]:
    firstToken(self: ConPat, tokens: Array[Token]) TokenIdx:
        self.con.firstToken(tokens)

    lastToken(self: ConPat, tokens: Array[Token]) TokenIdx:
        self._lastToken


#[derive(ToDoc)]
type RecordPat(
    fields: Vec[Named[Pat]],
    ignoreRest: Bool,
    inferredTy: Option[Ty],
    _firstToken: TokenIdx,
    _lastToken: TokenIdx,
)


impl Tokens[RecordPat]:
    firstToken(self: RecordPat, tokens: Array[Token]) TokenIdx:
        self._firstToken

    lastToken(self: RecordPat, tokens: Array[Token]) TokenIdx:
        self._lastToken


## A sum or product constructor, in patterns and expressions.
#[derive(ToDoc)]
type Con(
    ## Type of the constructor.
    ty: TyId,

    ## Name of the constructor. Only in sum types.
    con: Option[Id],

    ## Type arguments explicitly passed to the variable.
    ##
    ## Always `Option.None` in patterns.
    userTyArgs: Option[TyArgs],

    ## Inferred type arguments of the constructor's type. Filled in by the type checker.
    tyArgs: Vec[Type],

    # In variant constructors we'll see a '~' before `ty`, so we can't use `ty` as the first token.
    _firstToken: TokenIdx,
)


impl Tokens[Con]:
    firstToken(self: Con, tokens: Array[Token]) TokenIdx:
        self._firstToken

    lastToken(self: Con, tokens: Array[Token]) TokenIdx:
        match self.userTyArgs:
            Option.Some(tyArgs): tyArgs.lastToken(tokens)
            Option.None:
                match self.con:
                    Option.Some(con): con.token
                    Option.None: self.ty.token


#[derive(ToDoc)]
type Expr:
    ## A variable: `x`.
    Var(VarExpr)

    ## A constructor: `Option.None`, `Result.Ok`, `Bool.True`, `Vec`.
    ConSel(Con)

    ## A field selection: `<expr>.x` where `x` is a field.
    ##
    ## Parser generates this node for all expression of form `<expr>.<id>`, type checker converts
    ## method selection expressions to `MethodSel`.
    FieldSel(FieldSelExpr)

    ## A method selection: `<expr>.x` where `x` is a method.
    ##
    ## This node is generated by the type checker.
    MethodSel(MethodSelExpr)

    ## An associated function or method selection:
    ##
    ## - Associated function: `Vec.withCapacity`.
    ## - Method: `Vec.push`.
    AssocFnSel(AssocFnSelExpr)

    ## A function call: `f(a)`.
    Call(CallExpr)

    ## An integer literal.
    Int(IntExpr)

    ## A string literal.
    Str(StrExpr)

    ## A character literal.
    Char(CharExpr)

    Self(TokenIdx)

    ## A binary operator: `x + y`, `i >> 2`.
    ##
    ## Some of the binary operators are desugared to method calls by the type checker.
    BinOp(BinOpExpr)

    ## A unary operator: `-x`, `not b`.
    ##
    ## Some of the unary operators are desugared to method calls by the type checker.
    UnOp(UnOpExpr)

    ## A record: `(1, 2)`, `(x = 123, msg = "hi")`.
    Record(RecordExpr)

    Return(ReturnExpr)

    Match(MatchExpr)

    If(IfExpr)

    Fn_(FnExpr)

    Is(IsExpr)

    Do(DoExpr)

    # A sequence: `[a, b, c]`, `[a = b, c = d]`, `Vec.[...]`. Can be empty.
    Seq(SeqExpr)

    # A parenthesized expression.
    Paren(ParenExpr)

    # A variant: `~"hi"`, `Option.Some(123)`.
    Variant(Expr)


impl Tokens[Expr]:
    firstToken(self: Expr, tokens: Array[Token]) TokenIdx:
        match self:
            Expr.Var(e): e.firstToken(tokens)
            Expr.ConSel(e): e.firstToken(tokens)
            Expr.FieldSel(e): e.firstToken(tokens)
            Expr.MethodSel(e): e.firstToken(tokens)
            Expr.AssocFnSel(e): e.firstToken(tokens)
            Expr.Call(e): e.firstToken(tokens)
            Expr.Int(e): e.firstToken(tokens)
            Expr.Str(e): e.firstToken(tokens)
            Expr.Char(e): e.firstToken(tokens)
            Expr.Self(t): t
            Expr.BinOp(e): e.firstToken(tokens)
            Expr.UnOp(e): e.firstToken(tokens)
            Expr.Record(e): e.firstToken(tokens)
            Expr.Return(e): e.firstToken(tokens)
            Expr.Match(e): e.firstToken(tokens)
            Expr.If(e): e.firstToken(tokens)
            Expr.Fn_(e): e.firstToken(tokens)
            Expr.Is(e): e.firstToken(tokens)
            Expr.Do(e): e.firstToken(tokens)
            Expr.Seq(e): e.firstToken(tokens)
            Expr.Paren(e): e.firstToken(tokens)
            Expr.Variant(e): e.firstToken(tokens)

    lastToken(self: Expr, tokens: Array[Token]) TokenIdx:
        match self:
            Expr.Var(e): e.lastToken(tokens)
            Expr.ConSel(e): e.lastToken(tokens)
            Expr.FieldSel(e): e.lastToken(tokens)
            Expr.MethodSel(e): e.lastToken(tokens)
            Expr.AssocFnSel(e): e.lastToken(tokens)
            Expr.Call(e): e.lastToken(tokens)
            Expr.Int(e): e.lastToken(tokens)
            Expr.Str(e): e.lastToken(tokens)
            Expr.Char(e): e.lastToken(tokens)
            Expr.Self(t): t
            Expr.BinOp(e): e.lastToken(tokens)
            Expr.UnOp(e): e.lastToken(tokens)
            Expr.Record(e): e.lastToken(tokens)
            Expr.Return(e): e.lastToken(tokens)
            Expr.Match(e): e.lastToken(tokens)
            Expr.If(e): e.lastToken(tokens)
            Expr.Fn_(e): e.lastToken(tokens)
            Expr.Is(e): e.lastToken(tokens)
            Expr.Do(e): e.lastToken(tokens)
            Expr.Seq(e): e.lastToken(tokens)
            Expr.Paren(e): e.lastToken(tokens)
            Expr.Variant(e): e.lastToken(tokens)


#[derive(ToDoc)]
type VarExpr(
    id: VarId,

    # Type arguments explicitly passed to the variable.
    userTyArgs: Option[TyArgs],

    ## Inferred type arguments of the variable. Filled in by the type checker.
    tyArgs: Vec[Type],
)


impl Tokens[VarExpr]:
    firstToken(self: VarExpr, tokens: Array[Token]) TokenIdx:
        self.id.token

    lastToken(self: VarExpr, tokens: Array[Token]) TokenIdx:
        match self.userTyArgs:
            Option.Some(tyArgs): tyArgs.lastToken(tokens)
            Option.None: self.id.token


#[derive(ToDoc)]
type TyArgs(
    args: Vec[Type],

    # Left bracket.
    _firstToken: TokenIdx,

    # Right bracket.
    _lastToken: TokenIdx,
)


impl Tokens[TyArgs]:
    firstToken(self: TyArgs, tokens: Array[Token]) TokenIdx:
        self._firstToken

    lastToken(self: TyArgs, tokens: Array[Token]) TokenIdx:
        self._lastToken


#[derive(ToDoc)]
type FieldSelExpr(
    object: Expr,

    field: Id,

    ## Type arguments explicitly passed to the variable.
    ##
    ## Since fields can't have `forall` quantifiers, this will only be valid when the field is a
    ## method, in which case the type checker will convert this node into `MethodSelExpr`.
    userTyArgs: Option[TyArgs],
)


impl Tokens[FieldSelExpr]:
    firstToken(self: FieldSelExpr, tokens: Array[Token]) TokenIdx:
        self.object.firstToken(tokens)

    lastToken(self: FieldSelExpr, tokens: Array[Token]) TokenIdx:
        match self.userTyArgs:
            Option.Some(tyArgs): tyArgs.lastToken(tokens)
            Option.None: self.field.lastToken(tokens)


## A method selection: `<expr>.method`.
##
## This node is generated by the type checker, from `Expr::FieldSel`.
##
## Methods are always associated functions. They can be associated to a type (e.g. `Vec.push`) or
## trait methods (e.g. `Iterator.next`).
#[derive(ToDoc)]
type MethodSelExpr(
    ## The reciever, `<expr>` in `<expr>.method`.
    object: Expr,

    ## Type of `object` (receiver), filled in by the type checker.
    ##
    ## This type will always be a type constructor, potentially with arguments, as types without
    ## type constructors (records etc.) don't have methods.
    ##
    ## The type constructor will be the type with the associated function with `method` as the name
    ## and a `self` parameter that matches this type.
    # TODO: We could have separate fields for the ty con and args.
    # TODO: We could also add types to every expression if it's going to help with monomorphisation.
    #       For efficiency though, we should only annotate inferred types and then type check from
    #       the top-level expression every time we need to compute type of an expr.
    objectTy: Option[Ty],

    ## The type or trait id that defines the method.
    ##
    ## E.g. `Vec`, `Iterator`.
    ##
    ## Note: when calling trait methods, this will be the trait type rather than the receiver type.
    methodTyId: TyId,

    ## The method id.
    ##
    ## E.g. `push`, `next`.
    method: AssocVarId,

    ## Type arguments of `method_ty_id`.
    ##
    ## If the method is for a trait, the first arguments here will be for the
    ## trait type parameters. E.g. in `Iterator.next`, the first two argumetns
    ## will be the `iter` and `item` parameters of `trait Iterator[iter, item]`.
    ##
    ## (If the method is not a trait method, then we don't care about the type
    ## parameter order.. I think?)
    tyArgs: Vec[Ty],

    _lastToken: TokenIdx,
)


impl Tokens[MethodSelExpr]:
    firstToken(self: MethodSelExpr, tokens: Array[Token]) TokenIdx:
        self.object.firstToken(tokens)

    lastToken(self: MethodSelExpr, tokens: Array[Token]) TokenIdx:
        self._lastToken


## An associated function or method selection:
##
## - Associated function: `Vec.withCapacity`.
## - Method: `Vec.push`.
#[derive(ToDoc)]
type AssocFnSelExpr(
    # The type of the associated function: `Vec` in the examples above.
    ty: TyId,

    # The associated function name: `withCapacity` and `push` in the examples
    # above.
    member: AssocVarId,

    ## Type arguments explicitly passed to the variable.
    userTyArgs: Option[TyArgs],

    ## Inferred type arguments of the type and associated function. Filled in by
    ## the type checker.
    tyArgs: Vec[Ty],

    _lastToken: TokenIdx,
)


impl Tokens[AssocFnSelExpr]:
    firstToken(self: AssocFnSelExpr, tokens: Array[Token]) TokenIdx:
        self.ty.token

    lastToken(self: AssocFnSelExpr, tokens: Array[Token]) TokenIdx:
        self._lastToken


#[derive(ToDoc)]
type CallExpr(
    fun: Expr,
    args: Vec[Named[Expr]],
    _lastToken: TokenIdx,
)


impl Tokens[CallExpr]:
    firstToken(self: CallExpr, tokens: Array[Token]) TokenIdx:
        self.fun.firstToken(tokens)

    lastToken(self: CallExpr, tokens: Array[Token]) TokenIdx:
        self._lastToken


#[derive(ToDoc)]
type IntExpr(
    ## The digits of the integer, without any prefix ("0x" or "0b") and suffix ("u32" etc.).
    ##
    ## The digits will be parsed during type checking. If the integer doesn't have a suffix, parsing
    ## will be done based on the inferred type of the integer.
    text: Str,

    ## The type checker updates this based on the inferred type of the integer.
    suffix: Option[IntKind],

    radix: U32,

    ## Filled in by the type checker. The parsed integer.
    ##
    ## This will be the integer value in two's complement, extended to unsiged 32-bit.
    ## E.g. `-1u8` will be `0x000000ff`, instead of `0xffffffff`.
    parsed: U32,

    token: TokenIdx,
)


impl Tokens[IntExpr]:
    firstToken(self: IntExpr, tokens: Array[Token]) TokenIdx:
        self.token

    lastToken(self: IntExpr, tokens: Array[Token]) TokenIdx:
        self.token


#[derive(ToDoc)]
type StrExpr(
    parts: Vec[StrPart],
    first: TokenIdx,
    last: TokenIdx,
)


impl Tokens[StrExpr]:
    firstToken(self: StrExpr, tokens: Array[Token]) TokenIdx:
        self.first

    lastToken(self: StrExpr, tokens: Array[Token]) TokenIdx:
        self.last


#[derive(ToDoc)]
type StrPart:
    Str(Str)
    Expr(Expr)


#[derive(ToDoc)]
type CharExpr(
    char: Char,
    token: TokenIdx,
)


impl Tokens[CharExpr]:
    firstToken(self: CharExpr, tokens: Array[Token]) TokenIdx:
        self.token

    lastToken(self: CharExpr, tokens: Array[Token]) TokenIdx:
        self.token


#[derive(ToDoc)]
type BinOpExpr(
    left: Expr,
    right: Expr,
    op: BinOp,
)


impl Tokens[BinOpExpr]:
    firstToken(self: BinOpExpr, tokens: Array[Token]) TokenIdx:
        self.left.firstToken(tokens)

    lastToken(self: BinOpExpr, tokens: Array[Token]) TokenIdx:
        self.right.lastToken(tokens)


#[derive(ToDoc)]
type BinOp:
    Add
    And
    BitAnd
    BitOr
    Divide
    Equal
    Gt
    GtEq
    LeftShift
    Lt
    LtEq
    Multiply
    NotEqual
    Or
    RightShift
    Subtract


#[derive(ToDoc)]
type UnOpExpr(
    op: UnOp,
    expr: Expr,
    _firstToken: TokenIdx,
)


impl Tokens[UnOpExpr]:
    firstToken(self: UnOpExpr, tokens: Array[Token]) TokenIdx:
        self._firstToken

    lastToken(self: UnOpExpr, tokens: Array[Token]) TokenIdx:
        self.expr.lastToken(tokens)


#[derive(ToDoc)]
type RecordExpr(
    fields: Vec[Named[Expr]],
    _firstToken: TokenIdx,
    _lastToken: TokenIdx,
)


impl Tokens[RecordExpr]:
    firstToken(self: RecordExpr, tokens: Array[Token]) TokenIdx:
        self._firstToken

    lastToken(self: RecordExpr, tokens: Array[Token]) TokenIdx:
        self._lastToken


#[derive(ToDoc)]
type ReturnExpr(
    expr: Option[Expr],
    _firstToken: TokenIdx,
)


impl Tokens[ReturnExpr]:
    firstToken(self: ReturnExpr, tokens: Array[Token]) TokenIdx:
        self._firstToken

    lastToken(self: ReturnExpr, tokens: Array[Token]) TokenIdx:
        match self.expr:
            Option.Some(expr): expr.lastToken(tokens)
            Option.None: self._firstToken


#[derive(ToDoc)]
type MatchExpr(
    scrutinee: Expr,
    alts: Vec[Alt],
    _firstToken: TokenIdx,
)


impl Tokens[MatchExpr]:
    firstToken(self: MatchExpr, tokens: Array[Token]) TokenIdx:
        self._firstToken

    lastToken(self: MatchExpr, tokens: Array[Token]) TokenIdx:
        self.alts.last().unwrap().lastToken(tokens)


#[derive(ToDoc)]
type Alt(
    pat: Pat,
    guard: Option[Expr],
    rhs: Vec[Stmt],
)


impl Tokens[Alt]:
    firstToken(self: Alt, tokens: Array[Token]) TokenIdx:
        self.pat.firstToken(tokens)

    lastToken(self: Alt, tokens: Array[Token]) TokenIdx:
        self.rhs.last().unwrap().lastToken(tokens)


#[derive(ToDoc)]
type IfExpr(
    # At least one element
    branches: Vec[IfBranch],
    elseBranch: Option[Vec[Stmt]],
    _firstToken: TokenIdx,
)


#[derive(ToDoc)]
type IfBranch(
    guard: Expr,
    body: Vec[Stmt],
)


impl Tokens[IfExpr]:
    firstToken(self: IfExpr, tokens: Array[Token]) TokenIdx:
        self._firstToken

    lastToken(self: IfExpr, tokens: Array[Token]) TokenIdx:
        if self.elseBranch is Option.Some(block):
            return block.last().unwrap().lastToken(tokens)

        self.branches.last().unwrap().body.last().unwrap().lastToken(tokens)


#[derive(ToDoc)]
type FnExpr(
    sig: FunSig,
    body: Vec[Stmt],
    idx: U32,
    _firstToken: TokenIdx,
)


impl Tokens[FnExpr]:
    firstToken(self: FnExpr, tokens: Array[Token]) TokenIdx:
        self._firstToken

    lastToken(self: FnExpr, tokens: Array[Token]) TokenIdx:
        self.body.last().unwrap().lastToken(tokens)


# <expr> is <pat>
#[derive(ToDoc)]
type IsExpr(
    expr: Expr,
    pat: Pat,
)


impl Tokens[IsExpr]:
    firstToken(self: IsExpr, tokens: Array[Token]) TokenIdx:
        self.expr.firstToken(tokens)

    lastToken(self: IsExpr, tokens: Array[Token]) TokenIdx:
        self.pat.lastToken(tokens)


#[derive(ToDoc)]
type DoExpr(
    body: Vec[Stmt],
    _firstToken: TokenIdx,
)


impl Tokens[DoExpr]:
    firstToken(self: DoExpr, tokens: Array[Token]) TokenIdx:
        self._firstToken

    lastToken(self: DoExpr, tokens: Array[Token]) TokenIdx:
        self.body.last().unwrap().lastToken(tokens)


#[derive(ToDoc)]
type UnOp:
    Not
    Neg


#[derive(ToDoc)]
type SeqExpr(
    ty: Option[Type],
    elems: Vec[SeqElem],
    _lbracket: TokenIdx,
    _rbracket: TokenIdx,
)


#[derive(ToDoc)]
type SeqElem(
    key: Option[Expr],
    value: Expr,
)


impl Tokens[SeqExpr]:
    firstToken(self: SeqExpr, tokens: Array[Token]) TokenIdx:
        match self.ty:
            Option.Some(ty): ty.firstToken(tokens)
            Option.None: self._lbracket

    lastToken(self: SeqExpr, tokens: Array[Token]) TokenIdx:
        self._rbracket


#[derive(ToDoc)]
type ParenExpr(
    expr: Expr,
    _lparen: TokenIdx,
    _rparen: TokenIdx,
)


impl Tokens[ParenExpr]:
    firstToken(self: ParenExpr, tokens: Array[Token]) TokenIdx:
        self._lparen

    lastToken(self: ParenExpr, tokens: Array[Token]) TokenIdx:
        self._rparen


# --------------------------------------------------------------------------------------------------


impl ToStr[BinOp]:
    toStr(self: BinOp) Str:
        match self:
            BinOp.Add: "Add"
            BinOp.And: "And"
            BinOp.BitAnd: "BitAnd"
            BinOp.BitOr: "BitOr"
            BinOp.Divide: "Divide"
            BinOp.Equal: "Equal"
            BinOp.Gt: "Gt"
            BinOp.GtEq: "GtEq"
            BinOp.LeftShift: "LeftShift"
            BinOp.Lt: "Lt"
            BinOp.LtEq: "LtEq"
            BinOp.Multiply: "Multiply"
            BinOp.NotEqual: "NotEqual"
            BinOp.Or: "Or"
            BinOp.RightShift: "RightShift"
            BinOp.Subtract: "Subtract"


impl Eq[BinOp]:
    __eq(self: BinOp, other: BinOp) Bool:
        match (left = self, right = other):
            (left = BinOp.Add, right = BinOp.Add): Bool.True
            (left = BinOp.And, right = BinOp.And): Bool.True
            (left = BinOp.BitAnd, right = BinOp.BitOr): Bool.True
            (left = BinOp.Divide, right = BinOp.Divide): Bool.True
            (left = BinOp.Equal, right = BinOp.Equal): Bool.True
            (left = BinOp.Gt, right = BinOp.Gt): Bool.True
            (left = BinOp.GtEq, right = BinOp.GtEq): Bool.True
            (left = BinOp.LeftShift, right = BinOp.LeftShift): Bool.True
            (left = BinOp.Lt, right = BinOp.Lt): Bool.True
            (left = BinOp.LtEq, right = BinOp.LtEq): Bool.True
            (left = BinOp.Multiply, right = BinOp.Multiply): Bool.True
            (left = BinOp.NotEqual, right = BinOp.NotEqual): Bool.True
            (left = BinOp.Or, right = BinOp.Or): Bool.True
            (left = BinOp.RightShift, right = BinOp.RightShift): Bool.True
            (left = BinOp.Subtract, right = BinOp.Subtract): Bool.True
            _: Bool.False


# --------------------------------------------------------------------------------------------------
# Implementations below are generated with `Compiler/DeriveToDoc`, do not edit.


impl ToDoc[Id]:
    toDoc(self: Id) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("token =")
                + Doc.nested(4, Doc.break_(1) + self.token.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("Id") + Doc.char('(') + args)


impl ToDoc[TopDecl]:
    toDoc(self: TopDecl) Doc:
        match self:
            TopDecl.Type(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("TopDecl.Type") + Doc.char('(') + args)
            TopDecl.Fun(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("TopDecl.Fun") + Doc.char('(') + args)
            TopDecl.Import(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("TopDecl.Import") + Doc.char('(') + args)
            TopDecl.Trait(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("TopDecl.Trait") + Doc.char('(') + args)
            TopDecl.Impl(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("TopDecl.Impl") + Doc.char('(') + args)


impl ToDoc[TypeDecl]:
    toDoc(self: TypeDecl) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("prim_ =")
                + Doc.nested(4, Doc.break_(1) + self.prim_.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("name =") + Doc.nested(4, Doc.break_(1) + self.name.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("typeParams =")
                + Doc.nested(4, Doc.break_(1) + self.typeParams.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("typeParamKinds =")
                + Doc.nested(4, Doc.break_(1) + self.typeParamKinds.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("rhs =") + Doc.nested(4, Doc.break_(1) + self.rhs.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("TypeDecl") + Doc.char('(') + args)


impl ToDoc[TypeDeclRhs]:
    toDoc(self: TypeDeclRhs) Doc:
        match self:
            TypeDeclRhs.Sum(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("TypeDeclRhs.Sum") + Doc.char('(') + args)
            TypeDeclRhs.Product(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(
                    Doc.str("TypeDeclRhs.Product") + Doc.char('(') + args,
                )


impl ToDoc[ConDecl]:
    toDoc(self: ConDecl) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("name =") + Doc.nested(4, Doc.break_(1) + self.name.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("fields =")
                + Doc.nested(4, Doc.break_(1) + self.fields.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_lastToken =")
                + Doc.nested(4, Doc.break_(1) + self._lastToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("ConDecl") + Doc.char('(') + args)


impl ToDoc[ConFields]:
    toDoc(self: ConFields) Doc:
        match self:
            ConFields.Empty: Doc.str("ConFields.Empty")
            ConFields.Named(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("ConFields.Named") + Doc.char('(') + args)
            ConFields.Unnamed(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("ConFields.Unnamed") + Doc.char('(') + args)


impl ToDoc[NamedField]:
    toDoc(self: NamedField) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("name =") + Doc.nested(4, Doc.break_(1) + self.name.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("ty =") + Doc.nested(4, Doc.break_(1) + self.ty.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("NamedField") + Doc.char('(') + args)


impl ToDoc[FunDecl]:
    toDoc(self: FunDecl) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("prim_ =")
                + Doc.nested(4, Doc.break_(1) + self.prim_.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("parentTy =")
                + Doc.nested(4, Doc.break_(1) + self.parentTy.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("name =") + Doc.nested(4, Doc.break_(1) + self.name.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("sig =") + Doc.nested(4, Doc.break_(1) + self.sig.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("body =") + Doc.nested(4, Doc.break_(1) + self.body.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("FunDecl") + Doc.char('(') + args)


impl ToDoc[FunSig]:
    toDoc(self: FunSig) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("typeParams =")
                + Doc.nested(4, Doc.break_(1) + self.typeParams.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("context =")
                + Doc.nested(4, Doc.break_(1) + self.context.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("self_ =")
                + Doc.nested(4, Doc.break_(1) + self.self_.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("params =")
                + Doc.nested(4, Doc.break_(1) + self.params.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("returnTy =")
                + Doc.nested(4, Doc.break_(1) + self.returnTy.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("exceptions =")
                + Doc.nested(4, Doc.break_(1) + self.exceptions.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("lparen =")
                + Doc.nested(4, Doc.break_(1) + self.lparen.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("FunSig") + Doc.char('(') + args)


impl ToDoc[FunArg]:
    toDoc(self: FunArg) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("name =") + Doc.nested(4, Doc.break_(1) + self.name.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("ty =") + Doc.nested(4, Doc.break_(1) + self.ty.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("FunArg") + Doc.char('(') + args)


impl ToDoc[SelfParam]:
    toDoc(self: SelfParam) Doc:
        match self:
            SelfParam.No: Doc.str("SelfParam.No")
            SelfParam.Implicit: Doc.str("SelfParam.Implicit")
            SelfParam.Explicit(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("SelfParam.Explicit") + Doc.char('(') + args)


impl ToDoc[ImportDecl]:
    toDoc(self: ImportDecl) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("paths =")
                + Doc.nested(4, Doc.break_(1) + self.paths.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("ImportDecl") + Doc.char('(') + args)


impl ToDoc[TraitDecl]:
    toDoc(self: TraitDecl) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("name =") + Doc.nested(4, Doc.break_(1) + self.name.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("typeParams =")
                + Doc.nested(4, Doc.break_(1) + self.typeParams.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("typeParamKinds =")
                + Doc.nested(4, Doc.break_(1) + self.typeParamKinds.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("items =")
                + Doc.nested(4, Doc.break_(1) + self.items.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("TraitDecl") + Doc.char('(') + args)


impl ToDoc[ImplDecl]:
    toDoc(self: ImplDecl) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("typeParams =")
                + Doc.nested(4, Doc.break_(1) + self.typeParams.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("context =")
                + Doc.nested(4, Doc.break_(1) + self.context.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("trait_ =")
                + Doc.nested(4, Doc.break_(1) + self.trait_.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("tys =") + Doc.nested(4, Doc.break_(1) + self.tys.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("items =")
                + Doc.nested(4, Doc.break_(1) + self.items.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_firstToken =")
                + Doc.nested(4, Doc.break_(1) + self._firstToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("ImplDecl") + Doc.char('(') + args)


impl ToDoc[Type]:
    toDoc(self: Type) Doc:
        match self:
            Type.Named(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Type.Named") + Doc.char('(') + args)
            Type.Var(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Type.Var") + Doc.char('(') + args)
            Type.Record(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Type.Record") + Doc.char('(') + args)
            Type.Variant(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Type.Variant") + Doc.char('(') + args)
            Type.Fn_(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Type.Fn_") + Doc.char('(') + args)


impl ToDoc[RecordType]:
    toDoc(self: RecordType) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("fields =")
                + Doc.nested(4, Doc.break_(1) + self.fields.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("extension =")
                + Doc.nested(4, Doc.break_(1) + self.extension.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("isRow =")
                + Doc.nested(4, Doc.break_(1) + self.isRow.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_firstToken =")
                + Doc.nested(4, Doc.break_(1) + self._firstToken.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_lastToken =")
                + Doc.nested(4, Doc.break_(1) + self._lastToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("RecordType") + Doc.char('(') + args)


impl ToDoc[VariantType]:
    toDoc(self: VariantType) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("alts =") + Doc.nested(4, Doc.break_(1) + self.alts.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("extension =")
                + Doc.nested(4, Doc.break_(1) + self.extension.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("isRow =")
                + Doc.nested(4, Doc.break_(1) + self.isRow.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_firstToken =")
                + Doc.nested(4, Doc.break_(1) + self._firstToken.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_lastToken =")
                + Doc.nested(4, Doc.break_(1) + self._lastToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("VariantType") + Doc.char('(') + args)


impl ToDoc[FnType]:
    toDoc(self: FnType) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("args =") + Doc.nested(4, Doc.break_(1) + self.args.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("ret =") + Doc.nested(4, Doc.break_(1) + self.ret.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("exceptions =")
                + Doc.nested(4, Doc.break_(1) + self.exceptions.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_firstToken =")
                + Doc.nested(4, Doc.break_(1) + self._firstToken.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_rparen =")
                + Doc.nested(4, Doc.break_(1) + self._rparen.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("FnType") + Doc.char('(') + args)


impl ToDoc[Context]:
    toDoc(self: Context) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("preds =")
                + Doc.nested(4, Doc.break_(1) + self.preds.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_firstToken =")
                + Doc.nested(4, Doc.break_(1) + self._firstToken.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_lastToken =")
                + Doc.nested(4, Doc.break_(1) + self._lastToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("Context") + Doc.char('(') + args)


impl ToDoc[TypeParam]:
    toDoc(self: TypeParam) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("name =") + Doc.nested(4, Doc.break_(1) + self.name.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("kind =") + Doc.nested(4, Doc.break_(1) + self.kind.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("TypeParam") + Doc.char('(') + args)


impl ToDoc[NamedType]:
    toDoc(self: NamedType) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("name =") + Doc.nested(4, Doc.break_(1) + self.name.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("args =") + Doc.nested(4, Doc.break_(1) + self.args.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("NamedType") + Doc.char('(') + args)


impl[ToDoc[t]] ToDoc[Named[t]]:
    toDoc(self: Named[t]) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("name =") + Doc.nested(4, Doc.break_(1) + self.name.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("node =") + Doc.nested(4, Doc.break_(1) + self.node.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("Named") + Doc.char('(') + args)


impl ToDoc[Stmt]:
    toDoc(self: Stmt) Doc:
        match self:
            Stmt.Let(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Stmt.Let") + Doc.char('(') + args)
            Stmt.Assign(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Stmt.Assign") + Doc.char('(') + args)
            Stmt.Expr(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Stmt.Expr") + Doc.char('(') + args)
            Stmt.For(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Stmt.For") + Doc.char('(') + args)
            Stmt.While(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Stmt.While") + Doc.char('(') + args)
            Stmt.Loop(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Stmt.Loop") + Doc.char('(') + args)
            Stmt.Break(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Stmt.Break") + Doc.char('(') + args)
            Stmt.Continue(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Stmt.Continue") + Doc.char('(') + args)


impl ToDoc[LetStmt]:
    toDoc(self: LetStmt) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("lhs =") + Doc.nested(4, Doc.break_(1) + self.lhs.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("ty =") + Doc.nested(4, Doc.break_(1) + self.ty.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("rhs =") + Doc.nested(4, Doc.break_(1) + self.rhs.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_firstToken =")
                + Doc.nested(4, Doc.break_(1) + self._firstToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("LetStmt") + Doc.char('(') + args)


impl ToDoc[AssignStmt]:
    toDoc(self: AssignStmt) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("lhs =") + Doc.nested(4, Doc.break_(1) + self.lhs.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("rhs =") + Doc.nested(4, Doc.break_(1) + self.rhs.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("op =") + Doc.nested(4, Doc.break_(1) + self.op.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("AssignStmt") + Doc.char('(') + args)


impl ToDoc[AssignOp]:
    toDoc(self: AssignOp) Doc:
        match self:
            AssignOp.Eq: Doc.str("AssignOp.Eq")
            AssignOp.PlusEq: Doc.str("AssignOp.PlusEq")
            AssignOp.MinusEq: Doc.str("AssignOp.MinusEq")
            AssignOp.StarEq: Doc.str("AssignOp.StarEq")
            AssignOp.CaretEq: Doc.str("AssignOp.CaretEq")


impl ToDoc[ForStmt]:
    toDoc(self: ForStmt) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("label =")
                + Doc.nested(4, Doc.break_(1) + self.label.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("pat =") + Doc.nested(4, Doc.break_(1) + self.pat.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("astTy =")
                + Doc.nested(4, Doc.break_(1) + self.astTy.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("tcTy =") + Doc.nested(4, Doc.break_(1) + self.tcTy.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("expr =") + Doc.nested(4, Doc.break_(1) + self.expr.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("exprTy =")
                + Doc.nested(4, Doc.break_(1) + self.exprTy.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("body =") + Doc.nested(4, Doc.break_(1) + self.body.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_firstToken =")
                + Doc.nested(4, Doc.break_(1) + self._firstToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("ForStmt") + Doc.char('(') + args)


impl ToDoc[WhileStmt]:
    toDoc(self: WhileStmt) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("label =")
                + Doc.nested(4, Doc.break_(1) + self.label.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("cond =") + Doc.nested(4, Doc.break_(1) + self.cond.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("body =") + Doc.nested(4, Doc.break_(1) + self.body.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_firstToken =")
                + Doc.nested(4, Doc.break_(1) + self._firstToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("WhileStmt") + Doc.char('(') + args)


impl ToDoc[LoopStmt]:
    toDoc(self: LoopStmt) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("body =") + Doc.nested(4, Doc.break_(1) + self.body.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_firstToken =")
                + Doc.nested(4, Doc.break_(1) + self._firstToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("LoopStmt") + Doc.char('(') + args)


impl ToDoc[BreakStmt]:
    toDoc(self: BreakStmt) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("label =")
                + Doc.nested(4, Doc.break_(1) + self.label.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("level =")
                + Doc.nested(4, Doc.break_(1) + self.level.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_firstToken =")
                + Doc.nested(4, Doc.break_(1) + self._firstToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("BreakStmt") + Doc.char('(') + args)


impl ToDoc[ContinueStmt]:
    toDoc(self: ContinueStmt) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("label =")
                + Doc.nested(4, Doc.break_(1) + self.label.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("level =")
                + Doc.nested(4, Doc.break_(1) + self.level.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_firstToken =")
                + Doc.nested(4, Doc.break_(1) + self._firstToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("ContinueStmt") + Doc.char('(') + args)


impl ToDoc[Pat]:
    toDoc(self: Pat) Doc:
        match self:
            Pat.Var(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Pat.Var") + Doc.char('(') + args)
            Pat.Con(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Pat.Con") + Doc.char('(') + args)
            Pat.Record(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Pat.Record") + Doc.char('(') + args)
            Pat.Ignore(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Pat.Ignore") + Doc.char('(') + args)
            Pat.Str(i0, i1):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args += Doc.char(',') + Doc.break_(1)
                args += i1.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Pat.Str") + Doc.char('(') + args)
            Pat.Char(i0, i1):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args += Doc.char(',') + Doc.break_(1)
                args += i1.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Pat.Char") + Doc.char('(') + args)
            Pat.Or(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Pat.Or") + Doc.char('(') + args)
            Pat.Variant(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Pat.Variant") + Doc.char('(') + args)


impl ToDoc[VarPat]:
    toDoc(self: VarPat) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("var_ =") + Doc.nested(4, Doc.break_(1) + self.var_.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("ty =") + Doc.nested(4, Doc.break_(1) + self.ty.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("VarPat") + Doc.char('(') + args)


impl ToDoc[ConPat]:
    toDoc(self: ConPat) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("con =") + Doc.nested(4, Doc.break_(1) + self.con.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("fields =")
                + Doc.nested(4, Doc.break_(1) + self.fields.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("ignoreRest =")
                + Doc.nested(4, Doc.break_(1) + self.ignoreRest.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_lastToken =")
                + Doc.nested(4, Doc.break_(1) + self._lastToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("ConPat") + Doc.char('(') + args)


impl ToDoc[RecordPat]:
    toDoc(self: RecordPat) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("fields =")
                + Doc.nested(4, Doc.break_(1) + self.fields.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("ignoreRest =")
                + Doc.nested(4, Doc.break_(1) + self.ignoreRest.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("inferredTy =")
                + Doc.nested(4, Doc.break_(1) + self.inferredTy.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_firstToken =")
                + Doc.nested(4, Doc.break_(1) + self._firstToken.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_lastToken =")
                + Doc.nested(4, Doc.break_(1) + self._lastToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("RecordPat") + Doc.char('(') + args)


impl ToDoc[Con]:
    toDoc(self: Con) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("ty =") + Doc.nested(4, Doc.break_(1) + self.ty.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("con =") + Doc.nested(4, Doc.break_(1) + self.con.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("userTyArgs =")
                + Doc.nested(4, Doc.break_(1) + self.userTyArgs.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("tyArgs =")
                + Doc.nested(4, Doc.break_(1) + self.tyArgs.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_firstToken =")
                + Doc.nested(4, Doc.break_(1) + self._firstToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("Con") + Doc.char('(') + args)


impl ToDoc[Expr]:
    toDoc(self: Expr) Doc:
        match self:
            Expr.Var(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Expr.Var") + Doc.char('(') + args)
            Expr.ConSel(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Expr.ConSel") + Doc.char('(') + args)
            Expr.FieldSel(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Expr.FieldSel") + Doc.char('(') + args)
            Expr.MethodSel(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Expr.MethodSel") + Doc.char('(') + args)
            Expr.AssocFnSel(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Expr.AssocFnSel") + Doc.char('(') + args)
            Expr.Call(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Expr.Call") + Doc.char('(') + args)
            Expr.Int(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Expr.Int") + Doc.char('(') + args)
            Expr.Str(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Expr.Str") + Doc.char('(') + args)
            Expr.Char(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Expr.Char") + Doc.char('(') + args)
            Expr.Self(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Expr.Self") + Doc.char('(') + args)
            Expr.BinOp(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Expr.BinOp") + Doc.char('(') + args)
            Expr.UnOp(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Expr.UnOp") + Doc.char('(') + args)
            Expr.Record(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Expr.Record") + Doc.char('(') + args)
            Expr.Return(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Expr.Return") + Doc.char('(') + args)
            Expr.Match(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Expr.Match") + Doc.char('(') + args)
            Expr.If(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Expr.If") + Doc.char('(') + args)
            Expr.Fn_(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Expr.Fn_") + Doc.char('(') + args)
            Expr.Is(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Expr.Is") + Doc.char('(') + args)
            Expr.Do(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Expr.Do") + Doc.char('(') + args)
            Expr.Seq(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Expr.Seq") + Doc.char('(') + args)
            Expr.Paren(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Expr.Paren") + Doc.char('(') + args)
            Expr.Variant(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("Expr.Variant") + Doc.char('(') + args)


impl ToDoc[VarExpr]:
    toDoc(self: VarExpr) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("id =") + Doc.nested(4, Doc.break_(1) + self.id.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("userTyArgs =")
                + Doc.nested(4, Doc.break_(1) + self.userTyArgs.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("tyArgs =")
                + Doc.nested(4, Doc.break_(1) + self.tyArgs.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("VarExpr") + Doc.char('(') + args)


impl ToDoc[TyArgs]:
    toDoc(self: TyArgs) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("args =") + Doc.nested(4, Doc.break_(1) + self.args.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_firstToken =")
                + Doc.nested(4, Doc.break_(1) + self._firstToken.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_lastToken =")
                + Doc.nested(4, Doc.break_(1) + self._lastToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("TyArgs") + Doc.char('(') + args)


impl ToDoc[FieldSelExpr]:
    toDoc(self: FieldSelExpr) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("object =")
                + Doc.nested(4, Doc.break_(1) + self.object.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("field =")
                + Doc.nested(4, Doc.break_(1) + self.field.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("userTyArgs =")
                + Doc.nested(4, Doc.break_(1) + self.userTyArgs.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("FieldSelExpr") + Doc.char('(') + args)


impl ToDoc[MethodSelExpr]:
    toDoc(self: MethodSelExpr) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("object =")
                + Doc.nested(4, Doc.break_(1) + self.object.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("objectTy =")
                + Doc.nested(4, Doc.break_(1) + self.objectTy.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("methodTyId =")
                + Doc.nested(4, Doc.break_(1) + self.methodTyId.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("method =")
                + Doc.nested(4, Doc.break_(1) + self.method.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("tyArgs =")
                + Doc.nested(4, Doc.break_(1) + self.tyArgs.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_lastToken =")
                + Doc.nested(4, Doc.break_(1) + self._lastToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("MethodSelExpr") + Doc.char('(') + args)


impl ToDoc[AssocFnSelExpr]:
    toDoc(self: AssocFnSelExpr) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("ty =") + Doc.nested(4, Doc.break_(1) + self.ty.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("member =")
                + Doc.nested(4, Doc.break_(1) + self.member.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("userTyArgs =")
                + Doc.nested(4, Doc.break_(1) + self.userTyArgs.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("tyArgs =")
                + Doc.nested(4, Doc.break_(1) + self.tyArgs.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_lastToken =")
                + Doc.nested(4, Doc.break_(1) + self._lastToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("AssocFnSelExpr") + Doc.char('(') + args)


impl ToDoc[CallExpr]:
    toDoc(self: CallExpr) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("fun =") + Doc.nested(4, Doc.break_(1) + self.fun.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("args =") + Doc.nested(4, Doc.break_(1) + self.args.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_lastToken =")
                + Doc.nested(4, Doc.break_(1) + self._lastToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("CallExpr") + Doc.char('(') + args)


impl ToDoc[IntExpr]:
    toDoc(self: IntExpr) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("text =") + Doc.nested(4, Doc.break_(1) + self.text.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("suffix =")
                + Doc.nested(4, Doc.break_(1) + self.suffix.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("radix =")
                + Doc.nested(4, Doc.break_(1) + self.radix.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("parsed =")
                + Doc.nested(4, Doc.break_(1) + self.parsed.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("token =")
                + Doc.nested(4, Doc.break_(1) + self.token.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("IntExpr") + Doc.char('(') + args)


impl ToDoc[StrExpr]:
    toDoc(self: StrExpr) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("parts =")
                + Doc.nested(4, Doc.break_(1) + self.parts.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("first =")
                + Doc.nested(4, Doc.break_(1) + self.first.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("last =") + Doc.nested(4, Doc.break_(1) + self.last.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("StrExpr") + Doc.char('(') + args)


impl ToDoc[StrPart]:
    toDoc(self: StrPart) Doc:
        match self:
            StrPart.Str(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("StrPart.Str") + Doc.char('(') + args)
            StrPart.Expr(i0):
                let args = Doc.break_(0)
                args += i0.toDoc()
                args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
                Doc.grouped(Doc.str("StrPart.Expr") + Doc.char('(') + args)


impl ToDoc[CharExpr]:
    toDoc(self: CharExpr) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("char =") + Doc.nested(4, Doc.break_(1) + self.char.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("token =")
                + Doc.nested(4, Doc.break_(1) + self.token.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("CharExpr") + Doc.char('(') + args)


impl ToDoc[BinOpExpr]:
    toDoc(self: BinOpExpr) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("left =") + Doc.nested(4, Doc.break_(1) + self.left.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("right =")
                + Doc.nested(4, Doc.break_(1) + self.right.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("op =") + Doc.nested(4, Doc.break_(1) + self.op.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("BinOpExpr") + Doc.char('(') + args)


impl ToDoc[BinOp]:
    toDoc(self: BinOp) Doc:
        match self:
            BinOp.Add: Doc.str("BinOp.Add")
            BinOp.And: Doc.str("BinOp.And")
            BinOp.BitAnd: Doc.str("BinOp.BitAnd")
            BinOp.BitOr: Doc.str("BinOp.BitOr")
            BinOp.Divide: Doc.str("BinOp.Divide")
            BinOp.Equal: Doc.str("BinOp.Equal")
            BinOp.Gt: Doc.str("BinOp.Gt")
            BinOp.GtEq: Doc.str("BinOp.GtEq")
            BinOp.LeftShift: Doc.str("BinOp.LeftShift")
            BinOp.Lt: Doc.str("BinOp.Lt")
            BinOp.LtEq: Doc.str("BinOp.LtEq")
            BinOp.Multiply: Doc.str("BinOp.Multiply")
            BinOp.NotEqual: Doc.str("BinOp.NotEqual")
            BinOp.Or: Doc.str("BinOp.Or")
            BinOp.RightShift: Doc.str("BinOp.RightShift")
            BinOp.Subtract: Doc.str("BinOp.Subtract")


impl ToDoc[UnOpExpr]:
    toDoc(self: UnOpExpr) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("op =") + Doc.nested(4, Doc.break_(1) + self.op.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("expr =") + Doc.nested(4, Doc.break_(1) + self.expr.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_firstToken =")
                + Doc.nested(4, Doc.break_(1) + self._firstToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("UnOpExpr") + Doc.char('(') + args)


impl ToDoc[RecordExpr]:
    toDoc(self: RecordExpr) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("fields =")
                + Doc.nested(4, Doc.break_(1) + self.fields.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_firstToken =")
                + Doc.nested(4, Doc.break_(1) + self._firstToken.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_lastToken =")
                + Doc.nested(4, Doc.break_(1) + self._lastToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("RecordExpr") + Doc.char('(') + args)


impl ToDoc[ReturnExpr]:
    toDoc(self: ReturnExpr) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("expr =") + Doc.nested(4, Doc.break_(1) + self.expr.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_firstToken =")
                + Doc.nested(4, Doc.break_(1) + self._firstToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("ReturnExpr") + Doc.char('(') + args)


impl ToDoc[MatchExpr]:
    toDoc(self: MatchExpr) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("scrutinee =")
                + Doc.nested(4, Doc.break_(1) + self.scrutinee.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("alts =") + Doc.nested(4, Doc.break_(1) + self.alts.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_firstToken =")
                + Doc.nested(4, Doc.break_(1) + self._firstToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("MatchExpr") + Doc.char('(') + args)


impl ToDoc[Alt]:
    toDoc(self: Alt) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("pat =") + Doc.nested(4, Doc.break_(1) + self.pat.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("guard =")
                + Doc.nested(4, Doc.break_(1) + self.guard.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("rhs =") + Doc.nested(4, Doc.break_(1) + self.rhs.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("Alt") + Doc.char('(') + args)


impl ToDoc[IfExpr]:
    toDoc(self: IfExpr) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("branches =")
                + Doc.nested(4, Doc.break_(1) + self.branches.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("elseBranch =")
                + Doc.nested(4, Doc.break_(1) + self.elseBranch.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_firstToken =")
                + Doc.nested(4, Doc.break_(1) + self._firstToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("IfExpr") + Doc.char('(') + args)


impl ToDoc[IfBranch]:
    toDoc(self: IfBranch) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("guard =")
                + Doc.nested(4, Doc.break_(1) + self.guard.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("body =") + Doc.nested(4, Doc.break_(1) + self.body.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("IfBranch") + Doc.char('(') + args)


impl ToDoc[FnExpr]:
    toDoc(self: FnExpr) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("sig =") + Doc.nested(4, Doc.break_(1) + self.sig.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("body =") + Doc.nested(4, Doc.break_(1) + self.body.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("idx =") + Doc.nested(4, Doc.break_(1) + self.idx.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_firstToken =")
                + Doc.nested(4, Doc.break_(1) + self._firstToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("FnExpr") + Doc.char('(') + args)


impl ToDoc[IsExpr]:
    toDoc(self: IsExpr) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("expr =") + Doc.nested(4, Doc.break_(1) + self.expr.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("pat =") + Doc.nested(4, Doc.break_(1) + self.pat.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("IsExpr") + Doc.char('(') + args)


impl ToDoc[DoExpr]:
    toDoc(self: DoExpr) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("body =") + Doc.nested(4, Doc.break_(1) + self.body.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_firstToken =")
                + Doc.nested(4, Doc.break_(1) + self._firstToken.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("DoExpr") + Doc.char('(') + args)


impl ToDoc[UnOp]:
    toDoc(self: UnOp) Doc:
        match self:
            UnOp.Not: Doc.str("UnOp.Not")
            UnOp.Neg: Doc.str("UnOp.Neg")


impl ToDoc[SeqExpr]:
    toDoc(self: SeqExpr) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("ty =") + Doc.nested(4, Doc.break_(1) + self.ty.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("elems =")
                + Doc.nested(4, Doc.break_(1) + self.elems.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_lbracket =")
                + Doc.nested(4, Doc.break_(1) + self._lbracket.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_rbracket =")
                + Doc.nested(4, Doc.break_(1) + self._rbracket.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("SeqExpr") + Doc.char('(') + args)


impl ToDoc[SeqElem]:
    toDoc(self: SeqElem) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("key =") + Doc.nested(4, Doc.break_(1) + self.key.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("value =")
                + Doc.nested(4, Doc.break_(1) + self.value.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("SeqElem") + Doc.char('(') + args)


impl ToDoc[ParenExpr]:
    toDoc(self: ParenExpr) Doc:
        let args = Doc.break_(0)
        args += Doc.grouped(
            Doc.str("expr =") + Doc.nested(4, Doc.break_(1) + self.expr.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_lparen =")
                + Doc.nested(4, Doc.break_(1) + self._lparen.toDoc()),
        )
        args += Doc.char(',') + Doc.break_(1)
        args += Doc.grouped(
            Doc.str("_rparen =")
                + Doc.nested(4, Doc.break_(1) + self._rparen.toDoc()),
        )
        args = args.nest(4).group() + Doc.break_(0) + Doc.char(')')
        Doc.grouped(Doc.str("ParenExpr") + Doc.char('(') + args)
