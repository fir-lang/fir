# PEG grammar of PEG grammars.

import Compiler.Token
import ParseTree

type Terminal = Token
type NonTerminal = NonTerminal

Terminals:
    "lowerId" = Token(kind = TokenKind.LowerId, ..)
    "UpperId" = Token(kind = TokenKind.UpperId, ..)
    "Terminals" = Token(kind = TokenKind.UpperId, text = "Terminals", ..)
    "type" = Token(kind = TokenKind.Type, ..)
    "import" = Token(kind = TokenKind.Import, ..)
    ":" = Token(kind = TokenKind.Colon, ..)
    "INDENT" = Token(kind = TokenKind.Indent, ..)
    "DEDENT" = Token(kind = TokenKind.Dedent, ..)
    "NEWLINE" = Token(kind = TokenKind.Newline, ..)
    "+" = Token(kind = TokenKind.Plus, ..)
    "?" = Token(kind = TokenKind.Question, ..)
    "*" = Token(kind = TokenKind.Star, ..)
    "_" = Token(kind = TokenKind.Underscore, ..)
    "-" = Token(kind = TokenKind.Minus, ..)
    "=" = Token(kind = TokenKind.Eq, ..)
    "(" = Token(kind = TokenKind.LParen, ..)
    ")" = Token(kind = TokenKind.RParen, ..)
    "." = Token(kind = TokenKind.Dot, ..)
    "$" = Token(kind = TokenKind.Dollar, ..)
    "Str" = Token(kind = TokenKind.Str, ..)
    "ANY" = Token(..)

    # For semantic actions:
    "[" = Token(kind = TokenKind.LBracket, ..)
    "]" = Token(kind = TokenKind.RBracket, ..)
    "{" = Token(kind = TokenKind.LBrace, ..)
    "}" = Token(kind = TokenKind.RBrace, ..)
    "row(" = Token(kind = TokenKind.LParenRow, ..)
    "row[" = Token(kind = TokenKind.LBracketRow, ..)

grammar:
    importDecls typeDecls terminalsDecl nonTerminalDecls $

importDecls:
    importDecl*

importDecl:
    _"import" "UpperId" (_"." "UpperId")* _"NEWLINE"

typeDecls:
    typeDecl*

typeDecl:
    # NB. We can generalize the right-hand side to types using the compiler's
    # type parser.
    _"type" "UpperId" _"=" "UpperId" _"NEWLINE"

terminalsDecl:
    (_"Terminals" _":" _"NEWLINE" _"INDENT" terminalDecl+ _"DEDENT")?

terminalDecl:
    "Str" _"=" (-"NEWLINE" "ANY")+ _"NEWLINE"

nonTerminalDecls:
    nonTerminalDecl*

nonTerminalDecl:
    "lowerId" _":" _"NEWLINE" _"INDENT" nonTerminalAlt+ _"DEDENT"

nonTerminalAlt:
    symbol+ nonTerminalRhs

symbol:
    symbolPrefix? symbolNonRec symbolSuffix?
    "$"

symbolPrefix:
    "-"                 # negative lookahead (fails when symbol succeeds)
    "_"                 # silence, or ignore (don't push match to the tree)

    # Binder: it doesn't make sense to combine these with negative lookahead
    # and ignore, so we're parsing either a prefix or binder.
    "lowerId" _"="

symbolNonRec:
    "lowerId"           # non-terminal
    "Str"               # terminal
    _"(" symbol+ _")"   # group

symbolSuffix:
    "*"                 # zero or more
    "+"                 # one or more
    "?"                 # optional (zero or one)

nonTerminalRhs:
    _"NEWLINE"
    _":" inlineTokenTreeSingle+ _"NEWLINE"
    _":" _"NEWLINE" _"INDENT" indentedTokenTreeSingle+ _"DEDENT"

# --------------------------------------------------------------------------------------------------
# Token trees for the semantic action code.

inlineTokenTree:
    inlineTokenTreeSingle*

inlineTokenTreeSingle:
    "(" indentedTokenTree ")"
    "row(" indentedTokenTree ")"
    "[" indentedTokenTree "]"
    "row[" indentedTokenTree "]"
    "{" indentedTokenTree "}"
    "INDENT" indentedTokenTree "DEDENT"
    -inlineTokenTreeTerminator "ANY"

inlineTokenTreeTerminator:
    ")"
    "]"
    "}"
    "DEDENT"
    "NEWLINE"

indentedTokenTree:
    indentedTokenTreeSingle*

indentedTokenTreeSingle:
    "(" indentedTokenTree ")"
    "row(" indentedTokenTree ")"
    "[" indentedTokenTree "]"
    "row[" indentedTokenTree "]"
    "{" indentedTokenTree "}"
    "INDENT" indentedTokenTree "DEDENT"
    -indentedTokenTreeTerminator "ANY"

indentedTokenTreeTerminator:
    ")"
    "]"
    "}"
    "DEDENT"
