import Peg.ParseTree
import Token

type Terminal = Token
type NonTerminal = NonTerminal

# --------------------------------------------------------------------------------------------------

Terminals:
    "LowerId" = Token(kind = TokenKind.LowerId, ..)
    "UpperId" = Token(kind = TokenKind.UpperId, ..)
    "TildeUpperId" = Token(kind = TokenKind.TildeUpperId, ..)
    "and" = Token(kind = TokenKind.And, ..)
    "break" = Token(kind = TokenKind.Break, ..)
    "continue" = Token(kind = TokenKind.Continue, ..)
    "do" = Token(kind = TokenKind.Do, ..)
    "elif" = Token(kind = TokenKind.Elif, ..)
    "else" = Token(kind = TokenKind.Else, ..)
    "Fn" = Token(kind = TokenKind.UpperFn, ..)
    "for" = Token(kind = TokenKind.For, ..)
    "if" = Token(kind = TokenKind.If, ..)
    "impl" = Token(kind = TokenKind.Impl, ..)
    "import" = Token(kind = TokenKind.Import, ..)
    "in" = Token(kind = TokenKind.In, ..)
    "is" = Token(kind = TokenKind.Is, ..)
    "let" = Token(kind = TokenKind.Let, ..)
    "loop" = Token(kind = TokenKind.Loop, ..)
    "match" = Token(kind = TokenKind.Match, ..)
    "not" = Token(kind = TokenKind.Not, ..)
    "or" = Token(kind = TokenKind.Or, ..)
    "prim" = Token(kind = TokenKind.Prim, ..)
    "return" = Token(kind = TokenKind.Return, ..)
    "trait" = Token(kind = TokenKind.Trait, ..)
    "type" = Token(kind = TokenKind.Type, ..)
    "while" = Token(kind = TokenKind.While, ..)
    "row[" = Token(kind = TokenKind.LBracketRow, ..)
    "row(" = Token(kind = TokenKind.LParenRow, ..)
    "(" = Token(kind = TokenKind.LParen, ..)
    ")" = Token(kind = TokenKind.RParen, ..)
    "[" = Token(kind = TokenKind.LBracket, ..)
    "]" = Token(kind = TokenKind.RBracket, ..)
    ":" = Token(kind = TokenKind.Colon, ..)
    "," = Token(kind = TokenKind.Comma, ..)
    ".." = Token(kind = TokenKind.DotDot, ..)
    "." = Token(kind = TokenKind.Dot, ..)
    "=" = Token(kind = TokenKind.Eq, ..)
    "==" = Token(kind = TokenKind.EqEq, ..)
    "+=" = Token(kind = TokenKind.PlusEq, ..)
    "-=" = Token(kind = TokenKind.MinusEq, ..)
    "*=" = Token(kind = TokenKind.StarEq, ..)
    "^=" = Token(kind = TokenKind.CaretEq, ..)
    "!=" = Token(kind = TokenKind.ExclamationEq, ..)
    "-" = Token(kind = TokenKind.Minus, ..)
    "~" = Token(kind = TokenKind.Tilde, ..)
    "+" = Token(kind = TokenKind.Plus, ..)
    "-" = Token(kind = TokenKind.Minus, ..)
    "/" = Token(kind = TokenKind.Slash, ..)
    "*" = Token(kind = TokenKind.Star, ..)
    "|" = Token(kind = TokenKind.Pipe, ..)
    "||" = Token(kind = TokenKind.PipePipe, ..)
    "&" = Token(kind = TokenKind.Amp, ..)
    "/" = Token(kind = TokenKind.Slash, ..)
    "_" = Token(kind = TokenKind.Underscore, ..)
    ">" = Token(kind = TokenKind.RAngle, ..)
    ">>" = Token(kind = TokenKind.DoubleRAngle, ..)
    ">=" = Token(kind = TokenKind.RAngleEq, ..)
    "<" = Token(kind = TokenKind.LAngle, ..)
    "<<" = Token(kind = TokenKind.DoubleLAngle, ..)
    "<=" = Token(kind = TokenKind.LAngleEq, ..)
    "Int" = Token(kind = TokenKind.Int, ..)
    "HexInt" = Token(kind = TokenKind.HexInt, ..)
    "BinInt" = Token(kind = TokenKind.BinInt, ..)
    "Str" = Token(kind = TokenKind.Str, ..)
    "Char" = Token(kind = TokenKind.Char, ..)
    "NEWLINE" = Token(kind = TokenKind.Newline, ..)
    "INDENT" = Token(kind = TokenKind.Indent, ..)
    "DEDENT" = Token(kind = TokenKind.Dedent, ..)
    "label" = Token(kind = TokenKind.Label, ..)


#|
# --------------------------------------------------------------------------------------------------
# Top-level declarations

module:
    topDecl+ $


topDecl:
    typeDecl
    importDecl
    traitDecl
    implDecl
    topFunDecl


|#

# --------------------------------------------------------------------------------------------------
# Types

type_ Type:
    t=namedType: Type.Named(t)
    id="LowerId": Type.Var(newId(id.text))
    t=recordType: Type.Record(t)
    t=variantType: Type.Variant(t)
    t=fnType: Type.Fn_(t)


 namedType NamedType:
    name="UpperId" _"[" arg0=type_ args=(_"," t=type_)* _","? _"]":
        let args = once(arg0).chain(args.iter().map(|arg: (t: Type)|: arg.t)).toVec()
        NamedType(name = newId(name.text), args = args)

    name="UpperId":
        NamedType(name = newId(name.text), args = Vec.empty())


# - ()
# - (x: U32)
# - (x: U32,)
# - (x: U32, y: U32)
# - (x: U32, ..foo)
# - (..foo)
recordType RecordType:
    isRow=recordTypeStart _")":
        RecordType(fields = Vec.empty(), extension = Option.None, isRow = isRow)

    isRow=recordTypeStart ".." ext="LowerId" _")":
        RecordType(fields = Vec.empty(), extension = Option.Some(newId(ext.text)), isRow = isRow)

    isRow=recordTypeStart f0=recordTypeField fs=(_"," f=recordTypeField)* ext=recordTypeCont? _")":
        panic("TODO")


# Returns whether the type is a row.
recordTypeStart Bool:
    _"(": Bool.False
    "row(": Bool.True


recordTypeCont:
    _"," (_".." "LowerId")?


# - []
# - [A]
# - [A,]
# - [A, B]
# - [A, ..foo]
# - [..foo]
variantType VariantType:
    isRow=variantTypeStart _"]":
        VariantType(alts = Vec.empty(), extension = Option.None, isRow = isRow)

    isRow=variantTypeStart _".." ext="LowerId" _"]":
        VariantType(alts = Vec.empty(), extension = Option.Some(newId(ext.text)), isRow = isRow)

    isRow=variantTypeStart alt0=variantAlt alts=(_"," a=variantAlt)* ext=variantTypeCont? _"]":
        VariantType(
            alts = once(alt0).chain(alts.iter().map(|alt: (a: VariantAlt)|: alt.a)).toVec(),
            extension = ext.flatten(),
            isRow = isRow,
        )


# Returns whether the type is a row.
variantTypeStart Bool:
    _"[": Bool.False
    _"row[": Bool.True


variantTypeCont Option[Id]:
    _"," id=(_".." id="LowerId")?:
        id.map(|id: (id: Token)|: newId(id.id.text))


variantAlt VariantAlt:
    con="UpperId" _"(" fields=recordTypeFields _")":
        VariantAlt(con = newId(con.text), fields = fields)

    con="UpperId":
        VariantAlt(con = newId(con.text), fields = Vec.empty())


recordTypeFields Vec[Named[Type]]:
    f0=recordTypeField fs=(_"," f=recordTypeField)* _"," _".." "LowerId":
        # TODO: Extension?
        # TODO: We do we need the type annotation here?
        let vec: Vec[Named[Type]] = once(f0).chain(fs.iter().map(|f: (f: Named[Type])|: f.f)).toVec()
        vec

    f0=recordTypeField fs=(_"," f=recordTypeField)* _","?:
        let vec: Vec[Named[Type]] = once(f0).chain(fs.iter().map(|f: (f: Named[Type])|: f.f)).toVec()
        vec


recordTypeField Named[Type]:
    name="LowerId" _":" ty=type_:
        Named(name = Option.Some(newId(name.text)), node = ty)

    ty=type_:
        Named(name = Option.None, node = ty)


fnType FnType:
    _"Fn" _"(" args=fnArgTys? _")" ret=returnTy?:
        let args = args.unwrapOr(Vec.empty())
        let ret = ret.unwrapOr((ret = Option.None, exn = Option.None))
        FnType(args = args, ret = ret.ret, exceptions = ret.exn)

fnArgTys Vec[Type]:
    t0=type_ ts=(_"," t=type_)* _","?:
        let vec: Vec[Type] = once(t0).chain(ts.iter().map(|t: (t: Type)|: t.t)).toVec()
        vec


returnTy (ret: Option[Type], exn: Option[Type]):
    ret=type_ _"/" exn=type_:
        (ret = Option.Some(ret), exn = Option.Some(exn))

    ret=type_:
        (ret = Option.Some(ret), exn = Option.None)

    "/" exn=type_:
        (ret = Option.None, exn = Option.Some(exn))


# --------------------------------------------------------------------------------------------------
# Type declarations

typeDecl TypeDecl:
    _"type" name="UpperId" params=(_"[" params=typeParams _"]")? _":" _"NEWLINE" _"INDENT" rhs=typeDeclRhs _"DEDENT":
        TypeDecl(
            name = newId(name.text),
            typeParams = match params:
                Option.Some(params): params.params
                Option.None: Vec.empty(),
            typeParamKinds = Vec.empty(),
            rhs = Option.Some(rhs),
        )

    _"type" name="UpperId" params=(_"[" params=typeParams _"]")? _"NEWLINE":
        TypeDecl(
            name = newId(name.text),
            typeParams = match params:
                Option.Some(params): params.params
                Option.None: Vec.empty(),
            typeParamKinds = Vec.empty(),
            rhs = Option.None,
        )

    "prim" _"type" name="UpperId" params=(_"[" params=typeParams _"]")? _"NEWLINE":
        TypeDecl(
            name = newId(name.text),
            typeParams = match params:
                Option.Some(params): params.params
                Option.None: Vec.empty(),
            typeParamKinds = Vec.empty(),
            rhs = Option.None,
        )


typeParams Vec[Id]:
    id0="LowerId" ids=(_"," id="LowerId")* _","?:
        let vec: Vec[Id] =
            once(newId(id0.text)).chain(ids.iter().map(|id: (id: Token)|: newId(id.id.text))).toVec()
        vec


typeDeclRhs TypeDeclRhs:
    cs=conDecl+:
        TypeDeclRhs.Sum(cs)

    fs=namedField+:
        TypeDeclRhs.Product(ConFields.Named(fs))


conDecl ConDecl:
    name="UpperId" _":" _"NEWLINE" _"INDENT" fs=namedFields _"DEDENT":
        ConDecl(name = newId(name.text), fields = ConFields.Named(fs))

    name="UpperId" _"(" fs=unnamedFields? _")" _"NEWLINE":
        ConDecl(name = newId(name.text), fields = ConFields.Unnamed(fs.unwrapOr(Vec.empty())))

    name="UpperId" _"NEWLINE":
        ConDecl(name = newId(name.text), fields = ConFields.Empty)


namedFields Vec[(name: Id, ty: Type)]:
    fs=namedField+:
        fs


namedField (name: Id, ty: Type):
    name="LowerId" _":" ty=type_ _"NEWLINE":
        (name = newId(name.text), ty = ty)


unnamedFields Vec[Type]:
    t0=type_ ts=(_"," t=type_)* _","?:
        let vec: Vec[Type] = once(t0).chain(ts.iter().map(|t: (t: Type)|: t.t)).toVec()
        vec


#|
# --------------------------------------------------------------------------------------------------
# Expressions

expr:
    inlineExpr
    blockExpr


# Inline expressions don't end with a NEWLINE or DEDENT.
inlineExpr:
    prefixExpr inlineExprCont*


# Block expressions include an indented block and always end with DEDENT.
blockExpr:
    "match" inlineExpr _":" _"NEWLINE" _"INDENT" matchAlt+ _"DEDENT"

    "if" inlineExpr _":" _"NEWLINE" _"INDENT" stmt+ _"DEDENT"
        ("elif" inlineExpr _":" _"NEWLINE" _"INDENT" stmt+ _"DEDENT")*
        ("else" _":" _"NEWLINE" _"INDENT" stmt+ _"DEDENT")?

    "do" _":" _"NEWLINE" _"INDENT" stmt+ _"DEDENT"

    "||" returnTy? ":" _"NEWLINE" _"INDENT" stmt+ _"DEDENT"

    "|" fnArgs? "|" returnTy? ":" _"NEWLINE" _"INDENT" stmt + _"DEDENT"


inlineExprCont:
    binOp prefixExpr
    "is" pat


prefixExpr:
    exprPrefix? simpleExpr exprSuffix*


exprSuffix:
    field tyArgs?
    args


field:
    (_"." "LowerId")


args:
    _"(" (arg (_"," arg)* _","?)? _")"


arg:
    "LowerId" "=" expr
    expr


simpleExpr:
    # Variables
    "LowerId" tyArgs?

    # Constructor selection, or sequence
    upperIdPath tyArgs? (_"." sequence)?

    # Records: `(a, b)`, `(a = 1, b = 2)`
    "(" (parenExpr (_"," parenExpr)* _","?)? ")"

    sequence

    "return" inlineExpr?

    "||" returnTy? ":" inlineExpr

    "|" fnArgs? "|" returnTy? ":" inlineExpr

    "Int"
    "HexInt"
    "BinInt"
    "Str"
    "Char"


sequence:
    "[" "]"
    "[" seqElem (_"," seqElem)* _","? "]"


seqElem:
    inlineExpr (_"=" inlineExpr)?


upperIdPath:
    "UpperId" (_"." "UpperId")*
    "TildeUpperId" (_"." "UpperId")*


tyArgs:
    "[" type_ (_"," type_)* _","? "]"


parenExpr:
    "LowerId" "=" expr
    expr


exprPrefix:
    "~"
    "-"
    "not"


binOp:
    "+"
    "-"
    "*"
    "/"
    "=="
    "!="
    "and"
    "or"
    "|"
    "&"
    "/"
    ">"
    ">>"
    ">="
    "<"
    "<<"
    "<="


matchAlt:
    pat altGuard? _":" _"NEWLINE" _"INDENT" stmt+ _"DEDENT"
    pat altGuard? _":" stmt


altGuard:
    "if" expr


matchRhs:
    _"NEWLINE" _"INDENT" blockExpr
    inlineExpr


fnArgs:
    "LowerId" (_":" type_)? ("," "LowerId" (_":" type_)?)* _","?


# --------------------------------------------------------------------------------------------------
# Statements

stmt:
    "break" "label"? _"NEWLINE"

    "continue" "label"? _"NEWLINE"

    "let" pat (_":" type_)? "=" letRhs

    loopLabel? "for" pat (_":" type_)? "in" inlineExpr _":" _"NEWLINE" _"INDENT" stmt+ _"DEDENT"

    loopLabel? "while" inlineExpr _":" _"NEWLINE" _"INDENT" stmt+ _"DEDENT"

    loopLabel? "loop" _":" _"NEWLINE" _"INDENT" stmt+ _"DEDENT"

    inlineExpr stmtExprCont?

    blockExpr


loopLabel:
    "label" _":"


letRhs:
    inlineExpr _"NEWLINE"
    blockExpr


stmtExprCont:
    _"NEWLINE"
    assignOp blockExpr
    assignOp inlineExpr _"NEWLINE"


assignOp:
    "="
    "+="
    "-="
    "*="
    "^="


# --------------------------------------------------------------------------------------------------
# Patterns

pat:
    simplePat ("|" simplePat)*


simplePat:
    # Variables
    "LowerId"

    # Constructors
    upperIdPath _"(" ".." _")"
    upperIdPath (_"(" recordFieldPat (_"," recordFieldPat)* (_"," "..")? _")")?

    # Records: `(pat, pat)`, `(var = pat, ...)`
    "(" ")"
    "(" (recordFieldPat (_"," recordFieldPat)* _","?)? ")"
    "(" (recordFieldPat (_"," recordFieldPat)* _"," "..")? ")"

    # Ignore
    "_"

    # Literals.
    "Str" strPfxBinder?
    "Char"


strPfxBinder:
    "LowerId"
    _"_"


recordFieldPat:
    "LowerId" "=" pat
    pat
|#

# --------------------------------------------------------------------------------------------------
# Import declarations

importDecl Vec[Str]:
    _"import" p0="UpperId" ps=(_"." p="UpperId")* _"NEWLINE":
        let vec: Vec[Str] = once(p0.text).chain(ps.iter().map(|p: (p: Token)|: p.p.text)).toVec()
        vec


#|
# --------------------------------------------------------------------------------------------------
# Top-level functions

topFunDecl:
    "prim" topFunSig _"NEWLINE"
    topFunSig _":" _"NEWLINE" _"INDENT" stmt+ _"DEDENT"
    topFunSig _":" inlineExpr _"NEWLINE"


topFunSig:
    parentTy? "LowerId" context? paramList returnTy?


# TODO: Weird name, rename.
parentTy:
    "UpperId" _"."


context:
    _"[" type_ (_"," type_)* _","? _"]"


paramList:
    _"(" _")"
    _"(" param (_"," param)* _","? _")"


param:
    "LowerId" (_":" type_)?


# --------------------------------------------------------------------------------------------------
# Trait declarations

traitDecl:
    _"trait" "UpperId" _"[" typeParams _"]" traitDeclRhs?


traitDeclRhs:
    _"NEWLINE"
    _":" _"NEWLINE" _"INDENT" funDecl+ _"DEDENT"


funSig:
    "LowerId" context? paramList returnTy?


# --------------------------------------------------------------------------------------------------
# Impl declarations

implDecl:
    _"impl" context? "UpperId" _"[" type_ (_"," type_)* _","? _"]" implDeclRhs


implDeclRhs:
    _"NEWLINE"
    _":" _"NEWLINE" _"INDENT" funDecl+ _"DEDENT"


# --------------------------------------------------------------------------------------------------

funDecl:
    "prim" funSig _"NEWLINE"
    funSig funDeclRhs

funDeclRhs:
    _"NEWLINE"
    _":" _"NEWLINE" _"INDENT" stmt+ _"DEDENT"
    _":" inlineExpr _"NEWLINE"

|#
