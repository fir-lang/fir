import Error    # imports Loc
# TODO: Why is Loc in Error module?

type TokenIdx(idx: U32)

trait Tokens[t]:
    firstToken(self: t) TokenIdx
    lastToken(self: t) TokenIdx

type Id(token: TokenIdx)

impl Tokens[Id]:
    firstToken(self: Id) TokenIdx: self.token
    lastToken(self: Id) TokenIdx: self.token

## A top-level declaration.
type TopDecl:
    ## A type declaration: `type T: ...`.
    Type(TypeDecl)

    ## A function declaration: `f(...) = ...`.
    Fun(FunDecl)

    ## An import declaration.
    Import(ImportDecl)

    ## A trait declaration.
    Trait(TraitDecl)

    ## An `impl` block, implementing a trait or associated methods for a type.
    Impl(ImplDecl)

## A type declaration: `type Vec[t]: ...`.
type TypeDecl(
    ## The type name. `Vec` in the example.
    name: Id,

    ## Type parameters of the type. `[t]` in the example.
    typeParams: Vec[Id],

    ## Kinds of `type_params`. Filled in by kind inference.
    typeParamKinds: Vec[Kind],

    ## Constructors of the type.
    rhs: Option[TypeDeclRhs],
)

## Constructors of a type declaration.
type TypeDeclRhs:
    ## A sum type, with more than one constructor.
    Sum(Vec[ConDecl])

    ## A product type uses the type name as the constructor and only has fields.
    Product(ConFields)

## A sum type constructor.
type ConDecl(
    name: Id,
    fields: ConFields,
)

type Kind:
    Star
    Row(RecordOrVariant)

type RecordOrVariant:
    Record
    Variant

type ConFields:
    Empty
    Named(Vec[(name: Id, ty: Type)])
    Unnamed(Vec[Type])

type FunDecl(
    ## Only in associated functions: the parent type. E.g. `Vec` in `Vec.push(...) = ...`.
    parentTy: Option[Id],

    ## Name of the function.
    name: Id,

    ## Type signature of the function.
    sig: FunSig,

    ## Body (code) of the function. Not available in `prim` functions.
    body: Option[Vec[Stmt]],
)

type FunSig(
    context: Context,
    self_: SelfParam,
    params: Vec[(name: Id, ty: Option[Type])],
    exceptions: Option[Type],
    returnTy: Option[Type],
)

type SelfParam:
    No
    Implicit
    Explicit(Type)

type ImportDecl(
    ## Import path, e.g. `Fir.Prelude`.
    path: Vec[Str],
    # TODO: Imported thing list, renaming (`as`).
)

type TraitDecl(
    ## Trait name.
    name: Id,

    ## Type parameters of the trait.
    typeParams: Vec[Id],

    ## Kinds of `type_params`. Filled in by kind inference.
    typeParamKinds: Vec[Kind],

    ## Methods of the trait.
    items: Vec[FunDecl],
)

## An `impl` block, implementing a trait for a type.
##
## ```
## impl[ToStr[a]] ToStr[Vec[a]]:
##   toStr(self): Str = ...
##
## impl Iterator[VecIter[a], a]:
##   next(self): Option[a] = ...
## ```
type ImplDecl(
    ## Predicates of the `impl` block.
    ##
    ## In the example: `[ToStr[a]]`.
    context: Context,

    ## The trait name.
    ##
    ## In the example: `ToStr`.
    trait_: Id,

    ## Type parameters of the trait.
    ##
    ## In the example: `[Vec[a]]`.
    tys: Vec[Type],

    ## Method implementations.
    items: Vec[FunDecl],
)

type Type:
    ## A type constructor, potentially applied some number of arguments. E.g. `I32`, `Vec[T]`.
    Named(NamedType)

    ## A type variable.
    ##
    ## We don't have higher-kinded types for now, so type variables cannot be applied.
    Var(Id)

    ## An anonymous record type, e.g. `(x: I32, y: I32)`, `(a: Str, ..R)`.
    Record(RecordType)

    ## An anonymous variant type, e.g. `[Error(msg: Str), Ok, ..R]`.
    Variant(VariantType)

    ## A function type: `Fn(I32): Bool`.
    Fn_(FnType)

type RecordType(
    fields: Vec[Named[Type]],
    extension: Option[Id],
    isRow: Bool,
)

type VariantType(
    alts: Vec[VariantAlt],
    extension: Option[Id],
    isRow: Bool,
)

type FnType(
    args: Vec[Type],

    ## Optional return type of the function. `()` when omitted.
    ret: Option[Type],

    ## Same as `FunSig.exceptions`.
    exceptions: Option[Type],
)

type VariantAlt(
    con: Id,
    fields: Vec[Named[Type]],
)

## Type parameter and predicates of an `impl` or function.
##
## E.g. `[Iterator[iter, item], Debug[item]]`.
type Context(
    ## Type parameters, generated by the type checker.
    typeParams: Vec[(name: Id, kind: Kind)],

    ## Predicates: `Iterator[iter, item]` and `Debug[item]` in the example.
    preds: Vec[Type],
)

## A named type, e.g. `I32`, `Vec[I32]`, `Iterator[coll, Str]`.
type NamedType(
    ## Name of the type constructor, e.g. `I32`, `Vec`, `Iterator`.
    name: Id,

    ## Arguments of the type constructor.
    args: Vec[Type],
)

type Named[t](
    name: Option[Id],
    node: t,
)

type Stmt:
    Let(LetStmt)
    Assign(AssignStmt)
    Expr(Expr)
    For(ForStmt)
    While(WhileStmt)
    Loop(LoopStmt)
    Break(BreakStmt)
    Continue(ContinueStmt)

impl Tokens[Stmt]:
    firstToken(self: Stmt) TokenIdx:
        match self:
            Stmt.Let(e): e.firstToken()
            Stmt.Assign(e): e.firstToken()
            Stmt.Expr(e): e.firstToken()
            Stmt.For(e): e.firstToken()
            Stmt.While(e): e.firstToken()
            Stmt.Loop(e): e.firstToken()
            Stmt.Break(e): e.firstToken()
            Stmt.Continue(e): e.firstToken()

    lastToken(self: Stmt) TokenIdx:
        match self:
            Stmt.Let(e): e.lastToken()
            Stmt.Assign(e): e.lastToken()
            Stmt.Expr(e): e.lastToken()
            Stmt.For(e): e.lastToken()
            Stmt.While(e): e.lastToken()
            Stmt.Loop(e): e.lastToken()
            Stmt.Break(e): e.lastToken()
            Stmt.Continue(e): e.lastToken()

## A let statement: `let x: T = expr`.
type LetStmt(
    lhs: Pat,
    ty: Option[Type],
    rhs: Expr,
    _firstToken: TokenIdx,
)

impl Tokens[LetStmt]:
    firstToken(self: LetStmt) TokenIdx: self._firstToken
    lastToken(self: LetStmt) TokenIdx: self.rhs.lastToken()

type AssignStmt(
    lhs: Expr,
    rhs: Expr,
    op: AssignOp,
)

impl Tokens[AssignStmt]:
    firstToken(self: AssignStmt) TokenIdx: self.lhs.firstToken()
    lastToken(self: AssignStmt) TokenIdx: self.rhs.lastToken()

type AssignOp:
    Eq
    PlusEq
    MinusEq
    StarEq
    CaretEq

type ForStmt(
    label: Option[Id],
    pat: Pat,

    ## Type annotation on the loop variable, the `item` type in `Iterator[iter, item]`.
    astTy: Option[Type],

    ## `ast_ty`, converted to type checking types by the type checker.
    tcTy: Option[Type],  # TODO: type-checking type

    expr: Expr,

    ## Filled in by the type checker: the iterator type. `iter` in `Iterator[iter, item]`.
    exprTy: Option[Type], # TODO: type-checking type

    body: Vec[Stmt],

    _firstToken: TokenIdx,
)

impl Tokens[ForStmt]:
    firstToken(self: ForStmt) TokenIdx: self._firstToken
    lastToken(self: ForStmt) TokenIdx: self.body.last().unwrap().lastToken()

type WhileStmt(
    label: Option[Id],
    cond: Expr,
    body: Vec[Stmt],
    _firstToken: TokenIdx,
)

impl Tokens[WhileStmt]:
    firstToken(self: WhileStmt) TokenIdx: self._firstToken
    lastToken(self: WhileStmt) TokenIdx: self.body.last().unwrap().lastToken()

type LoopStmt(
    body: Vec[Stmt],
    _firstToken: TokenIdx,
)

impl Tokens[LoopStmt]:
    firstToken(self: LoopStmt) TokenIdx: self._firstToken
    lastToken(self: LoopStmt) TokenIdx: self.body.last().unwrap().lastToken()

type BreakStmt(
    label: Option[Id],

    ## How many levels of loops to break. Parser initializes this as 0, type checker updates
    ## based on the labels of enclosing loops.
    level: U32,

    _firstToken: TokenIdx,
)

impl Tokens[BreakStmt]:
    firstToken(self: BreakStmt) TokenIdx: self._firstToken

    lastToken(self: BreakStmt) TokenIdx:
        match self.label:
            Option.Some(id): id.lastToken()
            Option.None: self._firstToken

type ContinueStmt(
    label: Option[Id],

    ## Same as `BreakStmt.level`.
    level: U32,

    _firstToken: TokenIdx,
)

impl Tokens[ContinueStmt]:
    firstToken(self: ContinueStmt) TokenIdx: self._firstToken

    lastToken(self: ContinueStmt) TokenIdx:
        match self.label:
            Option.Some(id): id.lastToken()
            Option.None: self._firstToken

type Pat:
    ## Matches anything, binds it to variable.
    Var(VarPat)

    ## Matches a constructor.
    Constr(ConstrPat)

    Record(RecordPat)

    ## Underscore, aka. wildcard.
    Ignore(TokenIdx)

    ## Matches the string.
    Str(Str, TokenIdx)

    ## Matches the character.
    Char(Char, TokenIdx)

    ## Or pattern: `<pat1> | <pat2>`.
    Or(Pat, Pat)

impl Tokens[Pat]:
    firstToken(self: Pat) TokenIdx:
        match self:
            Pat.Var(pat)
                | Pat.Constr(pat)
                | Pat.Record(pat)
                | Pat.Or(_, pat): pat.firstToken()

            Pat.Ignore(tok)
                | Pat.Str(_, tok)
                | Pat.Char(_, tok): tok

    lastToken(self: Pat) TokenIdx:
        match self:
            Pat.Var(pat)
                | Pat.Constr(pat)
                | Pat.Record(pat)
                | Pat.Or(_, pat): pat.lastToken()

            Pat.Ignore(tok)
                | Pat.Str(_, tok)
                | Pat.Char(_, tok): tok

type VarPat(
    var_: Id,

    ## Inferred type of the binder. Filled in by the type checker.
    ty: Option[Type],    # TODO: This should be type-checking type instead of AST type
)

impl Tokens[VarPat]:
    firstToken(self: VarPat) TokenIdx: self.var_.firstToken()
    lastToken(self: VarPat) TokenIdx: self.var_.lastToken()

type ConstrPat(
    constr: Constructor,
    fields: Vec[Named[Pat]],
    ignoreRest: Bool,
    _lastToken: TokenIdx,
)

impl Tokens[ConstrPat]:
    firstToken(self: ConstrPat) TokenIdx: self.constr.firstToken()
    lastToken(self: ConstrPat) TokenIdx: self._lastToken

type RecordPat(
    fields: Vec[Named[Pat]],
    ignoreRest:Bool,
    inferredTy: Option[Type],   # TODO: This should be type-checking type instead of AST type
    _firstToken: TokenIdx,
    _lastToken: TokenIdx,
)

impl Tokens[Constructor]:
    firstToken(self: Constructor) TokenIdx: self._firstToken
    lastToken(self: Constructor) TokenIdx: self._lastToken

type Constructor(
    variant: Bool,

    ## Type of the constructor.
    ty: Id,

    ## Name of the constructor. Only in sum types.
    constr: Option[Id],

    ## Type arguments explicitly passed to the variable. Only empty when not specified. Otherwise
    ## there will be always one element.
    ##
    ## Always empty in patterns.
    userTyArgs: Vec[Type],

    ## Inferred type arguments of the constructor's type. Filled in by the type checker.
    tyArgs: Vec[Type],

    # In variant constructors we'll see a '~' before `ty`, so we can't use `ty` as the first token.
    _firstToken: TokenIdx,

    _lastToken: TokenIdx,
)

impl Tokens[Constructor]:
    firstToken(self: Constructor) TokenIdx: self._firstToken
    lastToken(self: Constructor) TokenIdx: self._lastToken

type Expr:
    ## A variable: `x`.
    Var(VarExpr)

    ## A constructor: `Option.None`, `Result.Ok`, `Bool.True`, `Vec`.
    ConstrSelect(Constructor)

    ## A field selection: `<expr>.x` where `x` is a field.
    ##
    ## Parser generates this node for all expression of form `<expr>.<id>`, type checker converts
    ## method selection expressions to `MethodSelect`.
    FieldSelect(FieldSelectExpr)

    ## A method selection: `<expr>.x` where `x` is a method.
    ##
    ## This node is generated by the type checker.
    MethodSelect(MethodSelectExpr)

    ## An associated function or method selection:
    ##
    ## - Associated function: `Vec.withCapacity`.
    ## - Method: `Vec.push`.
    AssocFnSelect(AssocFnSelectExpr)

    ## A function call: `f(a)`.
    Call(CallExpr)

    ## An integer literal.
    Int(IntExpr)

    ## A string literal.
    Str(StrExpr)

    ## A character literal.
    Char(CharExpr)

    Self(TokenIdx)

    ## A binary operator: `x + y`, `i >> 2`.
    ##
    ## Some of the binary operators are desugared to method calls by the type checker.
    BinOp(BinOpExpr)

    ## A unary operator: `-x`, `!b`.
    ##
    ## Some of the unary operators are desugared to method calls by the type checker.
    UnOp(UnOpExpr)

    ## A record: `(1, 2)`, `(x = 123, msg = "hi")`.
    Record(RecordExpr)

    Return(ReturnExpr)

    Match(MatchExpr)

    If(IfExpr)

    Fn_(FnExpr)

    Is(IsExpr)

    Do(DoExpr)

    # A sequence: `[a, b, c]`, `[a = b, c = d]`, `Vec.[...]`. Can be empty.
    Seq(SeqExpr)

impl Tokens[Expr]:
    firstToken(self: Expr) TokenIdx:
        match self:
            Expr.Var(e): e.firstToken()
            Expr.ConstrSelect(e): e.firstToken()
            Expr.FieldSelect(e): e.firstToken()
            Expr.MethodSelect(e): e.firstToken()
            Expr.AssocFnSelect(e): e.firstToken()
            Expr.Call(e): e.firstToken()
            Expr.Int(e): e.firstToken()
            Expr.Str(e): e.firstToken()
            Expr.Char(e): e.firstToken()
            Expr.Self(t): t
            Expr.BinOp(e): e.firstToken()
            Expr.UnOp(e): e.firstToken()
            Expr.Record(e): e.firstToken()
            Expr.Return(e): e.firstToken()
            Expr.Match(e): e.firstToken()
            Expr.If(e): e.firstToken()
            Expr.Fn_(e): e.firstToken()
            Expr.Is(e): e.firstToken()
            Expr.Do(e): e.firstToken()
            Expr.Seq(e): e.firstToken()

    lastToken(self: Expr) TokenIdx:
        match self:
            Expr.Var(e): e.lastToken()
            Expr.ConstrSelect(e): e.lastToken()
            Expr.FieldSelect(e): e.lastToken()
            Expr.MethodSelect(e): e.lastToken()
            Expr.AssocFnSelect(e): e.lastToken()
            Expr.Call(e): e.lastToken()
            Expr.Int(e): e.lastToken()
            Expr.Str(e): e.lastToken()
            Expr.Char(e): e.lastToken()
            Expr.Self(t): t
            Expr.BinOp(e): e.lastToken()
            Expr.UnOp(e): e.lastToken()
            Expr.Record(e): e.lastToken()
            Expr.Return(e): e.lastToken()
            Expr.Match(e): e.lastToken()
            Expr.If(e): e.lastToken()
            Expr.Fn_(e): e.lastToken()
            Expr.Is(e): e.lastToken()
            Expr.Do(e): e.lastToken()
            Expr.Seq(e): e.lastToken()

type VarExpr(
    id: Id,

    # Type arguments explicitly passed to the variable. Only empty when not specified. Otherwise
    # there will be always one element.
    userTyArgs: Vec[Type],

    ## Inferred type arguments of the variable. Filled in by the type checker.
    tyArgs: Vec[Type],

    _lastToken: TokenIdx,
)

impl Tokens[VarExpr]:
    firstToken(self: VarExpr) TokenIdx: self.id.firstToken()
    lastToken(self: VarExpr) TokenIdx: self._lastToken

type FieldSelectExpr(
    object: Expr,

    field: Id,

    ## Type arguments explicitly passed to the variable. Only empty when not specified. Otherwise
    ## there will be always one element.
    ##
    ## Since fields can't have `forall` quantifiers, this will only be valid when the field is a
    ## method, in which case the type checker will convert this node into `MethodSelectExpr`.
    userTyArgs: Vec[Type],
)

impl Tokens[FieldSelectExpr]:
    firstToken(self: FieldSelectExpr) TokenIdx: self.object.firstToken()
    lastToken(self: FieldSelectExpr) TokenIdx: self.field.lastToken()

## A method selection: `<expr>.method`.
##
## This node is generated by the type checker, from `Expr::FieldSelect`.
##
## Methods are always associated functions. They can be associated to a type (e.g. `Vec.push`) or
## trait methods (e.g. `Iterator.next`).
type MethodSelectExpr(
    ## The reciever, `<expr>` in `<expr>.method`.
    object: Expr,

    ## Type of `object` (receiver), filled in by the type checker.
    ##
    ## This type will always be a type constructor, potentially with arguments, as types without
    ## type constructors (records etc.) don't have methods.
    ##
    ## The type constructor will be the type with the associated function with `method` as the name
    ## and a `self` parameter that matches this type.
    # TODO: We could have separate fields for the ty con and args.
    # TODO: We could also add types to every expression if it's going to help with monomorphisation.
    #       For efficiency though, we should only annotate inferred types and then type check from
    #       the top-level expression every time we need to compute type of an expr.
    objectTy: Option[Type],  # TODO: type-checking type

    ## The type or trait id that defines the method.
    ##
    ## E.g. `Vec`, `Iterator`.
    ##
    ## Note: when calling trait methods, this will be the trait type rather than the receiver type.
    methodTyId: Id,

    ## The method id.
    ##
    ## E.g. `push`, `next`.
    method: Id,

    ## Type arguments of `method_ty_id`.
    ##
    ## If the method is for a trait, the first arguments here will be for the trait type parameters.
    ## E.g. in `Iterator.next`, the first two argumetns will be the `iter` and `item` parameters of
    ## `trait Iterator[iter, item]`.
    ##
    ## (If the method is not a trait method, then we don't care about the type parameter order.. I
    ## think?)
    tyArgs: Vec[Type],       # TODO: type-checking type

    _lastToken: TokenIdx
)


impl Tokens[MethodSelectExpr]:
    firstToken(self: MethodSelectExpr) TokenIdx: self.object.firstToken()
    lastToken(self: MethodSelectExpr) TokenIdx: self._lastToken

## An associated function or method selection:
##
## - Associated function: `Vec.withCapacity`.
## - Method: `Vec.push`.
type AssocFnSelectExpr(
    ty: Id,
    member: Id,

    ## Type arguments explicitly passed to the variable. Only empty when not specified. Otherwise
    ## there will be always one element.
    userTyArgs: Vec[Type],

    ## Inferred type arguments of the type and associated function. Filled in by the type checker.
    tyArgs: Vec[Type],       # TODO: type-checking type

    _lastToken: TokenIdx
)

impl Tokens[AssocFnSelectExpr]:
    firstToken(self: AssocFnSelectExpr) TokenIdx: self.ty.firstToken()
    lastToken(self: AssocFnSelectExpr) TokenIdx: self._lastToken

type CallExpr(
    fun: Expr,
    args: Vec[Named[Expr]],
    _lastToken: TokenIdx
)

impl Tokens[CallExpr]:
    firstToken(self: CallExpr) TokenIdx: self.fun.firstToken()
    lastToken(self: CallExpr) TokenIdx: self._lastToken

type IntExpr(
    ## The digits of the integer, without any prefix ("0x" or "0b") and suffix ("u32" etc.).
    ##
    ## The digits will be parsed during type checking. If the integer doesn't have a suffix, parsing
    ## will be done based on the inferred type of the integer.
    text: Str,

    ## The type checker updates this based on the inferred type of the integer.
    suffix: Option[IntKind],

    radix: U32,

    ## Filled in by the type checker. The parsed integer.
    ##
    ## This will be the integer value in two's complement, extended to unsiged 32-bit.
    ## E.g. `-1u8` will be `0x000000ff`, instead of `0xffffffff`.
    parsed: U32,

    token: TokenIdx,
)

impl Tokens[IntExpr]:
    firstToken(self: IntExpr) TokenIdx: self.token
    lastToken(self: IntExpr) TokenIdx: self.token

type StrExpr(
    parts: Vec[StrPart],
    token: TokenIdx,
)

impl Tokens[StrExpr]:
    firstToken(self: StrExpr) TokenIdx: self.token
    lastToken(self: StrExpr) TokenIdx: self.token

type StrPart:
    Str(Str)
    Expr(Expr)

type CharExpr(
    char: Char,
    token: TokenIdx,
)

impl Tokens[CharExpr]:
    firstToken(self: CharExpr) TokenIdx: self.token
    lastToken(self: CharExpr) TokenIdx: self.token

type BinOpExpr(
    left: Expr,
    right: Expr,
    op: BinOp,
)

impl Tokens[BinOpExpr]:
    firstToken(self: BinOpExpr) TokenIdx: self.left.firstToken()
    lastToken(self: BinOpExpr) TokenIdx: self.right.lastToken()

type BinOp:
    Add
    And
    BitAnd
    BitOr
    Divide
    Equal
    Gt
    GtEq
    LeftShift
    Lt
    LtEq
    Multiply
    NotEqual
    Or
    RightShift
    Subtract

type UnOpExpr(
    op: UnOp,
    expr: Expr,
    _firstToken: TokenIdx,
)

impl Tokens[UnOpExpr]:
    firstToken(self: UnOpExpr) TokenIdx: self._firstToken
    lastToken(self: UnOpExpr) TokenIdx: self.expr.lastToken()

type RecordExpr(
    fields: Vec[Named[Expr]],
    _firstToken: TokenIdx,
    _lastToken: TokenIdx,
)

impl Tokens[RecordExpr]:
    firstToken(self: RecordExpr) TokenIdx: self._firstToken
    lastToken(self: RecordExpr) TokenIdx: self._lastToken

type ReturnExpr(
    expr: Option[Expr],
    _firstToken: TokenIdx,
)

impl Tokens[ReturnExpr]:
    firstToken(self: ReturnExpr) TokenIdx: self._firstToken

    lastToken(self: ReturnExpr) TokenIdx:
        match self.expr:
            Option.Some(expr): expr.lastToken()
            Option.None: self._firstToken

type MatchExpr(
    scrutinee: Expr,
    alts: Vec[Alt],
    _firstToken: TokenIdx,
)

impl Tokens[MatchExpr]:
    firstToken(self: MatchExpr) TokenIdx: self._firstToken
    lastToken(self: MatchExpr) TokenIdx: self.alts.last().unwrap().lastToken()

type Alt(
    pattern: Pat,
    guard: Option[Expr],
    rhs: Vec[Stmt],
)

impl Tokens[Alt]:
    firstToken(self: Alt) TokenIdx: self.pattern.firstToken()
    lastToken(self: Alt) TokenIdx: self.rhs.last().unwrap().lastToken()

type IfExpr(
    # At least one element
    branches: Vec[(guard: Expr, body: Vec[Stmt])],
    elseBranch: Option[Vec[Stmt]],
    _firstToken: TokenIdx
)

impl Tokens[IfExpr]:
    firstToken(self: IfExpr) TokenIdx:
        self._firstToken

    lastToken(self: IfExpr) TokenIdx:
        if self.elseBranch is Option.Some(block):
            return block.last().unwrap().lastToken()

        self.branches.last().unwrap().body.last().unwrap().lastToken()

type FnExpr(
    sig: FunSig,
    body: Vec[Stmt],
    idx: U32,
    _firstToken: TokenIdx
)

impl Tokens[FnExpr]:
    firstToken(self: FnExpr) TokenIdx: self._firstToken
    lastToken(self: FnExpr) TokenIdx: self.body.last().unwrap().lastToken()

# <expr> is <pat>
type IsExpr(
    expr: Expr,
    pat: Pat,
)

impl Tokens[IsExpr]:
    firstToken(self: IsExpr) TokenIdx: self.expr.firstToken()
    lastToken(self: IsExpr) TokenIdx: self.pat.lastToken()

type DoExpr(
    body: Vec[Stmt],
    _firstToken: TokenIdx,
)

impl Tokens[DoExpr]:
    firstToken(self: DoExpr) TokenIdx: self._firstToken
    lastToken(self: DoExpr) TokenIdx: self.body.last().unwrap().lastToken()

type UnOp:
    Not
    Neg

type SeqExpr(
    ty: Option[Type],
    elems: Vec[(key: Option[Expr], value: Expr)],
    _firstToken: TokenIdx,
    _lastToken: TokenIdx,
)

impl Tokens[SeqExpr]:
    firstToken(self: SeqExpr) TokenIdx: self._firstToken
    lastToken(self: SeqExpr) TokenIdx: self._lastToken

# --------------------------------------------------------------------------------------------------

impl ToStr[BinOp]:
    toStr(self: BinOp) Str:
        match self:
            BinOp.Add: "Add"
            BinOp.And: "And"
            BinOp.BitAnd: "BitAnd"
            BinOp.BitOr: "BitOr"
            BinOp.Divide: "Divide"
            BinOp.Equal: "Equal"
            BinOp.Gt: "Gt"
            BinOp.GtEq: "GtEq"
            BinOp.LeftShift: "LeftShift"
            BinOp.Lt: "Lt"
            BinOp.LtEq: "LtEq"
            BinOp.Multiply: "Multiply"
            BinOp.NotEqual: "NotEqual"
            BinOp.Or: "Or"
            BinOp.RightShift: "RightShift"
            BinOp.Subtract: "Subtract"

impl Eq[BinOp]:
    __eq(self: BinOp, other: BinOp) Bool:
        match (left = self, right = other):
            (left = BinOp.Add, right = BinOp.Add): Bool.True
            (left = BinOp.And, right = BinOp.And): Bool.True
            (left = BinOp.BitAnd, right = BinOp.BitOr): Bool.True
            (left = BinOp.Divide, right = BinOp.Divide): Bool.True
            (left = BinOp.Equal, right = BinOp.Equal): Bool.True
            (left = BinOp.Gt, right = BinOp.Gt): Bool.True
            (left = BinOp.GtEq, right = BinOp.GtEq): Bool.True
            (left = BinOp.LeftShift, right = BinOp.LeftShift): Bool.True
            (left = BinOp.Lt, right = BinOp.Lt): Bool.True
            (left = BinOp.LtEq, right = BinOp.LtEq): Bool.True
            (left = BinOp.Multiply, right = BinOp.Multiply): Bool.True
            (left = BinOp.NotEqual, right = BinOp.NotEqual): Bool.True
            (left = BinOp.Or, right = BinOp.Or): Bool.True
            (left = BinOp.RightShift, right = BinOp.RightShift): Bool.True
            (left = BinOp.Subtract, right = BinOp.Subtract): Bool.True
            _: Bool.False
