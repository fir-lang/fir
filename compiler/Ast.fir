## Things with location information.
type L[a]:
    loc: Loc
    node: a

type Id:
    name: Str
    idx: U32
    loc: Loc

## A top-level declaration.
type TopDecl:
    ## A type declaration: `type T: ...`.
    Type(L[TypeDecl])

    ## A function declaration: `f(...) = ...`.
    Fun(L[FunDecl])

    ## An import declaration.
    Import(L[ImportDecl])

    ## A trait declaration.
    Trait(L[TraitDecl])

    ## An `impl` block, implementing a trait or associated methods for a type.
    Impl(L[ImplDecl])

## A type declaration: `type Vec[t]: ...`.
type TypeDecl:
    ## The type name. `Vec` in the example.
    name: Id

    ## Type parameters of the type. `[t]` in the example.
    typeParams: Vec[Id]

    ## Kinds of `type_params`. Filled in by kind inference.
    typeParamKinds: Vec[Kind]

    ## Constructors of the type.
    rhs: Option[TypeDeclRhs]

## Constructors of a type declaration.
type TypeDeclRhs:
    ## A sum type, with more than one constructor.
    Sum(Vec[ConstructorDecl])

    ## A product type uses the type name as the constructor and only has fields.
    Product(ConstructorFields)

## A sum type constructor.
type ConstructorDecl:
    name: Id
    fields: ConstructorFields

type Kind:
    Star
    Row(RecordOrVariant)

type RecordOrVariant:
    Record
    Variant

type ConstructorFields:
    Empty
    Named(Vec[(name: Id, ty: L[Type])])
    Unnamed(Vec[L[Type]])

type FunDecl:
    ## Only in associated functions: the parent type. E.g. `Vec` in `Vec.push(...) = ...`.
    parentTy: Option[Id]

    ## Name of the function.
    name: Id

    ## Type signature of the function.
    sig: FunSig

    ## Body (code) of the function. Not available in `prim` functions.
    body: Option[Vec[L[Stmt]]]

type FunSig:
    context: Context
    self_: SelfParam
    params: Vec[(name: Id, ty: L[Type])]
    exceptions: Option[L[Type]]
    returnTy: Option[L[Type]]

type SelfParam:
    No
    Implicit
    Explicit(L[Type])

type ImportDecl:
    ## Import path, e.g. `Fir.Prelude`.
    path: Vec[Str]
    # TODO: Imported thing list, renaming (`as`).

type TraitDecl:
    ## Trait name.
    name: Id

    ## Type parameters of the trait.
    typeParams: Vec[Id]

    ## Kinds of `type_params`. Filled in by kind inference.
    typeParamKinds: Vec[Kind]

    ## Methods of the trait.
    items: Vec[FunDecl]

## An `impl` block, implementing a trait for a type.
##
## ```
## impl[ToStr[a]] ToStr[Vec[a]]:
##   toStr(self): Str = ...
##
## impl Iterator[VecIter[a], a]:
##   next(self): Option[a] = ...
## ```
type ImplDecl:
    ## Predicates of the `impl` block.
    ##
    ## In the example: `[ToStr[a]]`.
    context: Context

    ## The trait name.
    ##
    ## In the example: `ToStr`.
    trait_: Id

    ## Type parameters of the trait.
    ##
    ## In the example: `[Vec[a]]`.
    tys: Vec[L[Type]]

    ## Method implementations.
    items: Vec[FunDecl]

type Type:
    ## A type constructor, potentially applied some number of arguments. E.g. `I32`, `Vec[T]`.
    Named(NamedType)

    ## A type variable.
    ##
    ## We don't have higher-kinded types for now, so type variables cannot be applied.
    Var(Id)

    ## An anonymous record type, e.g. `(x: I32, y: I32)`, `(a: Str, ..R)`.
    Record:
        fields: Vec[Named[L[Type]]]
        extension: Option[Id]

    ## An anonymous variant type, e.g. `[Error(msg: Str), Ok, ..R]`.
    Variant:
        alts: Vec[VariantAlt]
        extension: Option[Id]

    ## A function type: `Fn(I32): Bool`.
    Fn_(FnType)

type FnType:
    args: Vec[L[Type]]

    ## Optional return type of the function. `()` when omitted.
    ret: Option[L[Type]]

    ## Same as `FunSig.exceptions`.
    exceptions: Option[L[Type]]

type VariantAlt:
    con: Id
    fields: Vec[Named[L[Type]]]

## Type parameter and predicates of an `impl` or function.
##
## E.g. `[Iterator[iter, item], Debug[item]]`.
type Context:
    ## Type parameters, generated by the type checker.
    typeParams: Vec[(name: Id, kind: Kind)]

    ## Predicates.
    preds: Vec[L[Type]]

## A named type, e.g. `I32`, `Vec[I32]`, `Iterator[coll, Str]`.
type NamedType:
    ## Name of the type constructor, e.g. `I32`, `Vec`, `Iterator`.
    name: Id

    ## Arguments of the type constructor.
    args: Vec[L[Type]]

type Named[t]:
    name: Option[Id]
    node: t

type Stmt:
    Let(LetStmt)
    Assign(AssignStmt)
    Expr(Expr)
    For(ForStmt)
    While(WhileStmt)
    Break:
        label: Option[Id]

        ## How many levels of loops to break. Parser initializes this as 0, type checker updates
        ## based on the labels of enclosing loops.
        level: U32
    Continue:
        label: Option[Id]

        ## Same as `Break.level`.
        level: U32

## A let statement: `let x: T = expr`.
type LetStmt:
    lhs: L[Pat]
    ty: Option[L[Type]]
    rhs: L[Expr]

type AssignStmt:
    lhs: L[Expr]
    rhs: L[Expr]
    op: AssignOp

type AssignOp:
    Eq
    PlusEq
    MinusEq
    StarEq
    CaretEq

type ForStmt:
    label: Option[Id]
    pat: L[Pat]

    ## Type annotation on the loop variable, the `item` type in `Iterator[iter, item]`.
    astTy: Option[L[Type]]

    ## `ast_ty`, converted to type checking types by the type checker.
    tcTy: Option[L[Type]]  # TODO: type-checking type

    expr: L[Expr]

    ## Filled in by the type checker: the iterator type. `iter` in `Iterator[iter, item]`.
    exprTy: Option[L[Type]] # TODO: type-checking type

    body: Vec[L[Stmt]]

type WhileStmt:
    label: Option[Id]
    cond: L[Expr]
    body: Vec[L[Stmt]]

type Pat:
    ## Matches anything, binds it to variable.
    Var(VarPat)

    ## Matches a constructor.
    Constr(ConstrPat)

    Record(Vec[Named[L[Pat]]])

    ## Underscore, aka. wildcard.
    Ignore

    ## Matches the string.
    Str(Str)

    ## Matches the character.
    Char(Char)

    ## Match the prefix, bind the rest. E.g. `"a" .. rest`.
    StrPfx(Str, Id)

    ## Or pattern: `<pat1> | <pat2>`.
    Or(L[Pat], L[Pat])

type VarPat:
    var_: Id
    ty: Option[L[Type]]    # TODO: This should be type-checking type instead of AST type

type ConstrPat:
    constr: Constructor
    fields: Vec[Named[L[Pat]]]

type VariantPat:
    constr: Id
    fields: Vec[Named[L[Pat]]]

type Constructor:
    variant: Bool

    ty: Id

    constr: Option[Id]

    ## Type arguments explicitly passed to the variable. Only empty when not specified. Otherwise
    ## there will be always one element.
    ##
    ## Always empty in patterns.
    userTyArgs: Vec[L[Type]]

    ## Inferred type arguments of the constructor's type. Filled in by the type checker.
    tyArgs: Vec[L[Type]]

type Expr:
    ## A variable: `x`.
    Var(VarExpr)

    ## A constructor: `Option.None`, `Result.Ok`, `Bool.True`, `Vec`.
    ConstrSelect(Constructor)

    ## A field selection: `<expr>.x` where `x` is a field.
    ##
    ## Parser generates this node for all expression of form `<expr>.<id>`, type checker converts
    ## method selection expressions to `MethodSelect`.
    FieldSelect(FieldSelectExpr)

    ## A method selection: `<expr>.x` where `x` is a method.
    ##
    ## This node is generated by the type checker.
    MethodSelect(MethodSelectExpr)

    ## An associated function or method selection:
    ##
    ## - Associated function: `Vec.withCapacity`.
    ## - Method: `Vec.push`.
    AssocFnSelect(AssocFnSelectExpr)

    ## A function call: `f(a)`.
    Call(CallExpr)

    ## An integer literal.
    Int(IntExpr)

    ## A string literal.
    Str(Vec[StrPart])

    ## A character literal.
    Char(Char)

    Self

    ## A binary operator: `x + y`, `i >> 2`.
    ##
    ## Some of the binary operators are desugared to method calls by the type checker.
    BinOp(BinOpExpr)

    ## A unary operator: `-x`, `!b`.
    ##
    ## Some of the unary operators are desugared to method calls by the type checker.
    UnOp(UnOpExpr)

    ## A record: `(1, 2)`, `(x = 123, msg = "hi")`.
    Record(Vec[Named[L[Expr]]])

    Return(L[Expr])

    Match(MatchExpr)

    If(IfExpr)

    Fn_(FnExpr)

    Is(IsExpr)

    Do(Vec[L[Stmt]])

    # A sequence: `[a, b, c]`, `[a = b, c = d]`, `Vec.[...]`. Can be empty.
    Seq(Vec[L[Stmt]])

type VarExpr:
    id: Id

    # Type arguments explicitly passed to the variable. Only empty when not specified. Otherwise
    # there will be always one element.
    userTyArgs: Vec[L[Type]]

    ## Inferred type arguments of the variable. Filled in by the type checker.
    tyArgs: Vec[L[Type]]

type ConstrExpr:
    id: Id

    ## Inferred type arguments of the constructor. Filled by the type checker.
    tyArgs: Vec[L[Type]]

type FieldSelectExpr:
    object: L[Expr]

    field: Id

    ## Type arguments explicitly passed to the variable. Only empty when not specified. Otherwise
    ## there will be always one element.
    ##
    ## Since fields can't have `forall` quantifiers, this will only be valid when the field is a
    ## method, in which case the type checker will convert this node into `MethodSelectExpr`.
    userTyArgs: Vec[L[Type]]

## A method selection: `<expr>.method`.
##
## This node is generated by the type checker, from `Expr::FieldSelect`.
##
## Methods are always associated functions. They can be associated to a type (e.g. `Vec.push`) or
## trait methods (e.g. `Iterator.next`).
type MethodSelectExpr:
    ## The reciever, `<expr>` in `<expr>.method`.
    object: L[Expr]

    ## Type of `object` (receiver), filled in by the type checker.
    ##
    ## This type will always be a type constructor, potentially with arguments, as types without
    ## type constructors (records etc.) don't have methods.
    ##
    ## The type constructor will be the type with the associated function with `method` as the name
    ## and a `self` parameter that matches this type.
    # TODO: We could have separate fields for the ty con and args.
    # TODO: We could also add types to every expression if it's going to help with monomorphisation.
    #       For efficiency though, we should only annotate inferred types and then type check from
    #       the top-level expression every time we need to compute type of an expr.
    objectTy: Option[L[Type]]  # TODO: type-checking type

    ## The type or trait id that defines the method.
    ##
    ## E.g. `Vec`, `Iterator`.
    ##
    ## Note: when calling trait methods, this will be the trait type rather than the receiver type.
    methodTyId: Id

    ## The method id.
    ##
    ## E.g. `push`, `next`.
    method: Id

    ## Type arguments of `method_ty_id`.
    ##
    ## If the method is for a trait, the first arguments here will be for the trait type parameters.
    ## E.g. in `Iterator.next`, the first two argumetns will be the `iter` and `item` parameters of
    ## `trait Iterator[iter, item]`.
    ##
    ## (If the method is not a trait method, then we don't care about the type parameter order.. I
    ## think?)
    tyArgs: Vec[L[Type]]       # TODO: type-checking type

## An associated function or method selection:
##
## - Associated function: `Vec.withCapacity`.
## - Method: `Vec.push`.
type AssocFnSelectExpr:
    ty: Id
    member: Id

    ## Type arguments explicitly passed to the variable. Only empty when not specified. Otherwise
    ## there will be always one element.
    userTyArgs: Vec[L[Type]]

    ## Inferred type arguments of the type and associated function. Filled in by the type checker.
    tyArgs: Vec[L[Type]]       # TODO: type-checking type

type CallExpr:
    fun: L[Expr]
    args: Vec[CallArg]

type CallArg:
    name: Option[Id]
    expr: L[Expr]

type IntExpr:
    ## The digits of the integer, without any prefix ("0x" or "0b") and suffix ("u32" etc.).
    ##
    ## The digits will be parsed during type checking. If the integer doesn't have a suffix, parsing
    ## will be done based on the inferred type of the integer.
    text: Str

    ## Suffix of the integer. Initially as parsed. If not available, the type checker updates this
    ## based on the inferred type of the integer.
    suffix: Option[IntKind]

    radix: U32

    ## Filled in by the type checker. The parsed integer.
    ##
    ## This will be the integer value in two's complement, extended to unsiged 32-bit.
    ## E.g. `-1u8` will be `0x000000ff`, instead of `0xffffffff`.
    parsed: U32

type StrPart:
    Str(Str)
    Expr(L[Expr])

type BinOpExpr:
    left: L[Expr]
    right: L[Expr]
    op: BinOp

type BinOp:
    Add
    And
    BitAnd
    BitOr
    Divide
    Equal
    Gt
    GtEq
    LeftShift
    Lt
    LtEq
    Multiply
    NotEqual
    Or
    RightShift
    Subtract

type UnOpExpr:
    op: UnOp
    expr: L[Expr]

type VariantExpr:
    id: Id
    args: Vec[Named[L[Expr]]]

type MatchExpr:
    scrutinee: L[Expr]
    alts: Vec[Alt]

type Alt:
    pattern: L[Pat]
    guard: Option[L[Expr]]
    rhs: Vec[L[Stmt]]

type IfExpr:
    # At least one element
    branches: Vec[(guard: L[Expr], body: Vec[L[Stmt]])]
    else_branch: Option[Vec[L[Stmt]]]

type FnExpr:
    sig: FunSig
    body: Vec[L[Stmt]]
    idx: U32

type IsExpr:
    expr: L[Expr]
    pat: L[Pat]

type UnOp:
    Not
    Neg

# --------------------------------------------------------------------------------------------------

impl ToStr[BinOp]:
    toStr(self: BinOp) Str:
        match self:
            BinOp.Add: "Add"
            BinOp.And: "And"
            BinOp.BitAnd: "BitAnd"
            BinOp.BitOr: "BitOr"
            BinOp.Divide: "Divide"
            BinOp.Equal: "Equal"
            BinOp.Gt: "Gt"
            BinOp.GtEq: "GtEq"
            BinOp.LeftShift: "LeftShift"
            BinOp.Lt: "Lt"
            BinOp.LtEq: "LtEq"
            BinOp.Multiply: "Multiply"
            BinOp.NotEqual: "NotEqual"
            BinOp.Or: "Or"
            BinOp.RightShift: "RightShift"
            BinOp.Subtract: "Subtract"

impl Eq[BinOp]:
    __eq(self: BinOp, other: BinOp) Bool:
        match (left = self, right = other):
            (left = BinOp.Add, right = BinOp.Add): Bool.True
            (left = BinOp.And, right = BinOp.And): Bool.True
            (left = BinOp.BitAnd, right = BinOp.BitOr): Bool.True
            (left = BinOp.Divide, right = BinOp.Divide): Bool.True
            (left = BinOp.Equal, right = BinOp.Equal): Bool.True
            (left = BinOp.Gt, right = BinOp.Gt): Bool.True
            (left = BinOp.GtEq, right = BinOp.GtEq): Bool.True
            (left = BinOp.LeftShift, right = BinOp.LeftShift): Bool.True
            (left = BinOp.Lt, right = BinOp.Lt): Bool.True
            (left = BinOp.LtEq, right = BinOp.LtEq): Bool.True
            (left = BinOp.Multiply, right = BinOp.Multiply): Bool.True
            (left = BinOp.NotEqual, right = BinOp.NotEqual): Bool.True
            (left = BinOp.Or, right = BinOp.Or): Bool.True
            (left = BinOp.RightShift, right = BinOp.RightShift): Bool.True
            (left = BinOp.Subtract, right = BinOp.Subtract): Bool.True
            _: Bool.False
