import Error    # imports Loc
# TODO: Why is Loc in Error module?

type TokenIdx(idx: U32)

type Id(token: TokenIdx)

## A top-level declaration.
type TopDecl:
    ## A type declaration: `type T: ...`.
    Type(TypeDecl)

    ## A function declaration: `f(...) = ...`.
    Fun(FunDecl)

    ## An import declaration.
    Import(ImportDecl)

    ## A trait declaration.
    Trait(TraitDecl)

    ## An `impl` block, implementing a trait or associated methods for a type.
    Impl(ImplDecl)

## A type declaration: `type Vec[t]: ...`.
type TypeDecl(
    ## The type name. `Vec` in the example.
    name: Id,

    ## Type parameters of the type. `[t]` in the example.
    typeParams: Vec[Id],

    ## Kinds of `type_params`. Filled in by kind inference.
    typeParamKinds: Vec[Kind],

    ## Constructors of the type.
    rhs: Option[TypeDeclRhs],
)

## Constructors of a type declaration.
type TypeDeclRhs:
    ## A sum type, with more than one constructor.
    Sum(Vec[ConDecl])

    ## A product type uses the type name as the constructor and only has fields.
    Product(ConFields)

## A sum type constructor.
type ConDecl(
    name: Id,
    fields: ConFields,
)

type Kind:
    Star
    Row(RecordOrVariant)

type RecordOrVariant:
    Record
    Variant

type ConFields:
    Empty
    Named(Vec[(name: Id, ty: Type)])
    Unnamed(Vec[Type])

type FunDecl(
    ## Only in associated functions: the parent type. E.g. `Vec` in `Vec.push(...) = ...`.
    parentTy: Option[Id],

    ## Name of the function.
    name: Id,

    ## Type signature of the function.
    sig: FunSig,

    ## Body (code) of the function. Not available in `prim` functions.
    body: Option[Vec[Stmt]],
)

type FunSig(
    context: Context,
    self_: SelfParam,
    params: Vec[(name: Id, ty: Option[Type])],
    exceptions: Option[Type],
    returnTy: Option[Type],
)

type SelfParam:
    No
    Implicit
    Explicit(Type)

type ImportDecl(
    ## Import path, e.g. `Fir.Prelude`.
    path: Vec[Str],
    # TODO: Imported thing list, renaming (`as`).
)

type TraitDecl(
    ## Trait name.
    name: Id,

    ## Type parameters of the trait.
    typeParams: Vec[Id],

    ## Kinds of `type_params`. Filled in by kind inference.
    typeParamKinds: Vec[Kind],

    ## Methods of the trait.
    items: Vec[FunDecl],
)

## An `impl` block, implementing a trait for a type.
##
## ```
## impl[ToStr[a]] ToStr[Vec[a]]:
##   toStr(self): Str = ...
##
## impl Iterator[VecIter[a], a]:
##   next(self): Option[a] = ...
## ```
type ImplDecl(
    ## Predicates of the `impl` block.
    ##
    ## In the example: `[ToStr[a]]`.
    context: Context,

    ## The trait name.
    ##
    ## In the example: `ToStr`.
    trait_: Id,

    ## Type parameters of the trait.
    ##
    ## In the example: `[Vec[a]]`.
    tys: Vec[Type],

    ## Method implementations.
    items: Vec[FunDecl],
)

type Type:
    ## A type constructor, potentially applied some number of arguments. E.g. `I32`, `Vec[T]`.
    Named(NamedType)

    ## A type variable.
    ##
    ## We don't have higher-kinded types for now, so type variables cannot be applied.
    Var(Id)

    ## An anonymous record type, e.g. `(x: I32, y: I32)`, `(a: Str, ..R)`.
    Record(RecordType)

    ## An anonymous variant type, e.g. `[Error(msg: Str), Ok, ..R]`.
    Variant(VariantType)

    ## A function type: `Fn(I32): Bool`.
    Fn_(FnType)

type RecordType(
    fields: Vec[Named[Type]],
    extension: Option[Id],
    isRow: Bool,
)

type VariantType(
    alts: Vec[VariantAlt],
    extension: Option[Id],
    isRow: Bool,
)

type FnType(
    args: Vec[Type],

    ## Optional return type of the function. `()` when omitted.
    ret: Option[Type],

    ## Same as `FunSig.exceptions`.
    exceptions: Option[Type],
)

type VariantAlt(
    con: Id,
    fields: Vec[Named[Type]],
)

## Type parameter and predicates of an `impl` or function.
##
## E.g. `[Iterator[iter, item], Debug[item]]`.
type Context(
    ## Type parameters, generated by the type checker.
    typeParams: Vec[(name: Id, kind: Kind)],

    ## Predicates: `Iterator[iter, item]` and `Debug[item]` in the example.
    preds: Vec[Type],
)

## A named type, e.g. `I32`, `Vec[I32]`, `Iterator[coll, Str]`.
type NamedType(
    ## Name of the type constructor, e.g. `I32`, `Vec`, `Iterator`.
    name: Id,

    ## Arguments of the type constructor.
    args: Vec[Type],
)

type Named[t](
    name: Option[Id],
    node: t,
)

type Stmt:
    Let(LetStmt)
    Assign(AssignStmt)
    Expr(Expr)
    For(ForStmt)
    While(WhileStmt)
    Break(
        label: Option[Id],

        ## How many levels of loops to break. Parser initializes this as 0, type checker updates
        ## based on the labels of enclosing loops.
        level: U32,
    )
    Continue(
        label: Option[Id],

        ## Same as `Break.level`.
        level: U32,
    )

## A let statement: `let x: T = expr`.
type LetStmt(
    lhs: Pat,
    ty: Option[Type],
    rhs: Expr,
)

type AssignStmt(
    lhs: Expr,
    rhs: Expr,
    op: AssignOp,
)

type AssignOp:
    Eq
    PlusEq
    MinusEq
    StarEq
    CaretEq

type ForStmt(
    label: Option[Id],
    pat: Pat,

    ## Type annotation on the loop variable, the `item` type in `Iterator[iter, item]`.
    astTy: Option[Type],

    ## `ast_ty`, converted to type checking types by the type checker.
    tcTy: Option[Type],  # TODO: type-checking type

    expr: Expr,

    ## Filled in by the type checker: the iterator type. `iter` in `Iterator[iter, item]`.
    exprTy: Option[Type], # TODO: type-checking type

    body: Vec[Stmt],
)

type WhileStmt(
    label: Option[Id],
    cond: Expr,
    body: Vec[Stmt],
)

type Pat:
    ## Matches anything, binds it to variable.
    Var(VarPat)

    ## Matches a constructor.
    Constr(ConstrPat)

    Record(RecordPat)

    ## Underscore, aka. wildcard.
    Ignore

    ## Matches the string.
    Str(Str)

    ## Matches the character.
    Char(Char)

    ## Or pattern: `<pat1> | <pat2>`.
    Or(Pat, Pat)

type VarPat(
    var_: Id,
    ty: Option[Type],    # TODO: This should be type-checking type instead of AST type
)

type ConstrPat(
    constr: Constructor,
    fields: Vec[Named[Pat]],
    ignoreRest: Bool,
)

type RecordPat(
    fields: Vec[Named[Pat]],
    ignoreRest:Bool,
    inferredTy: Option[Type],   # TODO: This should be type-checking type instead of AST type
)

type Constructor(
    variant: Bool,

    ## Type of the constructor.
    ty: Id,

    ## Name of the constructor. Only in sum types.
    constr: Option[Id],

    ## Type arguments explicitly passed to the variable. Only empty when not specified. Otherwise
    ## there will be always one element.
    ##
    ## Always empty in patterns.
    userTyArgs: Vec[Type],

    ## Inferred type arguments of the constructor's type. Filled in by the type checker.
    tyArgs: Vec[Type],
)

type Expr:
    ## A variable: `x`.
    Var(VarExpr)

    ## A constructor: `Option.None`, `Result.Ok`, `Bool.True`, `Vec`.
    ConstrSelect(Constructor)

    ## A field selection: `<expr>.x` where `x` is a field.
    ##
    ## Parser generates this node for all expression of form `<expr>.<id>`, type checker converts
    ## method selection expressions to `MethodSelect`.
    FieldSelect(FieldSelectExpr)

    ## A method selection: `<expr>.x` where `x` is a method.
    ##
    ## This node is generated by the type checker.
    MethodSelect(MethodSelectExpr)

    ## An associated function or method selection:
    ##
    ## - Associated function: `Vec.withCapacity`.
    ## - Method: `Vec.push`.
    AssocFnSelect(AssocFnSelectExpr)

    ## A function call: `f(a)`.
    Call(CallExpr)

    ## An integer literal.
    Int(IntExpr)

    ## A string literal.
    Str(Vec[StrPart])

    ## A character literal.
    Char(Char)

    Self

    ## A binary operator: `x + y`, `i >> 2`.
    ##
    ## Some of the binary operators are desugared to method calls by the type checker.
    BinOp(BinOpExpr)

    ## A unary operator: `-x`, `!b`.
    ##
    ## Some of the unary operators are desugared to method calls by the type checker.
    UnOp(UnOpExpr)

    ## A record: `(1, 2)`, `(x = 123, msg = "hi")`.
    Record(Vec[Named[Expr]])

    Return(Expr)

    Match(MatchExpr)

    If(IfExpr)

    Fn_(FnExpr)

    Is(IsExpr)

    Do(Vec[Stmt])

    # A sequence: `[a, b, c]`, `[a = b, c = d]`, `Vec.[...]`. Can be empty.
    Seq(
        ty: Option[Type],
        elems: Vec[(key: Option[Expr], value: Expr)],
    )

type VarExpr(
    id: Id,

    # Type arguments explicitly passed to the variable. Only empty when not specified. Otherwise
    # there will be always one element.
    userTyArgs: Vec[Type],

    ## Inferred type arguments of the variable. Filled in by the type checker.
    tyArgs: Vec[Type],
)

type FieldSelectExpr(
    object: Expr,

    field: Id,

    ## Type arguments explicitly passed to the variable. Only empty when not specified. Otherwise
    ## there will be always one element.
    ##
    ## Since fields can't have `forall` quantifiers, this will only be valid when the field is a
    ## method, in which case the type checker will convert this node into `MethodSelectExpr`.
    userTyArgs: Vec[Type],
)

## A method selection: `<expr>.method`.
##
## This node is generated by the type checker, from `Expr::FieldSelect`.
##
## Methods are always associated functions. They can be associated to a type (e.g. `Vec.push`) or
## trait methods (e.g. `Iterator.next`).
type MethodSelectExpr(
    ## The reciever, `<expr>` in `<expr>.method`.
    object: Expr,

    ## Type of `object` (receiver), filled in by the type checker.
    ##
    ## This type will always be a type constructor, potentially with arguments, as types without
    ## type constructors (records etc.) don't have methods.
    ##
    ## The type constructor will be the type with the associated function with `method` as the name
    ## and a `self` parameter that matches this type.
    # TODO: We could have separate fields for the ty con and args.
    # TODO: We could also add types to every expression if it's going to help with monomorphisation.
    #       For efficiency though, we should only annotate inferred types and then type check from
    #       the top-level expression every time we need to compute type of an expr.
    objectTy: Option[Type],  # TODO: type-checking type

    ## The type or trait id that defines the method.
    ##
    ## E.g. `Vec`, `Iterator`.
    ##
    ## Note: when calling trait methods, this will be the trait type rather than the receiver type.
    methodTyId: Id,

    ## The method id.
    ##
    ## E.g. `push`, `next`.
    method: Id,

    ## Type arguments of `method_ty_id`.
    ##
    ## If the method is for a trait, the first arguments here will be for the trait type parameters.
    ## E.g. in `Iterator.next`, the first two argumetns will be the `iter` and `item` parameters of
    ## `trait Iterator[iter, item]`.
    ##
    ## (If the method is not a trait method, then we don't care about the type parameter order.. I
    ## think?)
    tyArgs: Vec[Type],       # TODO: type-checking type
)

## An associated function or method selection:
##
## - Associated function: `Vec.withCapacity`.
## - Method: `Vec.push`.
type AssocFnSelectExpr(
    ty: Id,
    member: Id,

    ## Type arguments explicitly passed to the variable. Only empty when not specified. Otherwise
    ## there will be always one element.
    userTyArgs: Vec[Type],

    ## Inferred type arguments of the type and associated function. Filled in by the type checker.
    tyArgs: Vec[Type],       # TODO: type-checking type
)

type CallExpr(
    fun: Expr,
    args: Vec[Named[Expr]],
)

type IntExpr(
    ## The digits of the integer, without any prefix ("0x" or "0b") and suffix ("u32" etc.).
    ##
    ## The digits will be parsed during type checking. If the integer doesn't have a suffix, parsing
    ## will be done based on the inferred type of the integer.
    text: Str,

    ## The type checker updates this based on the inferred type of the integer.
    suffix: Option[IntKind],

    radix: U32,

    ## Filled in by the type checker. The parsed integer.
    ##
    ## This will be the integer value in two's complement, extended to unsiged 32-bit.
    ## E.g. `-1u8` will be `0x000000ff`, instead of `0xffffffff`.
    parsed: U32,
)

type StrPart:
    Str(Str)
    Expr(Expr)

type BinOpExpr(
    left: Expr,
    right: Expr,
    op: BinOp,
)

type BinOp:
    Add
    And
    BitAnd
    BitOr
    Divide
    Equal
    Gt
    GtEq
    LeftShift
    Lt
    LtEq
    Multiply
    NotEqual
    Or
    RightShift
    Subtract

type UnOpExpr(
    op: UnOp,
    expr: Expr,
)

type MatchExpr(
    scrutinee: Expr,
    alts: Vec[Alt],
)

type Alt(
    pattern: Pat,
    guard: Option[Expr],
    rhs: Vec[Stmt],
)

type IfExpr(
    # At least one element
    branches: Vec[(guard: Expr, body: Vec[Stmt])],
    elseBranch: Option[Vec[Stmt]],
)

type FnExpr(
    sig: FunSig,
    body: Vec[Stmt],
    idx: U32,
)

type IsExpr(
    expr: Expr,
    pat: Pat,
)

type UnOp:
    Not
    Neg

# --------------------------------------------------------------------------------------------------

impl ToStr[BinOp]:
    toStr(self: BinOp) Str:
        match self:
            BinOp.Add: "Add"
            BinOp.And: "And"
            BinOp.BitAnd: "BitAnd"
            BinOp.BitOr: "BitOr"
            BinOp.Divide: "Divide"
            BinOp.Equal: "Equal"
            BinOp.Gt: "Gt"
            BinOp.GtEq: "GtEq"
            BinOp.LeftShift: "LeftShift"
            BinOp.Lt: "Lt"
            BinOp.LtEq: "LtEq"
            BinOp.Multiply: "Multiply"
            BinOp.NotEqual: "NotEqual"
            BinOp.Or: "Or"
            BinOp.RightShift: "RightShift"
            BinOp.Subtract: "Subtract"

impl Eq[BinOp]:
    __eq(self: BinOp, other: BinOp) Bool:
        match (left = self, right = other):
            (left = BinOp.Add, right = BinOp.Add): Bool.True
            (left = BinOp.And, right = BinOp.And): Bool.True
            (left = BinOp.BitAnd, right = BinOp.BitOr): Bool.True
            (left = BinOp.Divide, right = BinOp.Divide): Bool.True
            (left = BinOp.Equal, right = BinOp.Equal): Bool.True
            (left = BinOp.Gt, right = BinOp.Gt): Bool.True
            (left = BinOp.GtEq, right = BinOp.GtEq): Bool.True
            (left = BinOp.LeftShift, right = BinOp.LeftShift): Bool.True
            (left = BinOp.Lt, right = BinOp.Lt): Bool.True
            (left = BinOp.LtEq, right = BinOp.LtEq): Bool.True
            (left = BinOp.Multiply, right = BinOp.Multiply): Bool.True
            (left = BinOp.NotEqual, right = BinOp.NotEqual): Bool.True
            (left = BinOp.Or, right = BinOp.Or): Bool.True
            (left = BinOp.RightShift, right = BinOp.RightShift): Bool.True
            (left = BinOp.Subtract, right = BinOp.Subtract): Bool.True
            _: Bool.False
